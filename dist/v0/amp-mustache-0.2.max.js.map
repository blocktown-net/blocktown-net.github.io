{"version":3,"sources":["regexp/wrapper","node_modules/browser-pack/_prelude.js","amp-mustache.js","extensions/amp-mustache/0.2/amp-mustache.js","node_modules/dompurify/dist/purify.es.js","src/config.js","src/css.js","src/dom.js","src/format.js","src/internal-version.js","src/log.js","src/mode-object.js","src/mode.js","src/purifier.js","src/sanitation.js","src/srcset.js","src/string.js","src/types.js","src/url-parse-query-string.js","src/url-rewrite.js","src/url-try-decode-uri-component.js","src/url.js","src/utils/function.js","src/utils/lru-cache.js","src/utils/object.js","src/utils/promise.js","third_party/css-escape/css-escape.js","third_party/mustache/mustache.js"],"names":[],"mappings":"AAAA;ACAA;ACCA;AACA;AACA;AACA;AACA;ACWA;ADTA;ACUA;ADRA;ACSA;ADPA;ACQA;ADNA;AACA;AACA;AACA;AACA;ACIA;AAEA;AACE;AAA8E;AAEhF;ADHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACAE;ADEF;AACA;AACA;ACAE;AAA0B;ADG5B;ACFI;ADIJ;ACDI;AAAoC;AAAA;ADKxC;ACT4B;AAOzB;AAED;ADIF;AACA;AACA;AACA;AACA;ACNI;AACA;AACA;AACA;AACE;AACD;AACD;ADQJ;AACA;ACRI;AAEA;ADSJ;ACRI;ADUJ;ACRI;AAA+B;AAAW;AAC3C;AAED;ADWF;AACA;AACA;AACA;AACA;AACA;ACXI;AACE;AACA;AACA;AACA;AACA;AAAiB;AAAO;AACzB;AACC;AACD;ADeL;ACbI;AACD;AAED;ADcF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACfmC;ADiBnC;AChBI;AACA;AACE;ADkBN;ACfM;AAAsC;AAAO;ADmBnD;AChBM;ADkBN;ACjBM;AACD;AACF;AAED;ADkBF;AACA;AACA;AClBI;AACD;AAED;ADmBF;AACA;AACA;ACnBI;ADqBJ;ACnBI;AACE;AACD;ADqBL;ACpBI;AAGE;AAAe;ADqBrB;ACnBI;AACD;AAED;ADoBF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBI;AAEA;ADqBJ;ACpBI;AACA;AAAK;AAAO;AAAiB;AAAO;AACpC;AACD;AD0BH;AACA;AACA;AACA;AACA;AC3BA;AACE;AACD;AD6BD;AACA;AACA;AACA;AACA;AACA;AACA;AEjLA;AACE;AACD;AFmLD;AEjLA;AFmLA;AEhLA;AAEA;AAEA;AAEA;AF+KA;AE7KA;AACE;AACD;AF+KD;AE7KA;AAEA;AAEA;AAEA;AAEA;AACA;AF2KA;AEzKA;AF2KA;AE1KA;AF4KA;AE1KA;AACE;AACE;AACD;AACF;AAED;AF2KA;AACA;AE3KA;AACE;AACE;AACA;AACA;AACA;AACD;AF6KH;AE3KE;AF6KF;AE5KE;AACE;AF8KJ;AE7KI;AACE;AF+KN;AE9KM;AACE;AACA;AACE;AACD;AFgLT;AE9KQ;AACD;AACF;AFgLL;AE9KI;AACD;AFgLH;AE9KE;AACD;AAED;AF+KA;AACA;AE/KA;AACE;AAEA;AFgLF;AE/KE;AACE;AACE;AACD;AACF;AFiLH;AE/KE;AACD;AFiLD;AE/KA;AACE;AACD;AFiLD;AE/KA;AFiLA;AEhLA;AACA;AFkLA;AEjLA;AFmLA;AElLA;AAAyB;AAEzB;AACA;AAA0B;AFqL1B;AElLA;AAAqG;AAAoB;AAAoB;AAA+H;AFwL5Q;AEtLA;AAAmC;AAA0B;AAAiE;AAAmB;AF4LjJ;AE5LkJ;AAAc;AAAQ;AAAyB;AAAE;AFkMnM;AEhMA;AFkMA;AEjMA;AAEA;AACA;AFkMA;AEhMA;AACE;AACD;AFkMD;AEhMA;AACE;AACE;AACD;AACF;AAED;AFiMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AEjMA;AACE;AACE;AACD;AAGD;AACA;AFiMF;AACA;AEjME;AACA;AFmMF;AElME;AACE;AACD;AFoMH;AElME;AFoMF;AElME;AACE;AACE;AACE;AACD;AAH0C;AAK9C;AACC;AACA;AACA;AACA;AACA;AACD;AACF;AFoMD;AElMA;AACE;AFoMF;AElME;AACE;AACD;AAED;AFmMF;AACA;AACA;AACA;AACA;AEnME;AAEA;AFoMF;AACA;AACA;AACA;AEnME;AFqMF;AEnME;AACE;AACA;AACA;AAEA;AACD;AFoMH;AElME;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AACA;AACA;AACA;AACA;AFiMF;AE/LE;AACE;AFiMJ;AEhMI;AACE;AACD;AACF;AFkMH;AEhME;AFkMF;AEjME;AAEA;AAAA;AAAA;AAAA;AAAA;AAKA;AAGA;AAEA;AF+LF;AACA;AACA;AE9LE;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAEA;AF8LF;AACA;AACA;AACA;AE5LE;AF8LF;AE5LE;AACA;AAEA;AF6LF;AE5LE;AACA;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AACA;AACA;AE5LE;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AACA;AE5LE;AAEA;AF6LF;AACA;AACA;AACA;AE5LE;AAEA;AF6LF;AACA;AE5LE;AAEA;AF6LF;AACA;AACA;AACA;AE5LE;AAEA;AF6LF;AACA;AE5LE;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AACA;AE5LE;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AE5LE;AACA;AAEA;AF6LF;AE5LE;AAEA;AF6LF;AE5LE;AF8LF;AE5LE;AAEA;AF6LF;AACA;AACA;AACA;AE3LE;AF6LF;AE5LE;AACE;AACE;AACD;AAED;AF6LJ;AACA;AE7LI;AACE;AACD;AAED;AF8LJ;AACA;AE9LI;AACA;AACA;AACA;AACA;AACA;AACA;AFgMJ;AE/LI;AFiMJ;AEhMI;AFkMJ;AEjMI;AFmMJ;AElMI;AFoMJ;AEnMI;AFqMJ;AEpMI;AFsMJ;AErMI;AFuMJ;AEtMI;AFwMJ;AEvMI;AFyMJ;AExMI;AF0MJ;AEzMI;AF2MJ;AE1MI;AF4MJ;AE3MI;AF6MJ;AE3MI;AF6MJ;AE3MI;AACE;AACD;AF6ML;AE3MI;AACE;AACD;AAED;AF4MJ;AACA;AE5MI;AACE;AACA;AF8MN;AE7MM;AACE;AACA;AACD;AF+MP;AE7MM;AACE;AACA;AACA;AACD;AF+MP;AE7MM;AACE;AACA;AACA;AACD;AF+MP;AE7MM;AACE;AACA;AACA;AACD;AACF;AAED;AF8MJ;AACA;AE9MI;AACE;AACE;AACD;AFgNP;AE9MM;AACD;AFgNL;AE9MI;AACE;AACE;AACD;AFgNP;AE9MM;AACD;AFgNL;AE9MI;AACE;AACD;AAED;AF+MJ;AACA;AE/MI;AACE;AACD;AAED;AFgNJ;AACA;AEhNI;AACE;AACD;AAED;AFiNJ;AACA;AEjNI;AACE;AACA;AACD;AAGD;AFiNJ;AACA;AEjNI;AACE;AACD;AFmNL;AEjNI;AACD;AAED;AFkNF;AACA;AACA;AACA;AACA;AACA;AElNE;AACE;AAAyB;AAAF;AFsN3B;AErNI;AACE;AACD;AACC;AACD;AACF;AAED;AFsNF;AACA;AACA;AACA;AACA;AACA;AACA;AEtNE;AACE;AACE;AACE;AACA;AAFqB;AAIxB;AACC;AACE;AACA;AAFqB;AAIxB;AFwNL;AEtNI;AACD;AAED;AFuNF;AACA;AACA;AACA;AACA;AACA;AACA;AEvNE;AACE;AACA;AACA;AFyNJ;AEvNI;AACE;AACD;AACC;AACA;AACA;AFyNN;AExNM;AACE;AACD;AACF;AAED;AFyNJ;AACA;AEzNI;AACE;AACE;AACD;AACF;AAED;AF0NJ;AACA;AE1NI;AACE;AACD;AAED;AF2NJ;AACA;AACA;AE3NI;AACE;AACA;AAAA;AAGA;AACA;AACD;AF4NL;AE1NI;AACE;AACD;AAED;AF2NJ;AACA;AE3NI;AACD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AF2NF;AACA;AE3NE;AACE;AACE;AACE;AF6NR;AE5NQ;AACE;AACD;AACF;AACF;AF8NL;AE5NI;AACE;AACE;AF8NR;AE7NQ;AACE;AACD;AACF;AACF;AF+NL;AE7NI;AACE;AACE;AF+NR;AE9NQ;AACE;AACD;AACF;AACF;AACF;AAED;AF+NF;AACA;AACA;AACA;AACA;AACA;AACA;AE/NE;AACE;AACE;AACD;AACF;AAED;AFgOF;AACA;AACA;AACA;AACA;AACA;AACA;AEhOE;AACE;AACE;AACD;AFkOL;AEhOI;AACE;AACD;AFkOL;AEhOI;AACD;AAED;AFiOF;AACA;AACA;AACA;AACA;AACA;AACA;AEjOE;AACE;AACD;AAED;AFkOF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AElOE;AACE;AACE;AACD;AFoOL;AElOI;AACE;AACD;AACF;AAED;AFmOF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AEjOE;AFmOF;AACA;AEnOE;AACE;AAEA;AFoOJ;AEnOI;AAEA;AFoOJ;AACA;AEpOI;AACE;AFsON;AErOM;AACD;AAED;AFsOJ;AACA;AEtOI;AAEA;AFuOJ;AEtOI;AACE;AACA;AAF+C;AAKjD;AFuOJ;AACA;AEvOI;AACE;AACA;AACE;AACE;AACA;AACD;AACF;AFyOP;AEvOM;AFyON;AExOM;AACD;AAED;AFyOJ;AACA;AEzOI;AACE;AF2ON;AE1OM;AACD;AF4OL;AE1OI;AACE;AF4ON;AE3OM;AACD;AAED;AF4OJ;AACA;AE5OI;AACE;AF8ON;AE7OM;AACD;AAED;AF8OJ;AACA;AE9OI;AACE;AAAyB;AAAF;AFkP7B;AEjPM;AACE;AACD;AACC;AACD;AACF;AAED;AFkPJ;AACA;AElPI;AACE;AACA;AACA;AACA;AFoPN;AEnPM;AACE;AAAyB;AAAF;AACvB;AACD;AACF;AAED;AFsPJ;AACA;AEtPI;AFwPJ;AEtPI;AACD;AAED;AFuPF;AACA;AACA;AACA;AACA;AACA;AACA;AErPE;AFuPF;AACA;AEvPE;AACE;AACA;AACE;AACD;AAED;AFwPJ;AACA;AACA;AACA;AACA;AExPI;AAEC;AFyPL;AEvPM;AACD;AACC;AAEA;AACD;AFwPL;AEtPM;AFwPN;AEtPK;AFwPL;AEtPM;AFwPN;AEvPM;AACD;AFyPL;AEvPM;AFyPN;AACA;AEvPK;AFyPL;AEvPM;AACA;AACD;AFyPL;AEvPM;AACD;AACC;AACD;AFyPL;AEvPI;AACD;AAED;AFwPF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AEtPE;AFwPF;AACA;AExPE;AACE;AACA;AACA;AACA;AACA;AACA;AF0PJ;AEzPI;AF2PJ;AEzPI;AAEA;AF0PJ;AExPI;AACE;AACD;AF0PL;AExPI;AACE;AACA;AACA;AACA;AAJc;AAMhB;AAEA;AFyPJ;AExPI;AACE;AACA;AAAA;AAAA;AAIA;AACA;AAEA;AFwPN;AEvPM;AACA;AACA;AFyPN;AExPM;AF0PN;AEzPM;AAEA;AF0PN;AEzPM;AACE;AACD;AAED;AACA;AACA;AACA;AF0PN;AACA;AE1PM;AACE;AACA;AF4PR;AE3PQ;AF6PR;AE5PQ;AF8PR;AE7PQ;AACE;AACD;AACF;AAED;AACA;AACE;AACD;AACC;AACA;AACA;AACA;AACE;AACD;AF8PT;AE5PQ;AACD;AAED;AF6PN;AACA;AE7PM;AACE;AACD;AAED;AF8PN;AACA;AE9PM;AACE;AACA;AACD;AAED;AF+PN;AACA;AE/PM;AFiQN;AEhQM;AACE;AACD;AAED;AFiQN;AACA;AEjQM;AACE;AACE;AACD;AACC;AACA;AACD;AFmQT;AEjQQ;AACD;AACF;AAED;AFkQJ;AACA;AElQI;AACD;AAED;AFmQF;AACA;AACA;AACA;AACA;AACA;AEnQE;AACE;AFqQJ;AEpQI;AAEA;AFqQJ;AACA;AErQI;AFuQJ;AErQI;AACE;AACA;AAEA;AFsQN;AACA;AEtQM;AACE;AACD;AAED;AFuQN;AACA;AEvQM;AACE;AACD;AAED;AFwQN;AACA;AExQM;AACD;AAED;AFyQJ;AACA;AEzQI;AACD;AAED;AF0QF;AACA;AACA;AACA;AACA;AACA;AExQE;AF0QF;AACA;AE1QE;AACE;AACA;AACA;AACA;AACA;AACA;AF4QJ;AACA;AACA;AE3QI;AACE;AACD;AAED;AF4QJ;AACA;AE5QI;AACE;AACA;AACE;AACD;AACC;AF8QR;AE7QQ;AACE;AACD;AACF;AACF;AAED;AF8QJ;AACA;AE9QI;AACE;AACE;AACE;AACD;AFgRT;AE9QQ;AACE;AACD;AACF;AFgRP;AE9QM;AACD;AAED;AF+QJ;AACA;AE/QI;AACE;AACD;AAED;AFgRJ;AACA;AEhRI;AFkRJ;AEhRI;AACE;AACD;AACC;AFkRN;AEhRM;AACA;AFkRN;AEjRM;AACE;AACA;AACD;AACC;AACD;AACC;AACA;AACD;AACF;AACC;AACA;AACE;AACD;AAED;AFkRN;AACA;AElRM;AAEA;AFmRN;AElRM;AACE;AACD;AACF;AAED;AFmRJ;AACA;AEnRI;AACE;AACD;AAED;AFoRJ;AACA;AEpRI;AAEA;AFqRJ;AACA;AErRI;AACE;AACA;AACE;AACD;AAED;AFsRN;AACA;AEtRM;AACE;AACD;AAED;AFuRN;AACA;AEvRM;AACE;AACD;AAED;AFwRN;AACA;AExRM;AF0RN;AExRM;AACD;AF0RL;AExRI;AAEA;AFyRJ;AExRI;AACE;AACD;AAED;AFyRJ;AACA;AEzRI;AACE;AACE;AF2RR;AEzRQ;AACE;AACA;AACD;AACF;AACC;AACD;AF2RP;AEzRM;AACE;AF2RR;AACA;AACA;AACA;AEzRQ;AACD;AF2RP;AEzRM;AACD;AF2RL;AEzRI;AAEA;AF0RJ;AEzRI;AACE;AACA;AACD;AF2RL;AEzRI;AACD;AAED;AF0RF;AACA;AACA;AACA;AACA;AACA;AACA;AE1RE;AACE;AF4RJ;AE3RI;AACD;AAED;AF4RF;AACA;AACA;AACA;AACA;AACA;AE5RE;AACE;AACA;AACD;AAED;AF6RF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AE7RE;AACE;AACA;AACE;AACD;AF+RL;AE7RI;AACA;AACA;AACD;AAED;AF8RF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AE9RE;AACE;AACE;AACD;AFgSL;AE9RI;AACA;AACD;AAED;AF+RF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AE/RE;AACE;AACE;AACD;AACF;AAED;AFgSF;AACA;AACA;AACA;AACA;AACA;AACA;AEhSE;AACE;AACE;AACD;AACF;AAED;AFiSF;AACA;AACA;AACA;AACA;AACA;AEjSE;AACE;AACD;AFmSH;AEjSE;AACD;AFmSD;AEjSA;AFmSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AG79CA;AH+9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AG79CA;AH+9CA;AACA;AACA;AACA;AACA;AACA;AG79CA;AAEA;AAKA;AAKA;AHs9CA;AGr9CO;AACL;AACA;AACA;AACA;AHu9CF;AGt9CE;AHw9CF;AACA;AGt9CE;AAEA;AACA;AAEA;AHs9CF;AGr9CE;AHu9CF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AGr9CE;AAvBkB;AH++CpB;AGl9CO;AACL;AADoB;AHs9CtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AInhDA;AJqhDA;AIphDA;AJshDA;AIviDA;AJyiDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AIpiDA;AJsiDA;AACA;AACA;AACA;AACA;AIpiDO;AACL;AACD;AAED;AJqiDA;AACA;AACA;AACA;AIriDA;AAEA;AJsiDA;AACA;AACA;AACA;AIriDO;AACL;AACD;AAED;AJsiDA;AACA;AACA;AACA;AACA;AACA;AItiDO;AACL;AACE;AACD;AJwiDH;AItiDE;AACD;AAED;AJuiDA;AACA;AACA;AACA;AACA;AACA;AIviDA;AACE;AACE;AACA;AACA;AACA;AAEA;AJwiDJ;AIviDI;AAAmB;AAAO;AAC3B;AACC;AACD;AACF;AAED;AJ0iDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AI1iDO;AACL;AACD;AAED;AJ2iDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AI3iDO;AACL;AACD;AAED;AJ4iDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AI5iDO;AACL;AJ8iDF;AI5iDE;AACA;AACD;AJ8iDD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKhtDA;ALktDA;AKjtDA;ALmtDA;AK9sDA;ALgtDA;AK/sDA;ALitDA;AKhtDA;ALktDA;AKjtDA;ALmtDA;AK5uDA;AL8uDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKhuDA;AACE;AACA;AACA;AACA;AACA;AACA;AANwB;AAQ1B;AAEA;ALiuDA;AKhuDO;AAEP;ALiuDA;AACA;AKjuDO;AAEP;ALkuDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKnuDO;AACL;AACE;AACA;AACD;AACD;ALquDF;AACA;AKruDE;ALuuDF;AKtuDE;AACE;AACA;AACE;AACE;AACA;AACD;AACF;AACD;AAA0B;AAAD;AAC1B;AACC;AACA;AACE;AACE;AACA;AACD;AACF;AAAE;AAAmB;AACvB;AACF;AAED;AL2uDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AK3uDO;AACL;AACE;AACD;AACF;AAED;AL4uDA;AACA;AACA;AACA;AACA;AACA;AK5uDO;AACL;AAAkC;AAAA;AACnC;AAED;AL+uDA;AACA;AACA;AACA;AACA;AACA;AK/uDO;AACL;AAA0B;AAAA;AAC3B;AAED;ALkvDA;AACA;AACA;AACA;AACA;AKlvDO;AACL;AACE;AACD;AACF;AAED;ALmvDA;AACA;AACA;AACA;AACA;AKnvDO;AACL;AACE;AACD;AACF;AAED;ALovDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKpvDO;AACL;ALsvDF;AKrvDE;AACE;AACD;ALuvDH;AKtvDE;AACD;AAED;ALuvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKvvDO;AACL;AACA;AACD;AAED;ALwvDA;AACA;AACA;AACA;AACA;AACA;AACA;AKxvDO;AACL;AACE;AACD;AL0vDH;AKzvDE;AACD;AAED;AL0vDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AK1vDO;AACL;AACA;AACD;AAED;AL2vDA;AACA;AACA;AACA;AACA;AACA;AACA;AK3vDO;AACL;AL6vDF;AK5vDE;AACE;AACD;AL8vDH;AACA;AK5vDE;AL8vDF;AK7vDE;AACE;AL+vDJ;AK9vDI;AACE;AACD;AACC;AACD;AACF;ALgwDH;AK/vDE;AACD;AAED;ALgwDA;AACA;AACA;AACA;AACA;AACA;AKhwDO;AACL;AACE;AACA;AACD;ALkwDH;AKjwDE;ALmwDF;AKjwDE;ALmwDF;AKlwDE;AACD;AAED;ALmwDA;AACA;AACA;AACA;AACA;AACA;AKnwDO;AACL;AACA;AACE;AACD;AAED;ALowDF;AACA;AKpwDE;AACE;AACD;ALswDH;AKrwDE;AACoB;AAAwB;AAG7C;AAED;ALqwDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKrwDO;AACL;AACE;AACE;AACD;AACF;ALuwDH;AKtwDE;AACD;AAED;ALuwDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKvwDO;AACL;AACE;AACE;AACD;AACF;ALywDH;AKxwDE;AACD;AAED;ALywDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKzwDO;AACL;AACE;AACD;AL2wDH;AKzwDE;AACE;AACD;AACF;AAED;AL0wDA;AACA;AACA;AACA;AACA;AACA;AACA;AK1wDO;AACL;AL4wDF;AK3wDE;AAKE;AACE;AACD;AACF;ALywDH;AKxwDE;AACD;AAED;ALywDA;AACA;AACA;AACA;AACA;AACA;AACA;AKzwDO;AACL;AACA;AACA;AACE;AACD;AACF;AAED;AL0wDA;AACA;AACA;AACA;AACA;AACA;AACA;AK1wDO;AACL;AAKE;AACE;AACD;AACF;ALwwDH;AKvwDE;AACD;AAED;ALwwDA;AACA;AACA;AACA;AACA;AACA;AACA;AKxwDO;AACL;AL0wDF;AKzwDE;AAKE;AACE;AACD;AACF;ALuwDH;AKtwDE;AACD;AAED;ALuwDA;AACA;AACA;AACA;AACA;AACA;AACA;AKvwDO;AACL;AAKE;AACE;AACD;AACF;ALqwDH;AKpwDE;AACD;AAED;ALqwDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKrwDO;AACL;ALuwDF;AKtwDE;AACE;AACE;AACD;AACF;ALwwDH;AKvwDE;AACD;AAED;ALwwDA;AACA;AACA;AACA;AACA;AACA;AACA;AKxwDO;AACL;AACA;AAAO;AAAO;AAAd;AACD;AAED;AL4wDA;AACA;AACA;AACA;AACA;AACA;AACA;AK5wDO;AACL;AACA;AACE;AACD;AACF;AAED;AL6wDA;AACA;AACA;AACA;AACA;AACA;AACA;AK7wDO;AACL;AACA;AAAO;AAAO;AAAd;AACD;AAED;ALixDA;AACA;AACA;AACA;AACA;AACA;AACA;AKjxDO;AACL;AACA;AAAO;AAAO;AAAd;AACD;AAED;ALqxDA;AACA;AACA;AACA;AACA;AACA;AACA;AKrxDO;AACL;AACA;AAAO;AAAO;AAAd;AACD;AAED;ALyxDA;AACA;AACA;AACA;AACA;AACA;AACA;AKzxDO;AACL;AL2xDF;AKrxDE;AACE;AACD;ALuxDH;AKtxDE;AACD;AAED;ALuxDA;AACA;AACA;AACA;AACA;AACA;AACA;AKvxDO;AACL;AACA;AAAe;AAAO;AACvB;AAED;AL0xDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AK1xDA;AACE;AACA;AACA;AACA;AAAsB;AAAO;AAC7B;AACA;AACD;AAED;AL6xDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AK7xDO;AACL;AACE;AAAY;AAAO;AACpB;ALiyDH;AACA;AK/xDE;AACA;AACD;AAED;ALgyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKhyDO;AACL;AACE;AAAY;AAAO;AAGpB;ALkyDH;AACA;AKhyDE;AACD;AAED;ALiyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKjyDO;AAKL;AAA6D;AAAA;ALiyD/D;AKlyDE;AAGA;AACA;ALkyDF;AKjyDE;AACE;ALmyDJ;AKlyDI;AACE;ALoyDN;AKnyDM;AACD;AACF;ALqyDH;AKpyDE;AACD;AAED;ALqyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKryDO;AACL;ALuyDF;AKtyDE;AACE;AACE;AACD;AACF;ALwyDH;AKpyDE;AACD;AAED;ALqyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKryDO;AACL;AACE;AACD;AACC;AACA;AACA;AACD;AACF;AAED;ALsyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKtyDO;AAAqC;ALyyD5C;AKvyDE;AACE;AACD;AACF;AAED;ALwyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKxyDO;AACL;AACA;AACA;AACA;AL0yDF;AKzyDE;AACE;AACD;AACC;AACD;AL2yDH;AACA;AKzyDE;AACE;AACD;AL2yDH;AK1yDE;AACD;AAED;AL2yDA;AACA;AACA;AACA;AACA;AACA;AK3yDO;AACL;AAKD;AAED;ALwyDA;AACA;AACA;AACA;AACA;AACA;AKxyDO;AACL;AAID;AAED;ALsyDA;AACA;AACA;AACA;AACA;AACA;AKtyDO;AACL;AAIA;AACD;AAED;ALoyDA;AACA;AACA;AACA;AACA;AACA;AKpyDO;AACL;AACE;AACD;ALsyDH;AKryDE;AACD;AAED;ALsyDA;AACA;AACA;AACA;AACA;AKtyDA;AACE;AACD;AAED;ALuyDA;AACA;AACA;AACA;AACA;AACA;AKvyDO;AACL;AACE;AAAQ;AAAO;AAChB;AAEA;AACF;AAED;ALyyDA;AACA;AACA;AACA;AACA;AACA;AKzyDO;AACL;AACD;AAED;AL0yDA;AACA;AACA;AACA;AACA;AACA;AK1yDO;AACL;AAEA;AL2yDF;AK1yDE;AAGE;AAEH;AAED;ALwyDA;AACA;AACA;AACA;AACA;AACA;AACA;AKxyDO;AACL;AL0yDF;AKzyDE;AACE;AACA;AACD;AAED;AL0yDF;AACA;AK1yDE;AACE;AACA;AACA;AACD;AL4yDH;AK1yDE;AACD;AAED;AL2yDA;AACA;AACA;AACA;AACA;AACA;AK3yDO;AACL;AL6yDF;AKtyDE;AACE;AACD;AACF;AAED;ALuyDA;AACA;AACA;AACA;AACA;AACA;AKvyDO;AACL;ALyyDF;AKlyDE;AACE;AACA;AACD;ALoyDH;AK/yDwC;ALizDxC;AKpyDE;AACE;AACD;ALsyDH;AKryDE;ALuyDF;AKhyDE;AACE;AACD;AACF;AAED;ALiyDA;AACA;AACA;AACA;AACA;AACA;AACA;AKjyDO;AAAsC;ALoyD7C;AKlyDE;AACE;AACD;ALoyDH;AKxyD6C;AL0yD7C;AKpyDE;AACE;AACD;ALsyDH;AKryDE;AAKA;AACD;AAED;ALkyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKlyDO;AACL;AACD;AAED;ALmyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKnyDO;AACL;AACE;AACD;ALqyDH;AKnyDE;AACA;ALqyDF;AKjyDE;AACE;AACD;ALmyDH;AACA;AKjyDE;AACD;AAED;ALkyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AKlyDO;AACL;AACA;ALoyDF;AKlyDE;AACE;AACE;AACD;AACC;AACD;AACF;ALoyDH;AKlyDE;AACD;AAED;ALmyDA;AACA;AACA;AACA;AACA;AKnyDO;AAAwC;AAE7C;AAAwB;AAAO;AAC/B;AAAsC;AAAO;AAC7C;AACD;ALyyDD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AM5sFA;AN8sFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AM5sFA;AN8sFA;AACA;AACA;AACA;AACA;AM5sFA;AACE;AACA;AAAwC;AAAA;AACxC;AACD;AAED;AN+sFA;AACA;AACA;AACA;AACA;AM/sFO;AACL;AACD;AAED;ANgtFA;AACA;AACA;AACA;AACA;AMhtFO;AACL;AACD;ANktFD;AACA;AACA;AACA;AACA;AACA;AACA;AOlwFA;APowFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AOlwFA;APowFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AOlwFO;AACL;AACD;APowFD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQnyFA;ARqyFA;AQpyFA;ARsyFA;AQryFA;ARuyFA;AQtyFA;ARwyFA;AQvyFA;ARyyFA;AQxyFA;AR0yFA;AQ/zFA;ARi0FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQvzFA;AAEA;ARwzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQxzFO;AAEP;ARyzFA;AACA;AACA;AACA;AACA;AACA;AQzzFO;AAEP;AR0zFA;AACA;AACA;AACA;AACA;AACA;AQ3zFO;AACL;AACD;AAED;AR4zFA;AACA;AACA;AACA;AACA;AQ5zFO;AACL;AACD;AAED;AR6zFA;AACA;AACA;AACA;AACA;AQ7zFO;AACL;AACA;AACA;AACA;AACA;AALsB;AAQxB;AR8zFA;AACA;AACA;AACA;AACA;AACA;AACA;AQ/zFO;AACL;AACD;AAED;ARg0FA;AACA;AACA;AACA;AACA;AQh0FA;AAEA;ARi0FA;AACA;AACA;AQh0FO;AACL;AACD;AAED;ARi0FA;AACA;AACA;AACA;AACA;AACA;AACA;AQj0FA;AAAsB;AAAA;AAEtB;ARo0FA;AACA;AACA;AACA;AACA;AACA;AACA;AQp0FA;AAA2B;AAEvB;AAAA;AAFuB;AAM3B;ARq0FA;AACA;AACA;AACA;AACA;AACA;AQr0FA;AAAuC;AAAA;AAGvC;ARu0FA;AACA;AACA;AACA;AACA;AQv0FA;AAAwC;AAAA;AAGxC;ARy0FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQ30FE;AR60FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQ30FE;AAA6C;AR80F/C;AQ90F+C;AAAjB;AAAiB;ARk1F/C;AQj1FI;ARm1FJ;AACA;AACA;AACA;AQj1FI;AAEA;ARk1FJ;AQj1FI;AAEA;ARk1FJ;AQj1FI;AAEA;ARk1FJ;AQj1FI;AAEA;ARk1FJ;AQj1FI;AAEA;AACE;AAEgB;AAAA;AAEZ;AACE;AAAiB;AAA4B;AAC9C;AACF;AACJ;AACF;AAED;ARk1FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQp1FI;AACD;AAED;ARq1FF;AACA;AACA;AACA;AACA;AACA;AQr1FI;AACA;AACE;AACD;ARu1FL;AACA;AQr1FI;AACE;AACD;ARu1FL;AACA;AQr1FI;AACE;AACD;ARu1FL;AACA;AQr1FI;AACE;AACD;ARu1FL;AACA;AQr1FI;AACD;AAED;ARs1FF;AACA;AACA;AACA;AACA;AACA;AACA;AQt1FI;AACE;ARw1FN;AQv1FM;AACE;AACD;AACC;AACD;AACC;AACD;ARy1FP;AQx1FM;AR01FN;AQx1FM;AR01FN;AQz1FM;AACE;AACA;AACD;AACC;AACD;AR21FP;AQ11FM;AACD;AACF;AAED;AR21FF;AACA;AACA;AACA;AACA;AACA;AQ31FI;AACD;AAED;AR41FF;AACA;AACA;AACA;AACA;AACA;AACA;AQ51FI;AACE;AACD;AACF;AAED;AR61FF;AACA;AACA;AACA;AACA;AACA;AACA;AQ71FI;AACE;AACD;AACF;AAED;AR81FF;AACA;AACA;AACA;AACA;AACA;AACA;AQ91FI;AACE;AACD;AACF;AAED;AR+1FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQ/1FI;AACE;AACD;AACC;AAIA;AACA;AACD;AACF;AAED;AR61FF;AACA;AACA;AACA;AACA;AACA;AACA;AQ71FI;AR+1FJ;AQ91FI;AACE;ARg2FN;AQ91FM;AACD;AACF;AAED;AR+1FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQ/1FI;ARi2FJ;AQh2FI;AACE;ARk2FN;AQh2FM;AACD;AACF;AAED;ARi2FF;AACA;AACA;AACA;AACA;AACA;AACA;AQj2FI;AACA;AACA;AACD;AAED;ARk2FF;AACA;AACA;AACA;AACA;AACA;AACA;AQl2FI;AACA;AACA;AACA;AACD;AAED;ARm2FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQn2FI;ARq2FJ;AQp2FI;AACE;AAG4B;AAAuB;AAGpD;ARm2FL;AQl2FI;AACE;AACA;AACA;AACA;AACA;AACA;AACA;ARo2FN;AQn2FM;AACE;AACA;ARq2FR;AQp2FQ;AACE;AACD;ARs2FT;AQr2FQ;AACA;AACA;AACD;ARu2FP;AQt2FM;AACA;AACA;AACA;AACA;ARw2FN;AQt2FM;ARw2FN;AQv2FM;AACD;ARy2FL;AQx2FI;AACD;AAED;ARy2FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQz2FI;AACA;AAMA;AAAO;AAAyB;AAAhC;AACD;AAED;ARw2FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQx2FI;AAMA;AAAO;AAAuB;AAA9B;AACD;AAED;ARu2FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQv2FI;AAMA;AAAO;AAAuB;AAA9B;AACD;AAED;ARs2FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQt2FI;AAMA;AAAO;AAAuB;AAA9B;AACD;AAED;ARq2FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQr2FI;AAMA;AAAO;AAAwB;AAA/B;AACD;AAED;ARo2FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQp2FI;AACE;AACD;ARs2FL;AQr2FI;AACD;AAED;ARs2FF;AACA;AACA;AACA;AACA;AACA;AQt2FI;ARw2FJ;AQv2FI;AACE;AACE;AACD;AACC;AACD;AACF;AACC;AACD;AACF;AAED;ARw2FF;AACA;AACA;AACA;AACA;AACA;AACA;AQx2FI;AACE;AAA+B;AAAuB;AACvD;AR42FL;AQ32FI;AACD;AAED;AR42FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQ52FI;AACA;AAEA;AACA;AACA;AR62FJ;AQ52FI;AACE;AACD;AR82FL;AQ72FI;AACE;AACD;AR+2FL;AQ92FI;AACD;AAED;AR+2FF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQ/2FI;AACE;AACD;AACC;AACD;AACF;ARi3FH;AACA;AACA;AQh3FA;ARk3FA;AACA;AACA;AACA;AACA;AACA;AACA;AQp3FA;AAAiC;AAC/B;AAAuB;AADQ;AAAA;AAGjC;ARy3FA;AACA;AACA;AACA;AACA;AQz3FA;AACE;AACA;AACE;AACD;AR23FH;AQ13FE;AACD;AAED;AR23FA;AACA;AACA;AACA;AACA;AQ33FA;AACE;AACE;AACD;AACF;AAED;AR43FA;AACA;AACA;AACA;AACA;AACA;AQ53FO;AACL;AR83FF;AQ73FE;AACE;AACD;AR+3FH;AQn4FiD;AAAA;AAO/C;ARg4FF;AQ93FE;AACE;AACD;ARg4FH;AACA;AQ/3FE;AACA;AACD;AAED;ARg4FA;AACA;AACA;AACA;AACA;AACA;AQh4FO;AACL;AACA;ARk4FF;AQj4FE;AACE;ARm4FJ;AQl4FI;AACE;AACD;AACC;AACE;AACD;ARo4FP;AQn4FM;AACD;AACF;ARq4FH;AQn4FE;AACE;AACD;AACC;AACD;ARq4FH;AQp4FE;AACD;AAED;ARq4FA;AACA;AACA;AACA;AACA;AACA;AQr4FO;AACL;AACA;AACE;AACA;ARu4FJ;AQt4FI;AACD;AACF;AAED;ARu4FA;AACA;AACA;AACA;AACA;AACA;AQv4FA;AACE;AACA;AACA;AAHiC;AAMnC;AAEA;ARu4FA;AACA;AACA;AACA;AACA;AACA;AQt4FA;AAEA;ARu4FA;AACA;AACA;AQt4FO;AACL;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;ARu4FF;AQt4FE;AACA;AACD;AAED;ARu4FA;AACA;AACA;AACA;AQv4FO;AACL;AACD;AAED;ARw4FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQx4FO;AACL;AACE;AACD;AR04FH;AQz4FE;AACE;AACD;AACC;AACE;AACD;AR24FL;AQ14FI;AACD;AACF;AAED;AR24FA;AACA;AACA;AACA;AACA;AACA;AQ34FA;AACE;AACE;AACD;AR64FH;AQ54FE;AAGI;AR44FN;AQ34FM;AACE;AACD;AR64FP;AQ54FM;AACD;AAGJ;AAED;AR24FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQ34FO;AACL;AACE;AACD;AR64FH;AQ54FE;AACE;AACD;AR84FH;AQ74FE;AACE;AR+4FJ;AQ94FI;AACE;AACD;ARg5FL;AQ/4FI;AACE;AACD;ARi5FL;AQh5FI;AACD;AACF;AAED;ARi5FA;AACA;AACA;AACA;AACA;AACA;AQj5FO;AACL;AACE;AACD;ARm5FH;AQl5FE;AACD;AAED;ARm5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQn5FO;AAaL;AACE;AACD;ARy4FH;AQx4FE;AAAa;AAAc;AAa5B;AAED;AR+3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQ/3FO;AAaL;AAAc;AAAc;AAa7B;AR22FD;AACA;AACA;AACA;AACA;AACA;AACA;ASz0HA;AT20HA;AS31HA;AT61HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ASz1HA;AT21HA;AACA;AACA;AACA;AACA;ASz1HO;AACL;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVK;AAYR;AT21HD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AUz3HA;AV23HA;AU13HA;AV43HA;AU74HA;AV+4HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AU14HA;AV44HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AU14HO;AAEP;AV24HA;AACA;AACA;AACA;AACA;AACA;AU34HA;AAEA;AV44HA;AACA;AACA;AACA;AACA;AU34HO;AACL;AV64HF;AU54HE;AACE;AACD;AV84HH;AU74HE;AACD;AAED;AV84HA;AACA;AACA;AACA;AACA;AACA;AU94HA;AACE;AACA;AAGA;AACA;AACA;AV84HF;AU74HE;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEE;AACA;AAEF;AAEA;AV04HF;AUx4HE;AACE;AACD;AAGD;AACA;AACA;AVw4HF;AACA;AUx4HE;AACE;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5BK;AA8BR;AAED;AVq4HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AUr4HA;AACE;AACA;AACA;AACE;AACD;AVu4HH;AUr4HE;AACE;AACD;AAGD;AACA;AACA;AACA;AVq4HF;AACA;AUr4HE;AACD;AAED;AVs4HA;AACA;AACA;AACA;AACA;AACA;AACA;AUt4HO;AACL;AACD;AAED;AVu4HA;AACA;AUv4HO;AACL;AACD;AVy4HD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AW3iIA;AX6iIA;AWliIA;AXoiIA;AWniIA;AXqiIA;AWpiIA;AXsiIA;AWriIA;AXuiIA;AWtiIA;AXwiIA;AWviIA;AXyiIA;AACA;AACA;AW3kIA;AX6kIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AWzjIA;AX2jIA;AACA;AWzjIO;AX2jIP;AWxjIA;AX0jIA;AACA;AW1jIA;AAEA;AX2jIA;AW1jIA;AAEA;AX2jIA;AACA;AACA;AACA;AW1jIA;AACE;AACE;AACA;AAFQ;AADsB;AAOlC;AAAwB;AAAiC;AACvD;AACE;AACA;AACA;AAHY;AADyC;AAQzD;AX4jIA;AACA;AACA;AACA;AW3jIA;AAEA;AX4jIA;AACA;AACA;AACA;AACA;AACA;AACA;AW3jIO;AACL;AACA;AACA;AACA;AACA;AACD;AAED;AX4jIA;AACA;AACA;AACA;AACA;AACA;AACA;AW5jIO;AACL;AACA;AACA;AACA;AACA;AACD;AAED;AX6jIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AW7jIA;AACE;AAGE;AAAiC;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZ+B;AAenC;AAAO;AAAiC;AAAxC;AACD;AAED;AX+jIA;AACA;AACA;AACA;AACA;AW/jIO;AACL;AXikIF;AW/jIE;AACE;AACD;AXikIH;AW/jIE;AACA;AACE;AACD;AXikIH;AW/jIE;AACA;AACD;AAED;AXgkIA;AACA;AACA;AACA;AACA;AACA;AWhkIA;AACE;AXkkIF;AW/jIE;AACA;AXikIF;AW9jIE;AACA;AAEA;AX+jIF;AACA;AACA;AACA;AW9jIE;AAAiD;AAE/C;AXgkIJ;AW7jII;AACE;AACA;AACD;AX+jIL;AACA;AW9jII;AACE;AXgkIN;AW/jIM;AACE;AACD;AACF;AXikIL;AACA;AWhkII;AXkkIJ;AWjkII;AAAe;AAAA;AXqkInB;AWnkIM;AXqkIN;AWpkIM;AAIE;AACA;AACD;AACF;AACF;AAED;AXkkIF;AACA;AACA;AACA;AWlkIE;AACE;AACA;AACA;AACA;AACE;AACD;AACD;AACD;AAED;AXmkIF;AACA;AACA;AACA;AACA;AWnkIE;AACE;AACA;AACA;AACA;AACA;AAEA;AAPoD;AAAA;AAUpD;AXokIJ;AWlkII;AACE;AACA;AACA;AACE;AACA;AACD;AACF;AAGD;AXkkIJ;AACA;AWlkII;AXokIJ;AWnkII;AACE;AACD;AACC;AACA;AACA;AACA;AACA;AACE;AXqkIR;AWpkIQ;AACE;AACD;AACC;AACA;AACD;AACF;AXskIP;AACA;AWpkIM;AXskIN;AWrkIM;AACE;AACD;AACF;AXukIL;AWrkII;AAEA;AACA;AXskIJ;AWrkII;AACE;AACA;AACD;AXukIL;AWtkII;AACE;AACA;AACA;AACD;AXwkIL;AWtkII;AAKI;AAAU;AACV;AAAiB;AAGnB;AACE;AACD;AACF;AACC;AACA;AAOD;AX8jIL;AACA;AW5jII;AACD;AAED;AX6jIF;AACA;AACA;AACA;AACA;AW7jIE;AACE;AAA+B;AAAA;AAG/B;AACA;AX+jIJ;AW9jII;AACE;AACD;AACD;AXgkIJ;AW7jII;AX+jIJ;AW9jII;AACE;AACE;AAIE;AACA;AAID;AACF;AACF;AACF;AX0jIH;AWxjIE;AACA;AACA;AACA;AACD;AAED;AXyjIA;AACA;AACA;AACA;AWzjIA;AACE;AACA;AACA;AAHkB;AAMpB;AX0jIA;AACA;AACA;AACA;AWzjIA;AACE;AACE;AACD;AX2jIH;AW1jIE;AACE;AACD;AX4jIH;AW3jIE;AACD;AAED;AX4jIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AW5jIO;AACL;AAEA;AX6jIF;AW5jIE;AX8jIF;AW7jIE;AAAe;AAAA;AXikIjB;AW/jII;AACE;AACE;AACD;AACF;AACF;AXikIH;AACA;AWhkIE;AACE;AACE;AACD;AACF;AAED;AXikIF;AACA;AWjkIE;AACE;AACD;AXmkIH;AACA;AWlkIE;AACE;AACD;AXokIH;AWnkIE;AXqkIF;AWpkIE;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AXskIJ;AWrkII;AACE;AACD;AACF;AXukIH;AWtkIE;AAEI;AAA0B;AXwkIhC;AWtkIE;AAAiD;AAAiB;AAChE;AACD;AX0kIH;AWzkIE;AACD;AAED;AX0kIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AW1kIO;AAAgE;AAArB;AAAqB;AX+kIvE;AW9kIE;AACA;AACA;AAAyD;AAEvD;AXglIJ;AW/kII;AACE;AXilIN;AWhlIM;AACE;AACD;AACF;AACF;AACD;AACE;AACA;AACA;AACA;AACD;AAED;AACA;AACA;AXilIF;AWhlIE;AACE;AACA;AACA;AAHwC;AAK1C;AAEA;AXilIF;AWhlIE;AACA;AACA;AAAW;AAAO;AACnB;AXolID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AY5iJA;AZ8iJA;AY7iJA;AZ+iJA;AY9iJA;AZgjJA;AY/iJA;AZijJA;AYpkJA;AZskJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AY/jJA;AACO;AAEP;AZgkJA;AACA;AYhkJO;AAEP;AZikJA;AACA;AYjkJO;AAEP;AZkkJA;AACA;AACA;AACA;AACA;AACA;AYlkJO;AACL;AADmC;AAIrC;AZmkJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AYpkJO;AACL;AAEA;AACA;AZqkJF;AYpkJE;AZskJF;AYpkJE;AACE;AACA;AACA;AACD;AACC;AACA;AACE;AACD;AACF;AACF;AAED;AZqkJA;AACA;AACA;AACA;AACA;AYrkJO;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAb8B;AAgBhC;AZskJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AYtkJO;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXwC;AAc1C;AZukJA;AACA;AACA;AACA;AACA;AACA;AACA;AYvkJO;AAoCP;AZsiJA;AACA;AACA;AACA;AACA;AYtiJO;AAEL;AAUA;AAOA;AAGA;AAEA;AAQA;AAIA;AACA;AAGF;AZygJA;AACA;AACA;AACA;AACA;AYzgJO;AACL;AACA;AACA;AACA;AACA;AACA;AANuC;AASzC;AZ0gJA;AACA;AY1gJO;AAEP;AZ2gJA;AACA;AY3gJA;AACE;AAA4B;AAC5B;AAA4B;AAC5B;AAA4B;AAC5B;AAA4B;AAC5B;AAA4B;AAG9B;AZghJA;AY/gJA;AAEI;AACE;AADO;AADN;AAOP;AZ8gJA;AACA;AACA;AACA;AY7gJA;AAEI;AACE;AADO;AADN;AAOP;AZ4gJA;AY3gJA;AASA;AZqgJA;AYpgJA;AAEI;AACA;AACA;AAHG;AAOP;AZmgJA;AACA;AACA;AACA;AYlgJA;AAEI;AACA;AAFG;AAMP;AZigJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AYhgJA;AAEA;AZigJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AYhgJO;AAML;AADA;AACA;AZ+/IF;AY9/IE;AACE;AACA;AACE;AACD;AZggJL;AACA;AY9/II;AACE;AZggJN;AY//IM;AACE;AACE;AACD;AACF;AACF;AACF;AZigJH;AACA;AY//IE;AACE;AACD;AZigJH;AACA;AY//IE;AACE;AACD;AZigJH;AACA;AY//IE;AACE;AACD;AZigJH;AY//IE;AZigJF;AY9/IE;AZggJF;AY3/IE;AACE;AACD;AAGD;AZ2/IF;AACA;AY3/IE;AZ6/IF;AYx/IE;AACE;AZ0/IJ;AYz/II;AAIE;AACD;AACF;AZw/IH;AYt/IE;AACD;AZw/ID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Aa31JA;Ab61JA;Aa72JA;Ab+2JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Aa32JA;Ab62JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Aa32JA;AAEA;Ab42JA;AACA;AACA;AACA;AACA;AACA;Aa32JA;AAEA;Ab42JA;AACA;AACA;AACA;AACA;Aa32JO;AACL;Ab62JF;Aa52JE;AACE;AACD;AAED;AACA;Ab62JF;AACA;Aa72JE;AAKA;AACD;AAED;Ab02JA;AACA;AACA;AACA;AACA;AACA;Aa12JO;AACL;AAAoB;AAAU;AAAkB;AAA7B;AACpB;AAED;Ab+2JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Aa/2JO;AACL;AACA;Abi3JF;Aah3JE;AACE;AACA;AAAA;Abm3JJ;Aal3JI;AACE;Abo3JN;Aan3JM;AACE;AACD;AACC;AACD;AACC;AACD;AACF;AACC;AACA;AACD;Abq3JL;Aap3JI;AAAc;AAAK;AAAO;AAAb;AACd;Ab03JH;Aaz3JE;AACD;AAED;Ab03JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Aa53JE;Ab83JF;AACA;Aa53JE;AACE;AACA;Ab83JJ;Aa73JI;Ab+3JJ;Aa53JI;AACA;Ab83JJ;Aa73JI;AACE;AACA;AACA;AACD;Ab+3JL;Aa93JI;Abg4JJ;Aa13JI;AAEA;Ab23JJ;Aa13JI;AACD;AAED;Ab23JF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Aa73JI;AACA;AACA;Ab+3JJ;Aa93JI;AACE;AACD;AACC;AACD;Abg4JL;Aa/3JI;AACD;AAED;Abg4JF;AACA;AACA;AACA;AACA;AACA;AACA;Aah4JI;AACA;AACA;AACA;Abk4JJ;Aah4JI;AACE;AACA;AAGA;AACA;Abg4JN;Aa/3JM;AACE;AACA;AACA;AACD;AACC;AACD;AACF;Abi4JL;Aah4JI;AACD;AAED;Abi4JF;AACA;AACA;AACA;AACA;AACA;AACA;Aaj4JI;AACA;AACA;Abm4JJ;Aaj4JI;AACE;Abm4JN;Aal4JM;AACE;AACA;AACD;AACC;AACD;AACF;Abo4JL;Aan4JI;AACD;AAED;Abo4JF;AACA;AACA;AACA;AACA;AACA;Aap4JI;AAA0B;AAAA;AAC3B;AAED;Abu4JF;AACA;AACA;AACA;AACA;AACA;AACA;Aav4JI;AACA;Aby4JJ;Aax4JI;AACE;AACA;Ab04JN;Aaz4JM;AACE;AACD;Ab24JP;Aa14JM;AACE;AACD;AACC;AACD;Ab44JP;Aa34JM;AACD;Ab64JL;Aa54JI;AACD;Ab84JH;AACA;AACA;Aa74JA;Ab+4JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Aaj5JA;AACE;AACA;AACD;AAED;Abk5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Aal5JA;AACE;AACA;AACD;Abo5JD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AchsKA;AdksKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AchsKA;AdksKA;AACA;AACA;AACA;AchsKA;AACE;AACD;AAED;AdisKA;AACA;AACA;AACA;AACA;AcjsKA;AACE;AACD;AAED;AdksKA;AACA;AACA;AACA;AACA;AACA;AclsKO;AACL;AACD;AAED;AdmsKA;AACA;AACA;AACA;AACA;AACA;AACA;AcnsKO;AACL;AACD;AAED;AdosKA;AACA;AACA;AACA;AACA;AcpsKO;AACL;AACD;AAED;AdqsKA;AACA;AACA;AACA;AACA;AACA;AACA;AcrsKO;AACL;AACA;AACD;AAED;AdssKA;AACA;AACA;AACA;AACA;AACA;AACA;ActsKO;AACL;AACE;AACD;AdwsKH;AcvsKE;AACD;AAED;AdwsKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AcxsKO;AACL;AACE;AACD;Ad0sKH;AczsKE;AACE;AACD;Ad2sKH;Ac1sKE;AACD;AAED;Ad2sKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Ac3sKO;AACL;Ad6sKF;Ac9sKoE;AAGhE;AACA;AACE;AACA;AACD;Ad8sKL;Ac7sKI;AACE;AACD;AAV+D;Ad0tKpE;AcxtKE;AAAwC;Ad2tK1C;Ac3tK0C;AASvC;AdqtKH;AcptKE;AACD;AAED;AdqtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AcrtKO;AAA2B;AAEhC;AdutKF;ActtKE;AACE;AACD;AdwtKH;AACA;AcvtKE;AACD;AAED;AdwtKA;AACA;AACA;AACA;AACA;AACA;AcxtKO;AACL;AACA;AACE;AACD;Ad0tKH;AcxtKE;AACD;AAED;AdytKA;AACA;AACA;AACA;AACA;AACA;AcztKO;AACL;AACE;AACD;Ad2tKH;AcztKE;AACD;AAED;Ad0tKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Ac1tKO;AACL;AACE;AACD;Ad4tKH;Ac3tKE;AACA;Ad6tKF;Ac5tKE;AACE;AACD;Ad8tKH;Ac7tKE;AACD;Ad+tKD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Ae16KA;Af46KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Ae16KA;AACA;AAEA;Af26KA;AACA;AACA;AACA;AACA;Ae16KA;AACE;AACD;AAED;Af26KA;AACA;AACA;AACA;AACA;AACA;Ae36KO;AACL;AACD;AAED;Af46KA;AACA;AACA;AACA;AACA;AACA;AACA;Ae56KO;AACL;AACD;AAED;Af66KA;AACA;AACA;AACA;AACA;AACA;Ae76KO;AACL;AACD;AAED;Af86KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Ae96KO;AACL;AACD;AAED;Af+6KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Ae/6KO;AACL;AACE;AACE;AACD;AACF;Afi7KH;Aeh7KE;AACD;AAED;Afi7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;Aej7KO;AACL;AAAO;AAAwB;AAA/B;AACD;Afs7KD;AACA;AACA;AACA;AACA;AACA;AACA;AgB5gLA;AhB8gLA;AgB9hLA;AhBgiLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AgB3hLA;AAEA;AhB4hLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AgB3hLO;AACL;AAAe;AAA4B;AhB+hL7C;AgB9hLE;AACE;AACD;AhBgiLH;AgB9hLE;AhBgiLF;AgB/hLE;AACE;AACA;AACA;AACD;AhBiiLH;AgBhiLE;AACD;AhBkiLD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AiBtkLA;AjBwkLA;AiBjkLA;AjBmkLA;AiBlkLA;AjBokLA;AiBnkLA;AjBqkLA;AiBpkLA;AjBskLA;AiBhmLA;AjBkmLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AiBnlLA;AAEA;AjBolLA;AiBnlLA;AAEA;AjBolLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AiBnlLO;AAOL;AACA;AACA;AAEA;AACA;AjB8kLF;AiB7kLE;AjB+kLF;AiB9kLE;AACE;AACA;AACA;AjBglLJ;AiB9kLI;AACE;AACA;AACE;AACD;AjBglLP;AiB/kLM;AACD;AACC;AACA;AACD;AACF;AjBilLH;AiBhlLE;AACE;AACA;AACA;AACD;AjBklLH;AiBjlLE;AACA;AACD;AAED;AjBklLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AiBllLO;AACL;AACE;AACD;AjBolLH;AiBnlLE;AACD;AAED;AjBolLA;AACA;AACA;AACA;AACA;AiBplLO;AACL;AACD;AAED;AjBqlLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AiBrlLO;AACL;AACA;AACA;AjBulLF;AiBrlLE;AACE;AACD;AjBulLH;AiBrlLE;AACE;AACE;AACD;AjBulLL;AiBtlLI;AACD;AjBwlLH;AiBtlLE;AACE;AjBwlLJ;AiBvlLI;AACE;AACD;AACC;AACA;AACA;AACA;AACD;AjBylLL;AiBxlLI;AAA2B;AAAA;AAG5B;AjB0lLH;AiBxlLE;AACD;AAED;AjBylLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AiBzlLA;AACE;AAGA;AjBylLF;AiBxlLE;AACE;AACD;AjB0lLH;AACA;AiBxlLE;AAQD;AjBmlLD;AACA;AACA;AACA;AACA;AACA;AACA;AkB/wLA;AlBixLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AkB/wLA;AlBixLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AkB/wLO;AAA0D;AAAf;AAAe;AlBoxLjE;AkBnxLE;AACE;AACD;AACC;AACD;AACF;AlBqxLD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmBx0LA;AnB00LA;AmBz0LA;AnB20LA;AmB10LA;AnB40LA;AmB30LA;AnB60LA;AmB50LA;AnB80LA;AmB70LA;AnB+0LA;AmB90LA;AnBg1LA;AmB/0LA;AnBi1LA;AmBh1LA;AnBk1LA;AmB12LA;AnB42LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmBh2LA;AnBk2LA;AACA;AmBh2LA;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAV+B;AAajC;AnBi2LA;AACA;AACA;AACA;AmBh2LA;AAEA;AnBi2LA;AACA;AACA;AACA;AACA;AACA;AmBh2LA;AAEA;AnBi2LA;AmBh2LA;AAEA;AnBi2LA;AmBh2LA;AAEA;AnBi2LA;AmBh2LA;AAEA;AnBi2LA;AmBh2LA;AAEA;AnBi2LA;AmBh2LA;AAEA;AACE;AAA4B;AAC5B;AAA4B;AAC5B;AAA4B;AAG9B;AnBk2LA;AmBj2LO;AAEP;AnBk2LA;AACA;AACA;AACA;AACA;AACA;AACA;AmBn2LO;AACL;AACD;AAED;AnBo2LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmBp2LO;AACL;AACE;AAAI;AAAmC;AACvC;AACD;AnBw2LH;AmBt2LE;AACD;AAED;AnBu2LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmBv2LO;AACL;AACE;AACD;AnBy2LH;AmBv2LE;AAGA;AnBu2LF;AmBt2LE;AACE;AACD;AnBw2LH;AmBt2LE;AAAa;AAA0B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AnB02LJ;AmBn3LyC;AAavC;AnBy2LF;AmBx2LE;AACE;AACD;AAGD;AnBw2LF;AACA;AmBx2LE;AAIE;AACA;AACD;AAGD;AnBq2LF;AACA;AmBr2LE;AnBu2LF;AmBt2LE;AACE;AACD;AACC;AACD;AACC;AACD;AnBw2LH;AmBv2LE;AnBy2LF;AmBt2LE;AnBw2LF;AmBt2LE;AACE;AACD;AnBw2LH;AmBt2LE;AACD;AAED;AnBu2LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmBv2LO;AAKL;AACE;AACD;AnBq2LH;AmBp2LE;AACA;AAEA;AAOA;AACA;AACD;AACD;AnB+1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmB/1LO;AACL;AACA;AACD;AAED;AnBg2LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmBh2LO;AACL;AACD;AAED;AnBi2LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmBj2LO;AACL;AACA;AACA;AACA;AnBm2LF;AmBl2LE;AACE;AACE;AACD;AACF;AnBo2LH;AmBn2LE;AACD;AAED;AnBo2LA;AACA;AACA;AACA;AACA;AACA;AACA;AmBp2LO;AACL;AnBs2LF;AmBr2LE;AACE;AnBu2LJ;AmBt2LI;AACE;AACD;AACC;AACE;AAAW;AAAuB;AAClC;AACD;AACF;AACC;AAAW;AAAuB;AAClC;AACD;AACF;AnB42LH;AmB32LE;AACD;AAED;AnB42LA;AACA;AACA;AACA;AACA;AACA;AmB52LO;AACL;AACE;AACD;AnB82LH;AmB72LE;AAMD;AAED;AnBy2LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmBz2LO;AAIL;AADA;AACA;AnB02LF;AmBz2LE;AnB22LF;AmBp2LE;AAAqB;AAAuB;AAC5C;AASA;AACD;AAED;AnB+1LA;AACA;AACA;AACA;AACA;AACA;AmB/1LO;AACL;AAKA;AACD;AAED;AnB41LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmB51LO;AACL;AACD;AAED;AnB61LA;AACA;AACA;AACA;AACA;AACA;AACA;AmB71LO;AACL;AnB+1LF;AmB91LE;AACE;AACD;AnBg2LH;AmB/1LE;AACD;AAED;AnBg2LA;AACA;AACA;AACA;AACA;AACA;AACA;AmBh2LO;AACL;AnBk2LF;AmBj2LE;AACE;AACD;AnBm2LH;AmBl2LE;AACD;AAED;AnBm2LA;AACA;AACA;AACA;AACA;AACA;AmBn2LO;AACL;AACE;AACD;AnBq2LH;AmBp2LE;AACD;AAED;AnBq2LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmBr2LO;AACL;AACE;AACD;AnBu2LH;AmBt2LE;AACE;AACD;AnBw2LH;AmBv2LE;AACA;AACD;AAED;AnBw2LA;AACA;AACA;AACA;AACA;AACA;AmBx2LO;AACL;AACE;AACD;AnB02LH;AmBz2LE;AACD;AAED;AnB02LA;AACA;AACA;AACA;AACA;AACA;AACA;AmB12LO;AACL;AACE;AACD;AnB42LH;AmB32LE;AACE;AACD;AnB62LH;AmB52LE;AACD;AAED;AnB62LA;AACA;AACA;AACA;AACA;AACA;AmB72LO;AACL;AACA;AACA;AACD;AAED;AnB82LA;AACA;AACA;AACA;AACA;AACA;AmB92LO;AACL;AnBg3LF;AmB/2LE;AACE;AACD;AnBi3LH;AmBh3LE;AACA;AACD;AAED;AnBi3LA;AACA;AACA;AACA;AACA;AACA;AACA;AmBj3LA;AACE;AACE;AACD;AnBm3LH;AmBl3LE;AnBo3LF;AmB72LE;AACD;AAED;AnB82LA;AACA;AACA;AACA;AACA;AACA;AACA;AmB92LO;AACL;AACA;AACA;AACE;AACD;AnBg3LH;AmB/2LE;AACA;AACA;AACD;AAED;AnBg3LA;AACA;AACA;AACA;AACA;AACA;AACA;AmBh3LO;AACL;AACE;AACD;AnBk3LH;AACA;AmBh3LE;AACE;AACD;AAGD;AACA;AACA;AnBg3LF;AACA;AmBh3LE;AACA;AACA;AAKA;AACA;AnB82LF;AmBz2LE;AACA;AACA;AAMD;AAED;AnBq2LA;AACA;AACA;AACA;AACA;AACA;AACA;AmBr2LO;AACL;AACD;AAED;AnBs2LA;AACA;AACA;AACA;AACA;AACA;AACA;AmBt2LO;AACL;AACE;AACD;AnBw2LH;AmBv2LE;AACE;AACD;AnBy2LH;AmBx2LE;AACD;AAED;AnBy2LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmBz2LO;AACL;AACE;AACD;AnB22LH;AmB12LE;AACA;AnB42LF;AmBz2LE;AACE;AACD;AnB22LH;AACA;AmBz2LE;AACE;AACD;AnB22LH;AACA;AmBz2LE;AACE;AACD;AnB22LH;AACA;AmBz2LE;AAKD;AAED;AnBs2LA;AACA;AACA;AACA;AACA;AACA;AACA;AmBt2LO;AACL;AACA;AACA;AACD;AAED;AnBu2LA;AACA;AACA;AACA;AACA;AmBv2LO;AACL;AACA;AACA;AAKD;AAED;AnBo2LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmBp2LO;AACL;AACD;AnBs2LD;AACA;AACA;AACA;AACA;AACA;AACA;AoBv/MA;ApBy/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AoBt/MA;ApBw/MA;AoBv/MA;ApBy/MA;AoBv/MA;ApBy/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AoBv/MO;AACL;AACA;AACA;AACA;AACE;AAAgB;AADP;AACO;ApB4/MpB;AoB3/MM;AACA;AACA;AACD;ApB6/ML;AoB5/MI;AACD;AACF;ApB8/MD;AACA;AACA;AACA;AACA;AACA;AACA;AqB/hNA;ArBiiNA;AqBjjNA;ArBmjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AqB/iNA;AACA;AAEA;ArBgjNA;AACA;AACA;AACA;AACA;AACA;AqBjjNE;ArBmjNF;AACA;AqBjjNE;AACE;AACA;AAEA;ArBkjNJ;AqBjjNI;AAEA;ArBkjNJ;AACA;AACA;AACA;AqBjjNI;AAEA;ArBkjNJ;AqBjjNI;AACD;AAED;ArBkjNF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AqBpjNI;AACD;AAED;ArBqjNF;AACA;AACA;AACA;AACA;AACA;AqBrjNI;ArBujNJ;AqBtjNI;AACE;AACA;AACD;ArBwjNL;AqBvjNI;AACD;AAED;ArBwjNF;AACA;AACA;AACA;AACA;AACA;AqBxjNI;AACE;AACD;ArB0jNL;AqBzjNI;AAAoB;AAAS;AAAV;AACnB;AACD;AAED;ArB6jNF;AACA;AACA;AACA;AACA;AqB7jNI;AACE;AACD;ArB+jNL;AqB7jNI;AACA;AACA;AACA;ArB+jNJ;AqB9jNI;AAAyB;ArBikN7B;AqB/jNM;AACE;AACA;AACD;AACF;ArBikNL;AqB/jNI;AACE;AACA;AACD;AACF;ArBikNH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AsBzqNA;AtB2qNA;AsB3rNA;AtB6rNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AsBzrNA;AACA;AAEA;AtB0rNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AsBzrNO;AACL;AtB2rNF;AsB1rNE;AACE;AACD;AtB4rNH;AsB3rNE;AACD;AAED;AtB4rNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AsB5rNO;AACL;AACA;AACA;AAAO;AAA4B;AAAnC;AACD;AAED;AtBgsNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AsBhsNO;AACL;AACD;AAED;AtBisNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AsBjsNO;AACL;AACE;AACD;AACC;AACD;AACF;AAED;AtBksNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AsBlsNO;AAA+C;AAAZ;AAAY;AtBusNtD;AsBtsNE;AACA;AAEA;AtBusNF;AsBtsNE;AACA;AAAY;AAAW;AAAW;AAAvB;AtB4sNb;AsBltNsD;AAAA;AAAA;AAAA;AAAA;AtBwtNtD;AsB7sNI;AACE;AACD;AtB+sNL;AsB9sNI;AtBgtNJ;AsB/sNI;AACE;AACD;AtBitNL;AsBhtNI;AACE;AACA;AACD;AtBktNL;AsBjtNI;AACE;AAEA;AtBktNN;AsBjtNM;AACE;AtBmtNR;AsBltNQ;AACE;AAAY;AAAa;AAAa;AAA3B;AACX;AACD;AACF;AtBwtNP;AsBvtNM;AACD;AAlCiD;AtB4vNtD;AsBnvNE;AAAyB;AtBsvN3B;AsBtvN2B;AA0BxB;AtB+tNH;AsB9tNE;AACD;AAED;AtB+tNA;AACA;AACA;AACA;AACA;AACA;AsB/tNO;AACL;AACE;AACE;AACD;AtBiuNL;AsBhuNI;AACD;AACF;AtBkuND;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AuB13NA;AvB43NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AuB13NA;AvB43NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AuB13NE;AvB43NF;AACA;AuB13NE;AACE;AAEA;AvB23NJ;AACA;AACA;AuB13NI;AAAmB;AAAO;AACxB;AACA;AACD;AAED;AvB63NJ;AACA;AACA;AuB53NI;AAEA;AvB63NJ;AACA;AACA;AuB53NI;AACD;AAGH;AvB43NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AuB93NO;AACL;AACE;AACD;AACF;AAED;AvB+3NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AuB/3NO;AAAmC;AAAX;AAAW;AvBo4N1C;AuBn4NE;AACE;AACA;AvBq4NJ;AuBp4NI;AACE;AACD;AvBs4NL;AuBr4NI;AACE;AACD;AvBu4NL;AuBt4NI;AACA;AvBw4NJ;AuBt4NI;AACE;AACE;AACD;AvBw4NP;AuBv4NM;AACE;AACD;AACF;AvBy4NL;AuBx4NI;AACE;AACE;AACD;AvB04NP;AuBz4NM;AACE;AACD;AACF;AvB24NL;AuB14NI;AACE;AACD;AACF;AACF;AAED;AvB24NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AuB74NE;AvB+4NF;AACA;AuB74NE;AACE;AACA;AvB+4NJ;AuB94NI;AACE;AACA;AACD;AAED;AvB+4NJ;AuB94NI;AAEA;AvB+4NJ;AuB94NI;AAEA;AvB+4NJ;AuB94NI;AvBg5NJ;AuB94NI;AACE;AACE;AACD;AACF;AACF;AAED;AvB+4NF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AuBl5Ne;AvBo5Nf;AuBn5NI;AACA;AAEI;AACE;AACD;AACF;AAEC;AACA;AACA;AACE;AACD;AACF;AAEH;AACD;AAED;AvBi5NF;AACA;AACA;AuBj5NI;AACD;AvBm5NH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AwBnlOA;AxBqlOA;AwBllOA;AxBolOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AwBllOA;AxBolOA;AwBllOA;AACE;AACA;AACE;AACD;AxBolOH;AACA;AwBnlOE;AACE;AACD;AAED;AACA;AxBolOF;AACA;AwBplOE;AACE;AACD;AAED;AxBqlOF;AACA;AwBrlOE;AACD;AAED;AxBslOA;AACA;AACA;AACA;AACA;AACA;AwBtlOO;AACL;AACD;AxBwlOD;AACA;AACA;AACA;AACA;AACA;AACA;AyB/oOA;AzBipOA;AACA;AACA;AACA;AyB/oOA;AAEA;AAEE;AzB+oOF;AyB9oOE;AACE;AACD;AzBgpOH;AyB9oOE;AACE;AACD;AAED;AzB+oOF;AACA;AACA;AACA;AACA;AyB/oOE;AACE;AACD;AzBipOH;AyB/oOE;AACE;AACD;AAED;AzBgpOF;AACA;AACA;AACA;AACA;AyBhpOE;AACE;AAED;AAGD;AzB+oOF;AACA;AyB/oOE;AzBipOF;AyBhpOE;AACE;AACD;AzBkpOH;AyBhpOE;AzBkpOF;AyBjpOE;AACE;AACD;AzBmpOH;AyBjpOE;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARc;AzB4pOlB;AyBjpOE;AACE;AACE;AACD;AACF;AzBmpOH;AyBjpOE;AACA;AACA;AACA;AACA;AAEA;AzBkpOF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AyBjpOE;AACE;AAGA;AzBipOJ;AyBhpOI;AzBkpOJ;AyBjpOI;AzBmpOJ;AyBlpOI;AzBopOJ;AyBnpOI;AAEA;AACA;AzBopOJ;AyBnpOI;AACE;AACE;AACE;AADF;AAED;AACC;AACD;AzBspOP;AyBppOM;AACA;AACD;AzBspOL;AyBppOI;AzBspOJ;AyBrpOI;AACE;AAGA;AAGA;AACA;AACA;AACD;AzBmpOL;AyBjpOI;AAEA;AAEA;AzBipOJ;AyBhpOI;AACE;AzBkpON;AyB/oOM;AzBipON;AyB/oOM;AACE;AACE;AzBipOV;AyB/oOU;AACE;AACD;AACC;AACD;AzBipOX;AyB/oOU;AACA;AzBipOV;AyB9oOU;AAED;AACF;AzB+oOP;AACA;AyB7oOM;AAGA;AzB6oON;AyB1oOM;AACA;AzB4oON;AyBzoOM;AACE;AACA;AACA;AACD;AACC;AACA;AACA;AACA;AACD;AACC;AACD;AzB2oOP;AACA;AyBzoOM;AAGA;AACA;AzByoON;AyBvoOM;AACE;AACD;AACC;AACA;AAEA;AAGA;AAED;AACC;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AzBooON;AyBnoOK;AzBqoOL;AACA;AyBnoOI;AAEA;AAGA;AACD;AAED;AzBioOF;AACA;AACA;AACA;AACA;AyBjoOE;AACE;AAEA;AzBkoOJ;AyBjoOI;AACE;AzBmoON;AyBjoOM;AACE;AACE;AACA;AACD;AACC;AACA;AACD;AACF;AACF;AzBmoOL;AyBjoOI;AACD;AAED;AzBkoOF;AACA;AACA;AACA;AACA;AACA;AACA;AyBloOE;AACE;AACA;AACA;AAEA;AzBmoOJ;AyBloOI;AACE;AzBooON;AyBloOM;AACE;AACA;AACE;AACA;AACA;AACA;AzBooOV;AyBnoOQ;AACE;AACA;AACA;AACA;AzBqoOV;AyBpoOQ;AACE;AAbJ;AAeD;AzBsoOL;AyBpoOI;AACD;AAED;AzBqoOF;AACA;AACA;AACA;AACA;AyBroOE;AACE;AACA;AACA;AACD;AAED;AzBsoOF;AACA;AACA;AACA;AyBtoOE;AACE;AACD;AAED;AzBuoOF;AACA;AACA;AACA;AACA;AyBvoOE;AACE;AAEA;AAGA;AAEA;AACA;AAEA;AACD;AAED;AzBmoOF;AACA;AACA;AACA;AACA;AyBnoOE;AACE;AAAA;AzBsoOJ;AyBpoOI;AACE;AACE;AACA;AACA;AzBsoOR;AyBroOM;AACE;AACA;AzBuoOR;AyBtoOM;AACE;AACA;AAVJ;AzBmpOJ;AyBtoOI;AAEA;AACD;AAED;AzBsoOF;AACA;AACA;AACA;AACA;AyBtoOE;AACE;AACA;AAAe;AAAF;AACb;AACD;AAED;AzByoOF;AACA;AACA;AACA;AACA;AyBzoOE;AACE;AACD;AAED;AzB0oOF;AACA;AACA;AACA;AACA;AyB1oOE;AACE;AAEA;AzB2oOJ;AyB1oOI;AACE;AACD;AACC;AAAA;AAAA;AAAA;AzB+oON;AyB7oOM;AACE;AACE;AACA;AACA;AAEA;AzB8oOV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AyB7oOU;AACE;AACE;AACA;AACD;AzB+oOb;AyB9oOY;AAEA;AACD;AACF;AACC;AACE;AACD;AACC;AACA;AACD;AACF;AzB+oOT;AyB7oOQ;AAGA;AACD;AzB6oOP;AyB3oOM;AACD;AzB6oOL;AyB3oOI;AAGA;AACD;AAED;AzB0oOF;AACA;AACA;AACA;AACA;AACA;AyB1oOE;AACE;AACD;AAED;AzB2oOF;AACA;AACA;AACA;AyB3oOE;AACE;AACD;AAED;AzB4oOF;AACA;AACA;AACA;AACA;AyB5oOE;AACE;AACA;AAEA;AAGA;AACD;AAED;AzB0oOF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AyB1oOE;AACE;AACA;AACA;AACD;AAED;AzB2oOF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AyB3oOE;AACE;AAEA;AzB4oOJ;AyB3oOI;AACE;AACA;AACA;AAEA;AAOA;AAED;AzBqoOL;AyBnoOI;AACD;AzBqoOH;AyBnoOE;AACE;AACA;AACA;AAGA;AzBmoOJ;AyBloOI;AACE;AACD;AzBooOL;AyBloOI;AzBooOJ;AyBloOI;AACE;AACE;AACD;AACF;AACC;AACD;AACC;AzBooON;AyBhoOM;AAEA;AAED;AACC;AACD;AzBgoOL;AyB/nOI;AACD;AzBioOH;AyB/nOE;AACE;AAGA;AzB+nOJ;AyB9nOI;AAED;AzB+nOH;AyB7nOE;AACE;AAEA;AACA;AAED;AzB6nOH;AyB3nOE;AACE;AzB6nOJ;AyB5nOI;AACE;AACE;AACD;AzB8nOP;AyB7nOM;AACD;AACF;AzB+nOH;AyB7nOE;AACE;AACA;AAED;AzB8nOH;AyB5nOE;AACE;AACD;AzB8nOH;AyB5nOE;AACA;AACA;AzB8nOF;AyB3nOE;AAEA;AzB4nOF;AACA;AACA;AyB3nOE;AACE;AACD;AAED;AzB4nOF;AACA;AACA;AACA;AACA;AACA;AyB5nOE;AACE;AACD;AAED;AzB6nOF;AACA;AACA;AACA;AACA;AyB7nOE;AACE;AACE;AAGD;AzB6nOL;AyB3nOI;AACD;AzB6nOH;AyB1nOE;AAAoB;AzB6nOtB;AACA;AyB7nOE;AACE;AAEA;AzB8nOJ;AyB5nOI;AACE;AACD;AACC;AACD;AACF;AAGD;AzB4nOF;AACA;AyB5nOE;AzB8nOF;AyB3nOE;AzB6nOF;AyB5nOE;AACE;AACD;AzB8nOH;AACA;AyB5nOE;AACA;AACA;AAED;AzB6nOD;AyB7nOC;AAED;AACA;AzB8nOA;AACA;AACA;AACA;AACA;AFtwPA;AACA","file":"amp-mustache-0.2.max.js","sourcesContent":["(self.AMP=self.AMP||[]).push({n:\"amp-mustache\",v:\"1910040511210\",f:(function(AMP,_){\n$1\n})});","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.AmpMustache = void 0;\n\nvar _object = require(\"../../../src/utils/object\");\n\nvar _dom = require(\"../../../src/dom\");\n\nvar _purifier = require(\"../../../src/purifier\");\n\nvar _mustache = _interopRequireDefault(require(\"../../../third_party/mustache/mustache\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar TAG = 'amp-mustache';\nvar BaseTemplate =\n/** @type {function(new:../../../src/service/template-impl.BaseTemplate)} */\nAMP.BaseTemplate;\n/**\n * Implements an AMP template for Mustache.js.\n * See {@link https://github.com/janl/mustache.js/}.\n *\n * @visibleForTesting\n */\n\nvar AmpMustache =\n/*#__PURE__*/\nfunction (_BaseTemplate) {\n  _inheritsLoose(AmpMustache, _BaseTemplate);\n\n  /**\n   * @param {!Element} element\n   * @param {!Window} win\n   */\n  function AmpMustache(element, win) {\n    var _this;\n\n    _this = _BaseTemplate.call(this, element, win) || this; // Unescaped templating (triple mustache) has a special, strict sanitizer.\n\n    _mustache.default.setUnescapedSanitizer(function (value) {\n      return (0, _purifier.purifyTagsForTripleMustache)(value, _this.win.document);\n    });\n\n    return _this;\n  }\n  /** @override */\n\n\n  var _proto = AmpMustache.prototype;\n\n  _proto.compileCallback = function compileCallback() {\n    // If viewer is renderTemplate capable, skip the handling of the mustache\n    // templates as its rendering is managed by the viewer. This template will\n    // only be responsible for sanitizing and inserting it into the DOM.\n    if (this.viewerCanRenderTemplates()) {\n      return;\n    }\n    /** @private @const {!JsonObject} */\n\n\n    this.nestedTemplates_ = (0, _object.dict)();\n    /** @private @const {string} */\n\n    this.template_ = this.initTemplateString_();\n\n    _mustache.default.parse(this.template_,\n    /* tags */\n    undefined);\n  }\n  /**\n   * @private\n   * @return {string}\n   */\n  ;\n\n  _proto.initTemplateString_ = function initTemplateString_() {\n    if (this.element.tagName == 'TEMPLATE') {\n      var content = (0, _dom.templateContentClone)(this.element);\n      this.processNestedTemplates_(content);\n      var container = this.element.ownerDocument.createElement('div');\n      container.appendChild(content);\n      return container.\n      /*OK*/\n      innerHTML;\n    } else if (this.element.tagName == 'SCRIPT') {\n      return this.element.textContent;\n    }\n\n    return '';\n  }\n  /**\n   * Stores and replaces nested templates with custom triple-mustache pointers.\n   *\n   * This prevents the outer-most template from replacing variables in nested\n   * templates. Note that this constrains nested template markup to the more\n   * restrictive sanitization rules of triple-mustache.\n   *\n   * @param {!DocumentFragment} content\n   */\n  ;\n\n  _proto.processNestedTemplates_ = function processNestedTemplates_(content) {\n    var _this2 = this;\n\n    var templates = content.querySelectorAll('template');\n    (0, _dom.iterateCursor)(templates, function (template, index) {\n      var key = \"__AMP_NESTED_TEMPLATE_\" + index; // Store the nested template markup, keyed by index.\n\n      _this2.nestedTemplates_[key] = template.\n      /*OK*/\n      outerHTML; // Replace the markup with a pointer.\n\n      var pointer = _this2.element.ownerDocument.createTextNode(\"{{{\" + key + \"}}}\");\n\n      template.parentNode.replaceChild(pointer, template);\n    });\n  }\n  /** @override */\n  ;\n\n  _proto.setHtml = function setHtml(html) {\n    return this.purifyAndSetHtml_(html);\n  }\n  /** @override */\n  ;\n\n  _proto.render = function render(data) {\n    var mustacheData = data; // Also render any nested templates.\n\n    if (typeof data === 'object') {\n      mustacheData = Object.assign({}, data, this.nestedTemplates_);\n    }\n\n    var html = _mustache.default.render(this.template_, mustacheData,\n    /* partials */\n    undefined);\n\n    return this.purifyAndSetHtml_(html);\n  }\n  /**\n   *\n   * @param {string} html\n   * @return {!Element}\n   * @private\n   */\n  ;\n\n  _proto.purifyAndSetHtml_ = function purifyAndSetHtml_(html) {\n    var body = (0, _purifier.purifyHtml)(html, this.win.document); // TODO(choumx): Remove innerHTML usage once DOMPurify bug is fixed.\n    // https://github.com/cure53/DOMPurify/pull/295\n\n    var root = this.win.document.createElement('div');\n    root.\n    /*OK*/\n    innerHTML = body.\n    /*OK*/\n    innerHTML;\n    return this.unwrap(root);\n  };\n\n  return AmpMustache;\n}(BaseTemplate);\n\nexports.AmpMustache = AmpMustache;\nAMP.extension(TAG, '0.2', function (AMP) {\n  AMP.registerTemplate(TAG, AmpMustache);\n});\n\n},{\"../../../src/dom\":5,\"../../../src/purifier\":11,\"../../../src/utils/object\":22,\"../../../third_party/mustache/mustache\":25}],2:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar freeze$1 = Object.freeze || function (x) {\n  return x;\n};\n\nvar html = freeze$1(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG\n\nvar svg = freeze$1(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern']);\nvar svgFilters = freeze$1(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\nvar mathMl = freeze$1(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\nvar text = freeze$1(['#text']);\n\nvar freeze$2 = Object.freeze || function (x) {\n  return x;\n};\n\nvar html$1 = freeze$2(['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'coords', 'crossorigin', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'integrity', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);\nvar svg$1 = freeze$2(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\nvar mathMl$1 = freeze$2(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\nvar xml = freeze$2(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\nvar hasOwnProperty = Object.hasOwnProperty;\nvar setPrototypeOf = Object.setPrototypeOf;\n\nvar _ref$1 = typeof Reflect !== 'undefined' && Reflect;\n\nvar apply$1 = _ref$1.apply;\n\nif (!apply$1) {\n  apply$1 = function apply(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n/* Add properties to a lookup table */\n\n\nfunction addToSet(set, array) {\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  var l = array.length;\n\n  while (l--) {\n    var element = array[l];\n\n    if (typeof element === 'string') {\n      var lcElement = element.toLowerCase();\n\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!Object.isFrozen(array)) {\n          array[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n/* Shallow clone an object */\n\n\nfunction clone(object) {\n  var newObject = {};\n  var property = void 0;\n\n  for (property in object) {\n    if (apply$1(hasOwnProperty, object, [property])) {\n      newObject[property] = object[property];\n    }\n  }\n\n  return newObject;\n}\n\nvar seal = Object.seal || function (x) {\n  return x;\n};\n\nvar MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n\nvar ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\nvar DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n\nvar ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n\nvar IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nvar IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nvar ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g // eslint-disable-line no-control-regex\n);\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nvar _ref = typeof Reflect !== 'undefined' && Reflect;\n\nvar apply = _ref.apply;\nvar arraySlice = Array.prototype.slice;\nvar freeze = Object.freeze;\n\nvar getGlobal = function getGlobal() {\n  return typeof window === 'undefined' ? null : window;\n};\n\nif (!apply) {\n  apply = function apply(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n * @param {Document} document The document object (to determine policy name suffix)\n * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n * are not supported).\n */\n\n\nvar _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n    return null;\n  } // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n\n\n  var suffix = null;\n  var ATTR_NAME = 'data-tt-policy-suffix';\n\n  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n    suffix = document.currentScript.getAttribute(ATTR_NAME);\n  }\n\n  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML: function createHTML(html$$1) {\n        return html$$1;\n      }\n    });\n  } catch (error) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n    return null;\n  }\n};\n\nfunction createDOMPurify() {\n  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n  var DOMPurify = function DOMPurify(root) {\n    return createDOMPurify(root);\n  };\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n\n\n  DOMPurify.version = '2.0.2';\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n\n  DOMPurify.removed = [];\n\n  if (!window || !window.document || window.document.nodeType !== 9) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n    return DOMPurify;\n  }\n\n  var originalDocument = window.document;\n  var useDOMParser = false;\n  var removeSVGAttr = false;\n  var removeTitle = false;\n  var document = window.document;\n  var DocumentFragment = window.DocumentFragment,\n      HTMLTemplateElement = window.HTMLTemplateElement,\n      Node = window.Node,\n      NodeFilter = window.NodeFilter,\n      _window$NamedNodeMap = window.NamedNodeMap,\n      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n      Text = window.Text,\n      Comment = window.Comment,\n      DOMParser = window.DOMParser,\n      TrustedTypes = window.TrustedTypes; // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n\n  if (typeof HTMLTemplateElement === 'function') {\n    var template = document.createElement('template');\n\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  var trustedTypesPolicy = _createTrustedTypesPolicy(TrustedTypes, originalDocument);\n\n  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';\n  var _document = document,\n      implementation = _document.implementation,\n      createNodeIterator = _document.createNodeIterator,\n      getElementsByTagName = _document.getElementsByTagName,\n      createDocumentFragment = _document.createDocumentFragment;\n  var importNode = originalDocument.importNode;\n  var hooks = {};\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n\n  DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && document.documentMode !== 9;\n  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n      ERB_EXPR$$1 = ERB_EXPR,\n      DATA_ATTR$$1 = DATA_ATTR,\n      ARIA_ATTR$$1 = ARIA_ATTR,\n      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n\n  var ALLOWED_TAGS = null;\n  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(svgFilters), _toConsumableArray(mathMl), _toConsumableArray(text)));\n  /* Allowed attribute names */\n\n  var ALLOWED_ATTR = null;\n  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(mathMl$1), _toConsumableArray(xml)));\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n\n  var FORBID_TAGS = null;\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n\n  var FORBID_ATTR = null;\n  /* Decide if ARIA attributes are okay */\n\n  var ALLOW_ARIA_ATTR = true;\n  /* Decide if custom data attributes are okay */\n\n  var ALLOW_DATA_ATTR = true;\n  /* Decide if unknown protocols are okay */\n\n  var ALLOW_UNKNOWN_PROTOCOLS = false;\n  /* Output should be safe for jQuery's $() factory? */\n\n  var SAFE_FOR_JQUERY = false;\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n\n  var SAFE_FOR_TEMPLATES = false;\n  /* Decide if document with <html>... should be returned */\n\n  var WHOLE_DOCUMENT = false;\n  /* Track whether config is already set on this instance of DOMPurify. */\n\n  var SET_CONFIG = false;\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n\n  var FORCE_BODY = false;\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n\n  var RETURN_DOM = false;\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n\n  var RETURN_DOM_FRAGMENT = false;\n  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n   * `Node` is imported into the current `Document`. If this flag is not enabled the\n   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n   * DOMPurify. */\n\n  var RETURN_DOM_IMPORT = false;\n  /* Try to return a Trusted Type object instead of a string, retrun a string in\n   * case Trusted Types are not supported  */\n\n  var RETURN_TRUSTED_TYPE = false;\n  /* Output should be free from DOM clobbering attacks? */\n\n  var SANITIZE_DOM = true;\n  /* Keep element content when removing element? */\n\n  var KEEP_CONTENT = true;\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n\n  var IN_PLACE = false;\n  /* Allow usage of profiles like html, svg and mathMl */\n\n  var USE_PROFILES = {};\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n\n  var FORBID_CONTENTS = addToSet({}, ['audio', 'colgroup', 'head', 'math', 'script', 'style', 'template', 'thead', 'svg', 'video']);\n  /* Tags that are safe for data: URIs */\n\n  var DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image']);\n  /* Attributes safe for values like \"javascript:\" */\n\n  var URI_SAFE_ATTRIBUTES = null;\n  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);\n  /* Keep a reference to config to pass to hooks */\n\n  var CONFIG = null;\n  /* Ideally, do not touch anything below this line */\n\n  /* ______________________________________________ */\n\n  var formElement = document.createElement('form');\n  /**\n   * _parseConfig\n   *\n   * @param  {Object} cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n\n  var _parseConfig = function _parseConfig(cfg) {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n    /* Shield configuration object from tampering */\n\n\n    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n      cfg = {};\n    }\n    /* Set configuration parameters */\n\n\n    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet({}, cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n\n    SAFE_FOR_JQUERY = cfg.SAFE_FOR_JQUERY || false; // Default false\n\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n\n    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false\n\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n\n    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n    /* Parse profile info */\n\n\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(text)));\n      ALLOWED_ATTR = [];\n\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, html);\n        addToSet(ALLOWED_ATTR, html$1);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, svg);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, svgFilters);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, mathMl);\n        addToSet(ALLOWED_ATTR, mathMl$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n    }\n    /* Merge configuration parameters */\n\n\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n    }\n    /* Add #text in case KEEP_CONTENT is set to true */\n\n\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n\n\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n\n\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    } // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n\n\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n  /**\n   * _forceRemove\n   *\n   * @param  {Node} node a DOM node\n   */\n\n\n  var _forceRemove = function _forceRemove(node) {\n    DOMPurify.removed.push({\n      element: node\n    });\n\n    try {\n      node.parentNode.removeChild(node);\n    } catch (error) {\n      node.outerHTML = emptyHTML;\n    }\n  };\n  /**\n   * _removeAttribute\n   *\n   * @param  {String} name an Attribute name\n   * @param  {Node} node a DOM node\n   */\n\n\n  var _removeAttribute = function _removeAttribute(name, node) {\n    try {\n      DOMPurify.removed.push({\n        attribute: node.getAttributeNode(name),\n        from: node\n      });\n    } catch (error) {\n      DOMPurify.removed.push({\n        attribute: null,\n        from: node\n      });\n    }\n\n    node.removeAttribute(name);\n  };\n  /**\n   * _initDocument\n   *\n   * @param  {String} dirty a string of dirty markup\n   * @return {Document} a DOM, filled with the dirty markup\n   */\n\n\n  var _initDocument = function _initDocument(dirty) {\n    /* Create a HTML document */\n    var doc = void 0;\n    var leadingWhitespace = void 0;\n\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      var matches = dirty.match(/^[\\s]+/);\n      leadingWhitespace = matches && matches[0];\n\n      if (leadingWhitespace) {\n        dirty = dirty.slice(leadingWhitespace.length);\n      }\n    }\n    /* Use DOMParser to workaround Firefox bug (see comment below) */\n\n\n    if (useDOMParser) {\n      try {\n        doc = new DOMParser().parseFromString(dirty, 'text/html');\n      } catch (error) {}\n    }\n    /* Remove title to fix a mXSS bug in older MS Edge */\n\n\n    if (removeTitle) {\n      addToSet(FORBID_TAGS, ['title']);\n    }\n    /* Otherwise use createHTMLDocument, because DOMParser is unsafe in\n    Safari (see comment below) */\n\n\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createHTMLDocument('');\n      var _doc = doc,\n          body = _doc.body;\n      body.parentNode.removeChild(body.parentNode.firstElementChild);\n      body.outerHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n    }\n\n    if (leadingWhitespace) {\n      doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);\n    }\n    /* Work on whole document or just its body */\n\n\n    return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n  }; // Firefox uses a different parser for innerHTML rather than\n  // DOMParser (see https://bugzilla.mozilla.org/show_bug.cgi?id=1205631)\n  // which means that you *must* use DOMParser, otherwise the output may\n  // not be safe if used in a document.write context later.\n  //\n  // So we feature detect the Firefox bug and use the DOMParser if necessary.\n  //\n  // Chrome 77 and other versions ship an mXSS bug that caused a bypass to\n  // happen. We now check for the mXSS trigger and react accordingly.\n\n\n  if (DOMPurify.isSupported) {\n    (function () {\n      try {\n        var doc = _initDocument('<svg><p><textarea><img src=\"</textarea><img src=x abc=1//\">');\n\n        if (doc.querySelector('svg img')) {\n          useDOMParser = true;\n        }\n      } catch (error) {}\n    })();\n\n    (function () {\n      try {\n        var doc = _initDocument('<x/><title>&lt;/title&gt;&lt;img&gt;');\n\n        if (doc.querySelector('title').innerHTML.match(/<\\/title/)) {\n          removeTitle = true;\n        }\n      } catch (error) {}\n    })();\n\n    (function () {\n      try {\n        var doc = _initDocument('<svg></p></svg>');\n\n        if (doc.querySelector('svg p')) {\n          removeSVGAttr = true;\n        }\n      } catch (error) {}\n    })();\n  }\n  /**\n   * _createIterator\n   *\n   * @param  {Document} root document/fragment to create iterator for\n   * @return {Iterator} iterator instance\n   */\n\n\n  var _createIterator = function _createIterator(root) {\n    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {\n      return NodeFilter.FILTER_ACCEPT;\n    }, false);\n  };\n  /**\n   * _isClobbered\n   *\n   * @param  {Node} elm element to check for clobbering attacks\n   * @return {Boolean} true if clobbered, false if safe\n   */\n\n\n  var _isClobbered = function _isClobbered(elm) {\n    if (elm instanceof Text || elm instanceof Comment) {\n      return false;\n    }\n\n    if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function') {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * _isNode\n   *\n   * @param  {Node} obj object to check whether it's a DOM node\n   * @return {Boolean} true is object is a DOM node\n   */\n\n\n  var _isNode = function _isNode(obj) {\n    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? obj instanceof Node : obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';\n  };\n  /**\n   * _executeHook\n   * Execute user configurable hooks\n   *\n   * @param  {String} entryPoint  Name of the hook's entry point\n   * @param  {Node} currentNode node to work on with the hook\n   * @param  {Object} data additional hook parameters\n   */\n\n\n  var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n    if (!hooks[entryPoint]) {\n      return;\n    }\n\n    hooks[entryPoint].forEach(function (hook) {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  };\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   *\n   * @param   {Node} currentNode to check for permission to exist\n   * @return  {Boolean} true if node was killed, false if left alive\n   */\n  // eslint-disable-next-line complexity\n\n\n  var _sanitizeElements = function _sanitizeElements(currentNode) {\n    var content = void 0;\n    /* Execute a hook if present */\n\n    _executeHook('beforeSanitizeElements', currentNode, null);\n    /* Check if element is clobbered or can clobber */\n\n\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n\n      return true;\n    }\n    /* Now let's check the element's type and name */\n\n\n    var tagName = currentNode.nodeName.toLowerCase();\n    /* Execute a hook if present */\n\n    _executeHook('uponSanitizeElement', currentNode, {\n      tagName: tagName,\n      allowedTags: ALLOWED_TAGS\n    });\n    /* Remove element if anything forbids its presence */\n\n\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      /* Keep content except for black-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function') {\n        try {\n          var htmlToInsert = currentNode.innerHTML;\n          currentNode.insertAdjacentHTML('AfterEnd', trustedTypesPolicy ? trustedTypesPolicy.createHTML(htmlToInsert) : htmlToInsert);\n        } catch (error) {}\n      }\n\n      _forceRemove(currentNode);\n\n      return true;\n    }\n    /* Remove in case a noscript/noembed XSS is suspected */\n\n\n    if (tagName === 'noscript' && currentNode.innerHTML.match(/<\\/noscript/i)) {\n      _forceRemove(currentNode);\n\n      return true;\n    }\n\n    if (tagName === 'noembed' && currentNode.innerHTML.match(/<\\/noembed/i)) {\n      _forceRemove(currentNode);\n\n      return true;\n    }\n    /* Remove in case an mXSS is suspected */\n\n\n    if (currentNode.namespaceURI && currentNode.namespaceURI.match(/svg|math/i) && currentNode.textContent && currentNode.textContent.match(new RegExp('</' + tagName, 'i'))) {\n      _forceRemove(currentNode);\n\n      return true;\n    }\n    /* Convert markup to cover jQuery behavior */\n\n\n    if (SAFE_FOR_JQUERY && !currentNode.firstElementChild && (!currentNode.content || !currentNode.content.firstElementChild) && /</g.test(currentNode.textContent)) {\n      DOMPurify.removed.push({\n        element: currentNode.cloneNode()\n      });\n\n      if (currentNode.innerHTML) {\n        currentNode.innerHTML = currentNode.innerHTML.replace(/</g, '&lt;');\n      } else {\n        currentNode.innerHTML = currentNode.textContent.replace(/</g, '&lt;');\n      }\n    }\n    /* Sanitize element content to be template-safe */\n\n\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n      content = content.replace(MUSTACHE_EXPR$$1, ' ');\n      content = content.replace(ERB_EXPR$$1, ' ');\n\n      if (currentNode.textContent !== content) {\n        DOMPurify.removed.push({\n          element: currentNode.cloneNode()\n        });\n        currentNode.textContent = content;\n      }\n    }\n    /* Execute a hook if present */\n\n\n    _executeHook('afterSanitizeElements', currentNode, null);\n\n    return false;\n  };\n  /**\n   * _isValidAttribute\n   *\n   * @param  {string} lcTag Lowercase tag name of containing element.\n   * @param  {string} lcName Lowercase attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n\n\n  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n    /* Make sure attribute cannot clobber */\n    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n      return false;\n    }\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n\n\n    if (ALLOW_DATA_ATTR && DATA_ATTR$$1.test(lcName)) {// This attribute is safe\n    } else if (ALLOW_ARIA_ATTR && ARIA_ATTR$$1.test(lcName)) {// This attribute is safe\n\n      /* Otherwise, check the name is permitted */\n    } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      return false;\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) {// This attribute is safe\n\n      /* Check no script, data or unknown possibly unsafe URI\n        unless we know URI values are safe for that attribute */\n    } else if (IS_ALLOWED_URI$$1.test(value.replace(ATTR_WHITESPACE$$1, ''))) {// This attribute is safe\n\n      /* Keep image data URIs alive if src/xlink:href is allowed */\n\n      /* Further prevent gadget XSS for dynamically built script tags */\n    } else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && value.indexOf('data:') === 0 && DATA_URI_TAGS[lcTag]) {// This attribute is safe\n\n      /* Allow unknown protocols: This provides support for links that\n        are handled by protocol handlers which may be unknown ahead of\n        time, e.g. fb:, spotify: */\n    } else if (ALLOW_UNKNOWN_PROTOCOLS && !IS_SCRIPT_OR_DATA$$1.test(value.replace(ATTR_WHITESPACE$$1, ''))) {// This attribute is safe\n\n      /* Check for binary attributes */\n      // eslint-disable-next-line no-negated-condition\n    } else if (!value) {// Binary attributes are safe at this point\n\n      /* Anything else, presume unsafe, do not add it back */\n    } else {\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param  {Node} currentNode to sanitize\n   */\n  // eslint-disable-next-line complexity\n\n\n  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n    var attr = void 0;\n    var value = void 0;\n    var lcName = void 0;\n    var idAttr = void 0;\n    var l = void 0;\n    /* Execute a hook if present */\n\n    _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n    var attributes = currentNode.attributes;\n    /* Check if we have attributes; if not we might have a text node */\n\n    if (!attributes) {\n      return;\n    }\n\n    var hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR\n    };\n    l = attributes.length;\n    /* Go backwards over all attributes; safely remove bad ones */\n\n    while (l--) {\n      attr = attributes[l];\n      var _attr = attr,\n          name = _attr.name,\n          namespaceURI = _attr.namespaceURI;\n      value = attr.value.trim();\n      lcName = name.toLowerCase();\n      /* Execute a hook if present */\n\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n\n      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n\n      value = hookEvent.attrValue;\n      /* Check for possible Chrome mXSS */\n\n      if (removeSVGAttr && value.match(/<\\//)) {\n        _forceRemove(currentNode);\n      }\n      /* Remove attribute */\n      // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to\n      // remove a \"name\" attribute from an <img> tag that has an \"id\"\n      // attribute at the time.\n\n\n      if (lcName === 'name' && currentNode.nodeName === 'IMG' && attributes.id) {\n        idAttr = attributes.id;\n        attributes = apply(arraySlice, attributes, []);\n\n        _removeAttribute('id', currentNode);\n\n        _removeAttribute(name, currentNode);\n\n        if (attributes.indexOf(idAttr) > l) {\n          currentNode.setAttribute('id', idAttr.value);\n        }\n      } else if ( // This works around a bug in Safari, where input[type=file]\n      // cannot be dynamically set after type has been removed\n      currentNode.nodeName === 'INPUT' && lcName === 'type' && value === 'file' && hookEvent.keepAttr && (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName])) {\n        continue;\n      } else {\n        // This avoids a crash in Safari v9.0 with double-ids.\n        // The trick is to first set the id to be empty and then to\n        // remove the attribute\n        if (name === 'id') {\n          currentNode.setAttribute(name, '');\n        }\n\n        _removeAttribute(name, currentNode);\n      }\n      /* Did the hooks approve of the attribute? */\n\n\n      if (!hookEvent.keepAttr) {\n        continue;\n      }\n      /* Sanitize attribute content to be template-safe */\n\n\n      if (SAFE_FOR_TEMPLATES) {\n        value = value.replace(MUSTACHE_EXPR$$1, ' ');\n        value = value.replace(ERB_EXPR$$1, ' ');\n      }\n      /* Is `value` valid for this attribute? */\n\n\n      var lcTag = currentNode.nodeName.toLowerCase();\n\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        continue;\n      }\n      /* Handle invalid data-* attribute set by try-catching it */\n\n\n      try {\n        if (namespaceURI) {\n          currentNode.setAttributeNS(namespaceURI, name, value);\n        } else {\n          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n          currentNode.setAttribute(name, value);\n        }\n\n        DOMPurify.removed.pop();\n      } catch (error) {}\n    }\n    /* Execute a hook if present */\n\n\n    _executeHook('afterSanitizeAttributes', currentNode, null);\n  };\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param  {DocumentFragment} fragment to iterate over recursively\n   */\n\n\n  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n    var shadowNode = void 0;\n\n    var shadowIterator = _createIterator(fragment);\n    /* Execute a hook if present */\n\n\n    _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n    while (shadowNode = shadowIterator.nextNode()) {\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeShadowNode', shadowNode, null);\n      /* Sanitize tags and elements */\n\n\n      if (_sanitizeElements(shadowNode)) {\n        continue;\n      }\n      /* Deep shadow DOM detected */\n\n\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n      /* Check attributes, sanitize if necessary */\n\n\n      _sanitizeAttributes(shadowNode);\n    }\n    /* Execute a hook if present */\n\n\n    _executeHook('afterSanitizeShadowDOM', fragment, null);\n  };\n  /**\n   * Sanitize\n   * Public method providing core sanitation functionality\n   *\n   * @param {String|Node} dirty string or DOM node\n   * @param {Object} configuration object\n   */\n  // eslint-disable-next-line complexity\n\n\n  DOMPurify.sanitize = function (dirty, cfg) {\n    var body = void 0;\n    var importedNode = void 0;\n    var currentNode = void 0;\n    var oldNode = void 0;\n    var returnNode = void 0;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n\n    if (!dirty) {\n      dirty = '<!-->';\n    }\n    /* Stringify, in case dirty is an object */\n\n\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      // eslint-disable-next-line no-negated-condition\n      if (typeof dirty.toString !== 'function') {\n        throw new TypeError('toString is not a function');\n      } else {\n        dirty = dirty.toString();\n\n        if (typeof dirty !== 'string') {\n          throw new TypeError('dirty is not a string, aborting');\n        }\n      }\n    }\n    /* Check we can run. Otherwise fall back or ignore */\n\n\n    if (!DOMPurify.isSupported) {\n      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n        if (typeof dirty === 'string') {\n          return window.toStaticHTML(dirty);\n        }\n\n        if (_isNode(dirty)) {\n          return window.toStaticHTML(dirty.outerHTML);\n        }\n      }\n\n      return dirty;\n    }\n    /* Assign config vars */\n\n\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n    /* Clean up removed elements */\n\n\n    DOMPurify.removed = [];\n\n    if (IN_PLACE) {\n      /* No special handling necessary for in-place sanitization */\n    } else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!-->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n\n      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && RETURN_TRUSTED_TYPE && dirty.indexOf('<') === -1) {\n        return trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      }\n      /* Initialize the document to work on */\n\n\n      body = _initDocument(dirty);\n      /* Check we have a DOM node from the data */\n\n      if (!body) {\n        return RETURN_DOM ? null : emptyHTML;\n      }\n    }\n    /* Remove first element node (ours) if FORCE_BODY is set */\n\n\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n    /* Get node iterator */\n\n\n    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n    /* Now start iterating over the created document */\n\n\n    while (currentNode = nodeIterator.nextNode()) {\n      /* Fix IE's strange behavior with manipulated textNodes #89 */\n      if (currentNode.nodeType === 3 && currentNode === oldNode) {\n        continue;\n      }\n      /* Sanitize tags and elements */\n\n\n      if (_sanitizeElements(currentNode)) {\n        continue;\n      }\n      /* Shadow DOM detected, sanitize it */\n\n\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n      /* Check attributes, sanitize if necessary */\n\n\n      _sanitizeAttributes(currentNode);\n\n      oldNode = currentNode;\n    }\n\n    oldNode = null;\n    /* If we sanitized `dirty` in-place, return it. */\n\n    if (IN_PLACE) {\n      return dirty;\n    }\n    /* Return sanitized string or DOM */\n\n\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (RETURN_DOM_IMPORT) {\n        /* AdoptNode() is not used because internal state is not reset\n               (e.g. the past names map of a HTMLFormElement), this is safe\n               in theory but we would rather not risk another attack vector.\n               The state that is cloned by importNode() is explicitly defined\n               by the specs. */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n    /* Sanitize final string template-safe */\n\n    if (SAFE_FOR_TEMPLATES) {\n      serializedHTML = serializedHTML.replace(MUSTACHE_EXPR$$1, ' ');\n      serializedHTML = serializedHTML.replace(ERB_EXPR$$1, ' ');\n    }\n\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n  };\n  /**\n   * Public method to set the configuration once\n   * setConfig\n   *\n   * @param {Object} cfg configuration object\n   */\n\n\n  DOMPurify.setConfig = function (cfg) {\n    _parseConfig(cfg);\n\n    SET_CONFIG = true;\n  };\n  /**\n   * Public method to remove the configuration\n   * clearConfig\n   *\n   */\n\n\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n  /**\n   * Public method to check if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   * isValidAttribute\n   *\n   * @param  {string} tag Tag name of containing element.\n   * @param  {string} attr Attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n   */\n\n\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    var lcTag = tag.toLowerCase();\n    var lcName = attr.toLowerCase();\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n  /**\n   * AddHook\n   * Public method to add DOMPurify hooks\n   *\n   * @param {String} entryPoint entry point for the hook to add\n   * @param {Function} hookFunction function to execute\n   */\n\n\n  DOMPurify.addHook = function (entryPoint, hookFunction) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n\n    hooks[entryPoint] = hooks[entryPoint] || [];\n    hooks[entryPoint].push(hookFunction);\n  };\n  /**\n   * RemoveHook\n   * Public method to remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if more are present)\n   *\n   * @param {String} entryPoint entry point for the hook to remove\n   */\n\n\n  DOMPurify.removeHook = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint].pop();\n    }\n  };\n  /**\n   * RemoveHooks\n   * Public method to remove all DOMPurify hooks at a given entryPoint\n   *\n   * @param  {String} entryPoint entry point for the hooks to remove\n   */\n\n\n  DOMPurify.removeHooks = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint] = [];\n    }\n  };\n  /**\n   * RemoveAllHooks\n   * Public method to remove all DOMPurify hooks\n   *\n   */\n\n\n  DOMPurify.removeAllHooks = function () {\n    hooks = {};\n  };\n\n  return DOMPurify;\n}\n\nvar purify = createDOMPurify();\nvar _default = purify;\nexports.default = _default;\n\n},{}],3:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.config = exports.urls = void 0;\n\n/**\n * Copyright 2016 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Allows for runtime configuration. Internally, the runtime should\n * use the src/config.js module for various constants. We can use the\n * AMP_CONFIG global to translate user-defined configurations to this\n * module.\n * @type {!Object<string, string>}\n */\nvar env = self.AMP_CONFIG || {};\nvar thirdPartyFrameRegex = typeof env['thirdPartyFrameRegex'] == 'string' ? new RegExp(env['thirdPartyFrameRegex']) : env['thirdPartyFrameRegex'];\nvar cdnProxyRegex = typeof env['cdnProxyRegex'] == 'string' ? new RegExp(env['cdnProxyRegex']) : env['cdnProxyRegex'];\n/** @type {!Object<string, string|boolean|RegExp|Array<RegExp>>} */\n\nvar urls = {\n  thirdParty: env['thirdPartyUrl'] || 'https://3p.ampproject.net',\n  thirdPartyFrameHost: env['thirdPartyFrameHost'] || 'ampproject.net',\n  thirdPartyFrameRegex: thirdPartyFrameRegex || /^d-\\d+\\.ampproject\\.net$/,\n  cdn: env['cdnUrl'] || 'https://cdn.ampproject.org',\n\n  /* Note that cdnProxyRegex is only ever checked against origins\n   * (proto://host[:port]) so does not need to consider path\n   */\n  cdnProxyRegex: cdnProxyRegex || /^https:\\/\\/([a-zA-Z0-9_-]+\\.)?cdn\\.ampproject\\.org$/,\n  localhostRegex: /^https?:\\/\\/localhost(:\\d+)?$/,\n  errorReporting: env['errorReportingUrl'] || 'https://amp-error-reporting.appspot.com/r',\n  localDev: env['localDev'] || false,\n\n  /**\n   * These domains are trusted with more sensitive viewer operations such as\n   * propagating the referrer. If you believe your domain should be here,\n   * file the issue on GitHub to discuss. The process will be similar\n   * (but somewhat more stringent) to the one described in the [3p/README.md](\n   * https://github.com/ampproject/amphtml/blob/master/3p/README.md)\n   *\n   * {!Array<!RegExp>}\n   */\n  trustedViewerHosts: [/(^|\\.)google\\.(com?|[a-z]{2}|com?\\.[a-z]{2}|cat)$/, /(^|\\.)gmail\\.dev$/]\n};\nexports.urls = urls;\nvar config = {\n  urls: urls\n};\nexports.config = config;\n\n},{}],4:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.assertIsName = assertIsName;\nexports.setScopeSelectorSupportedForTesting = setScopeSelectorSupportedForTesting;\nexports.isScopeSelectorSupported = isScopeSelectorSupported;\nexports.prependSelectorsWith = prependSelectorsWith;\nexports.escapeCssSelectorIdent = escapeCssSelectorIdent;\nexports.escapeCssSelectorNth = escapeCssSelectorNth;\n\nvar _cssEscape = require(\"../third_party/css-escape/css-escape\");\n\nvar _log = require(\"./log\");\n\n/**\n * Copyright 2019 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Asserts that name is just an alphanumeric word, and does not contain\n * advanced CSS selector features like attributes, psuedo-classes, class names,\n * nor ids.\n * @param {string} name\n */\nfunction assertIsName(name) {\n  (0, _log.devAssert)(/^[\\w-]+$/.test(name));\n}\n/**\n * @type {boolean|undefined}\n */\n\n\nvar scopeSelectorSupported;\n/**\n * @param {boolean|undefined} val\n * @visibleForTesting\n */\n\nfunction setScopeSelectorSupportedForTesting(val) {\n  scopeSelectorSupported = val;\n}\n/**\n * Test that the :scope selector is supported and behaves correctly.\n * @param {!Element} el\n * @return {boolean}\n */\n\n\nfunction isScopeSelectorSupported(el) {\n  if (scopeSelectorSupported !== undefined) {\n    return scopeSelectorSupported;\n  }\n\n  return scopeSelectorSupported = testScopeSelector(el);\n}\n/**\n * Test that the :scope selector is supported and behaves correctly.\n * @param {!Element} el\n * @return {boolean}\n */\n\n\nfunction testScopeSelector(el) {\n  try {\n    var doc = el.ownerDocument;\n    var testElement = doc.createElement('div');\n    var testChild = doc.createElement('div');\n    testElement.appendChild(testChild); // NOTE(cvializ, #12383): Firefox's implementation is incomplete,\n    // therefore we test actual functionality of`:scope` as well.\n\n    return testElement.\n    /*OK*/\n    querySelector(':scope div') === testChild;\n  } catch (e) {\n    return false;\n  }\n}\n/**\n * Prefixes a selector for ancestor selection. Splits in subselectors and\n * applies prefix to each.\n *\n * e.g.\n * ```\n *   prependSelectorsWith('div', '.i-amphtml-scoped');\n *   // => '.i-amphtml-scoped div'\n *   prependSelectorsWith('div, ul', ':scope');\n *   // => ':scope div, :scope ul'\n *   prependSelectorsWith('div, ul', 'article >');\n *   // => 'article > div, article > ul'\n * ```\n *\n * @param {string} selector\n * @param {string} distribute\n * @return {string}\n */\n\n\nfunction prependSelectorsWith(selector, distribute) {\n  return selector.replace(/^|,/g, \"$&\" + distribute + \" \");\n}\n/**\n * Escapes an ident (ID or a class name) to be used as a CSS selector.\n *\n * See https://drafts.csswg.org/cssom/#serialize-an-identifier.\n *\n * @param {string} ident\n * @return {string}\n */\n\n\nfunction escapeCssSelectorIdent(ident) {\n  return (0, _cssEscape.cssEscape)(ident);\n}\n/**\n * Escapes an ident in a way that can be used by :nth-child() psuedo-class.\n *\n * See https://github.com/w3c/csswg-drafts/issues/2306.\n *\n * @param {string|number} ident\n * @return {string}\n */\n\n\nfunction escapeCssSelectorNth(ident) {\n  var escaped = String(ident); // Ensure it doesn't close the nth-child psuedo class.\n\n  (0, _log.devAssert)(escaped.indexOf(')') === -1);\n  return escaped;\n}\n\n},{\"../third_party/css-escape/css-escape\":24,\"./log\":8}],5:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.waitForChild = waitForChild;\nexports.waitForChildPromise = waitForChildPromise;\nexports.waitForBodyOpen = waitForBodyOpen;\nexports.waitForBodyOpenPromise = waitForBodyOpenPromise;\nexports.removeElement = removeElement;\nexports.removeChildren = removeChildren;\nexports.copyChildren = copyChildren;\nexports.insertAfterOrAtStart = insertAfterOrAtStart;\nexports.addAttributesToElement = addAttributesToElement;\nexports.createElementWithAttributes = createElementWithAttributes;\nexports.isConnectedNode = isConnectedNode;\nexports.rootNodeFor = rootNodeFor;\nexports.isShadowRoot = isShadowRoot;\nexports.closest = closest;\nexports.closestNode = closestNode;\nexports.closestAncestorElementBySelector = closestAncestorElementBySelector;\nexports.ancestorElements = ancestorElements;\nexports.ancestorElementsByTag = ancestorElementsByTag;\nexports.childElement = childElement;\nexports.childElements = childElements;\nexports.lastChildElement = lastChildElement;\nexports.childNodes = childNodes;\nexports.childElementByAttr = childElementByAttr;\nexports.lastChildElementByAttr = lastChildElementByAttr;\nexports.childElementsByAttr = childElementsByAttr;\nexports.childElementByTag = childElementByTag;\nexports.childElementsByTag = childElementsByTag;\nexports.matches = matches;\nexports.elementByTag = elementByTag;\nexports.scopedQuerySelector = scopedQuerySelector;\nexports.scopedQuerySelectorAll = scopedQuerySelectorAll;\nexports.getDataParamsFromAttributes = getDataParamsFromAttributes;\nexports.hasNextNodeInDocumentOrder = hasNextNodeInDocumentOrder;\nexports.templateContentClone = templateContentClone;\nexports.iterateCursor = iterateCursor;\nexports.openWindowDialog = openWindowDialog;\nexports.isJsonScriptTag = isJsonScriptTag;\nexports.isJsonLdScriptTag = isJsonLdScriptTag;\nexports.isRTL = isRTL;\nexports.escapeHtml = escapeHtml;\nexports.tryFocus = tryFocus;\nexports.isIframed = isIframed;\nexports.isAmpElement = isAmpElement;\nexports.whenUpgradedToCustomElement = whenUpgradedToCustomElement;\nexports.fullscreenEnter = fullscreenEnter;\nexports.fullscreenExit = fullscreenExit;\nexports.isFullscreenElement = isFullscreenElement;\nexports.isEnabled = isEnabled;\nexports.domOrderComparator = domOrderComparator;\nexports.toggleAttribute = toggleAttribute;\nexports.getVerticalScrollbarWidth = getVerticalScrollbarWidth;\nexports.UPGRADE_TO_CUSTOMELEMENT_RESOLVER = exports.UPGRADE_TO_CUSTOMELEMENT_PROMISE = void 0;\n\nvar _promise = require(\"./utils/promise\");\n\nvar _css = require(\"./css\");\n\nvar _log = require(\"./log\");\n\nvar _object = require(\"./utils/object\");\n\nvar _string = require(\"./string\");\n\nvar _types = require(\"./types\");\n\n/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar HTML_ESCAPE_CHARS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '`': '&#x60;'\n};\nvar HTML_ESCAPE_REGEX = /(&|<|>|\"|'|`)/g;\n/** @const {string} */\n\nvar UPGRADE_TO_CUSTOMELEMENT_PROMISE = '__AMP_UPG_PRM';\n/** @const {string} */\n\nexports.UPGRADE_TO_CUSTOMELEMENT_PROMISE = UPGRADE_TO_CUSTOMELEMENT_PROMISE;\nvar UPGRADE_TO_CUSTOMELEMENT_RESOLVER = '__AMP_UPG_RES';\n/**\n * Waits until the child element is constructed. Once the child is found, the\n * callback is executed.\n * @param {!Element} parent\n * @param {function(!Element):boolean} checkFunc\n * @param {function()} callback\n */\n\nexports.UPGRADE_TO_CUSTOMELEMENT_RESOLVER = UPGRADE_TO_CUSTOMELEMENT_RESOLVER;\n\nfunction waitForChild(parent, checkFunc, callback) {\n  if (checkFunc(parent)) {\n    callback();\n    return;\n  }\n  /** @const {!Window} */\n\n\n  var win = (0, _types.toWin)(parent.ownerDocument.defaultView);\n\n  if (win.MutationObserver) {\n    /** @const {MutationObserver} */\n    var observer = new win.MutationObserver(function () {\n      if (checkFunc(parent)) {\n        observer.disconnect();\n        callback();\n      }\n    });\n    observer.observe(parent, {\n      childList: true\n    });\n  } else {\n    /** @const {number} */\n    var interval = win.setInterval(function () {\n      if (checkFunc(parent)) {\n        win.clearInterval(interval);\n        callback();\n      }\n    },\n    /* milliseconds */\n    5);\n  }\n}\n/**\n * Waits until the child element is constructed. Once the child is found, the\n * promise is resolved.\n * @param {!Element} parent\n * @param {function(!Element):boolean} checkFunc\n * @return {!Promise}\n */\n\n\nfunction waitForChildPromise(parent, checkFunc) {\n  return new Promise(function (resolve) {\n    waitForChild(parent, checkFunc, resolve);\n  });\n}\n/**\n * Waits for document's body to be available and ready.\n * @param {!Document} doc\n * @param {function()} callback\n */\n\n\nfunction waitForBodyOpen(doc, callback) {\n  waitForChild(doc.documentElement, function () {\n    return !!doc.body;\n  }, callback);\n}\n/**\n * Waits for document's body to be available.\n * @param {!Document} doc\n * @return {!Promise}\n */\n\n\nfunction waitForBodyOpenPromise(doc) {\n  return new Promise(function (resolve) {\n    return waitForBodyOpen(doc, resolve);\n  });\n}\n/**\n * Removes the element.\n * @param {!Element} element\n */\n\n\nfunction removeElement(element) {\n  if (element.parentElement) {\n    element.parentElement.removeChild(element);\n  }\n}\n/**\n * Removes all child nodes of the specified element.\n * @param {!Element} parent\n */\n\n\nfunction removeChildren(parent) {\n  while (parent.firstChild) {\n    parent.removeChild(parent.firstChild);\n  }\n}\n/**\n * Copies all children nodes of element \"from\" to element \"to\". Child nodes\n * are deeply cloned. Notice, that this method should be used with care and\n * preferably on smaller subtrees.\n * @param {!Element} from\n * @param {!Element|!DocumentFragment} to\n */\n\n\nfunction copyChildren(from, to) {\n  var frag = to.ownerDocument.createDocumentFragment();\n\n  for (var n = from.firstChild; n; n = n.nextSibling) {\n    frag.appendChild(n.cloneNode(true));\n  }\n\n  to.appendChild(frag);\n}\n/**\n * Insert the element in the root after the element named after or\n * if that is null at the beginning.\n * @param {!Element|!ShadowRoot} root\n * @param {!Element} element\n * @param {?Node} after\n */\n\n\nfunction insertAfterOrAtStart(root, element, after) {\n  var before = after ? after.nextSibling : root.firstChild;\n  root.insertBefore(element, before);\n}\n/**\n * Add attributes to an element.\n * @param {!Element} element\n * @param {!JsonObject<string, string>} attributes\n * @return {!Element} created element\n */\n\n\nfunction addAttributesToElement(element, attributes) {\n  for (var attr in attributes) {\n    element.setAttribute(attr, attributes[attr]);\n  }\n\n  return element;\n}\n/**\n * Create a new element on document with specified tagName and attributes.\n * @param {!Document} doc\n * @param {string} tagName\n * @param {!JsonObject<string, string>} attributes\n * @return {!Element} created element\n */\n\n\nfunction createElementWithAttributes(doc, tagName, attributes) {\n  var element = doc.createElement(tagName);\n  return addAttributesToElement(element, attributes);\n}\n/**\n * Returns true if node is connected (attached).\n * @param {!Node} node\n * @return {boolean}\n * @see https://dom.spec.whatwg.org/#connected\n */\n\n\nfunction isConnectedNode(node) {\n  var connected = node.isConnected;\n\n  if (connected !== undefined) {\n    return connected;\n  } // \"An element is connected if its shadow-including root is a document.\"\n\n\n  var n = node;\n\n  do {\n    n = rootNodeFor(n);\n\n    if (n.host) {\n      n = n.host;\n    } else {\n      break;\n    }\n  } while (true);\n\n  return n.nodeType === Node.DOCUMENT_NODE;\n}\n/**\n * Returns the root for a given node. Does not cross shadow DOM boundary.\n * @param {!Node} node\n * @return {!Node}\n */\n\n\nfunction rootNodeFor(node) {\n  if (Node.prototype.getRootNode) {\n    // Type checker says `getRootNode` may return null.\n    return node.getRootNode() || node;\n  }\n\n  var n; // Check isShadowRoot() is only needed for the polyfill case.\n\n  for (n = node; !!n.parentNode && !isShadowRoot(n); n = n.parentNode) {}\n\n  return n;\n}\n/**\n * Determines if value is actually a `ShadowRoot` node.\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isShadowRoot(value) {\n  // TODO(#22733): remove in preference to dom's `rootNodeFor`.\n  if (!value) {\n    return false;\n  } // Node.nodeType == DOCUMENT_FRAGMENT to speed up the tests. Unfortunately,\n  // nodeType of DOCUMENT_FRAGMENT is used currently for ShadowRoot nodes.\n\n\n  if (value.tagName == 'I-AMPHTML-SHADOW-ROOT') {\n    return true;\n  }\n\n  return value.nodeType ==\n  /* DOCUMENT_FRAGMENT */\n  11 && Object.prototype.toString.call(value) === '[object ShadowRoot]';\n}\n/**\n * Finds the closest element that satisfies the callback from this element\n * up the DOM subtree.\n * @param {!Element} element\n * @param {function(!Element):boolean} callback\n * @param {Element=} opt_stopAt optional elemnt to stop the search at.\n * @return {?Element}\n */\n\n\nfunction closest(element, callback, opt_stopAt) {\n  for (var el = element; el && el !== opt_stopAt; el = el.parentElement) {\n    if (callback(el)) {\n      return el;\n    }\n  }\n\n  return null;\n}\n/**\n * Finds the closest node that satisfies the callback from this node\n * up the DOM subtree.\n * @param {!Node} node\n * @param {function(!Node):boolean} callback\n * @return {?Node}\n */\n\n\nfunction closestNode(node, callback) {\n  for (var n = node; n; n = n.parentNode) {\n    if (callback(n)) {\n      return n;\n    }\n  }\n\n  return null;\n}\n/**\n * Finds the closest ancestor element with the specified selector from this\n * element.\n * @param {!Element} element\n * @param {string} selector\n * @return {?Element} closest ancestor if found.\n */\n\n\nfunction closestAncestorElementBySelector(element, selector) {\n  if (element.closest) {\n    return element.closest(selector);\n  }\n\n  return closest(element, function (el) {\n    return matches(el, selector);\n  });\n}\n/**\n * Finds all ancestor elements that satisfy predicate.\n * @param {!Element} child\n * @param {function(!Element):boolean} predicate\n * @return {!Array<!Element>}\n */\n\n\nfunction ancestorElements(child, predicate) {\n  var ancestors = [];\n\n  for (var ancestor = child.parentElement; ancestor; ancestor = ancestor.parentElement) {\n    if (predicate(ancestor)) {\n      ancestors.push(ancestor);\n    }\n  }\n\n  return ancestors;\n}\n/**\n * Finds all ancestor elements that has the specified tag name.\n * @param {!Element} child\n * @param {string} tagName\n * @return {!Array<!Element>}\n */\n\n\nfunction ancestorElementsByTag(child, tagName) {\n  (0, _css.assertIsName)(tagName);\n  tagName = tagName.toUpperCase();\n  return ancestorElements(child, function (el) {\n    return el.tagName == tagName;\n  });\n}\n/**\n * Finds the first child element that satisfies the callback.\n * @param {!Element} parent\n * @param {function(!Element):boolean} callback\n * @return {?Element}\n */\n\n\nfunction childElement(parent, callback) {\n  for (var child = parent.firstElementChild; child; child = child.nextElementSibling) {\n    if (callback(child)) {\n      return child;\n    }\n  }\n\n  return null;\n}\n/**\n * Finds all child elements that satisfy the callback.\n * @param {!Element} parent\n * @param {function(!Element):boolean} callback\n * @return {!Array<!Element>}\n */\n\n\nfunction childElements(parent, callback) {\n  var children = [];\n\n  for (var child = parent.firstElementChild; child; child = child.nextElementSibling) {\n    if (callback(child)) {\n      children.push(child);\n    }\n  }\n\n  return children;\n}\n/**\n * Finds the last child element that satisfies the callback.\n * @param {!Element} parent\n * @param {function(!Element):boolean} callback\n * @return {?Element}\n */\n\n\nfunction lastChildElement(parent, callback) {\n  for (var child = parent.lastElementChild; child; child = child.previousElementSibling) {\n    if (callback(child)) {\n      return child;\n    }\n  }\n\n  return null;\n}\n/**\n * Finds all child nodes that satisfy the callback.\n * These nodes can include Text, Comment and other child nodes.\n * @param {!Node} parent\n * @param {function(!Node):boolean} callback\n * @return {!Array<!Node>}\n */\n\n\nfunction childNodes(parent, callback) {\n  var nodes = [];\n\n  for (var child = parent.firstChild; child; child = child.nextSibling) {\n    if (callback(child)) {\n      nodes.push(child);\n    }\n  }\n\n  return nodes;\n}\n/**\n * Finds the first child element that has the specified attribute.\n * @param {!Element} parent\n * @param {string} attr\n * @return {?Element}\n */\n\n\nfunction childElementByAttr(parent, attr) {\n  (0, _css.assertIsName)(attr);\n  return (\n    /*OK*/\n    scopedQuerySelector(parent, \"> [\" + attr + \"]\")\n  );\n}\n/**\n * Finds the last child element that has the specified attribute.\n * @param {!Element} parent\n * @param {string} attr\n * @return {?Element}\n */\n\n\nfunction lastChildElementByAttr(parent, attr) {\n  (0, _css.assertIsName)(attr);\n  return lastChildElement(parent, function (el) {\n    return el.hasAttribute(attr);\n  });\n}\n/**\n * Finds all child elements that has the specified attribute.\n * @param {!Element} parent\n * @param {string} attr\n * @return {!NodeList<!Element>}\n */\n\n\nfunction childElementsByAttr(parent, attr) {\n  (0, _css.assertIsName)(attr);\n  return (\n    /*OK*/\n    scopedQuerySelectorAll(parent, \"> [\" + attr + \"]\")\n  );\n}\n/**\n * Finds the first child element that has the specified tag name.\n * @param {!Element} parent\n * @param {string} tagName\n * @return {?Element}\n */\n\n\nfunction childElementByTag(parent, tagName) {\n  (0, _css.assertIsName)(tagName);\n  return (\n    /*OK*/\n    scopedQuerySelector(parent, \"> \" + tagName)\n  );\n}\n/**\n * Finds all child elements with the specified tag name.\n * @param {!Element} parent\n * @param {string} tagName\n * @return {!NodeList<!Element>}\n */\n\n\nfunction childElementsByTag(parent, tagName) {\n  (0, _css.assertIsName)(tagName);\n  return (\n    /*OK*/\n    scopedQuerySelectorAll(parent, \"> \" + tagName)\n  );\n}\n/**\n * Checks if the given element matches the selector\n * @param  {!Element} el The element to verify\n * @param  {string} selector The selector to check against\n * @return {boolean} True if the element matched the selector. False otherwise.\n */\n\n\nfunction matches(el, selector) {\n  var matcher = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector || el.oMatchesSelector;\n\n  if (matcher) {\n    return matcher.call(el, selector);\n  }\n\n  return false; // IE8 always returns false.\n}\n/**\n * Finds the first descendant element with the specified name.\n * @param {!Element|!Document|!ShadowRoot} element\n * @param {string} tagName\n * @return {?Element}\n */\n\n\nfunction elementByTag(element, tagName) {\n  (0, _css.assertIsName)(tagName);\n  return element.\n  /*OK*/\n  querySelector(tagName);\n}\n/**\n * Finds all elements that matche `selector`, scoped inside `root`\n * for user-agents that do not support native scoping.\n *\n * This method isn't required for modern builds, can be removed.\n *\n * @param {!Element} root\n * @param {string} selector\n * @return {!NodeList<!Element>}\n */\n\n\nfunction scopedQuerySelectionFallback(root, selector) {\n  var unique = 'i-amphtml-scoped';\n  root.classList.add(unique);\n  var scopedSelector = (0, _css.prependSelectorsWith)(selector, \".\" + unique);\n  var elements = root.\n  /*OK*/\n  querySelectorAll(scopedSelector);\n  root.classList.remove(unique);\n  return elements;\n}\n/**\n * Finds the first element that matches `selector`, scoped inside `root`.\n * Note: in IE, this causes a quick mutation of the element's class list.\n * @param {!Element} root\n * @param {string} selector\n * @return {?Element}\n */\n\n\nfunction scopedQuerySelector(root, selector) {\n  if ((0, _css.isScopeSelectorSupported)(root)) {\n    return root.\n    /*OK*/\n    querySelector((0, _css.prependSelectorsWith)(selector, ':scope'));\n  } // Only IE.\n\n\n  var fallbackResult = scopedQuerySelectionFallback(root, selector);\n  return fallbackResult[0] === undefined ? null : fallbackResult[0];\n}\n/**\n * Finds every element that matches `selector`, scoped inside `root`.\n * Note: in IE, this causes a quick mutation of the element's class list.\n * @param {!Element} root\n * @param {string} selector\n * @return {!NodeList<!Element>}\n */\n\n\nfunction scopedQuerySelectorAll(root, selector) {\n  if ((0, _css.isScopeSelectorSupported)(root)) {\n    return root.\n    /*OK*/\n    querySelectorAll((0, _css.prependSelectorsWith)(selector, ':scope'));\n  } // Only IE.\n\n\n  return scopedQuerySelectionFallback(root, selector);\n}\n/**\n * Returns element data-param- attributes as url parameters key-value pairs.\n * e.g. data-param-some-attr=value -> {someAttr: value}.\n * @param {!Element} element\n * @param {function(string):string=} opt_computeParamNameFunc to compute the\n *    parameter name, get passed the camel-case parameter name.\n * @param {!RegExp=} opt_paramPattern Regex pattern to match data attributes.\n * @return {!JsonObject}\n */\n\n\nfunction getDataParamsFromAttributes(element, opt_computeParamNameFunc, opt_paramPattern) {\n  var computeParamNameFunc = opt_computeParamNameFunc || function (key) {\n    return key;\n  };\n\n  var dataset = element.dataset;\n  var params = (0, _object.dict)();\n  var paramPattern = opt_paramPattern ? opt_paramPattern : /^param(.+)/;\n\n  for (var key in dataset) {\n    var _matches = key.match(paramPattern);\n\n    if (_matches) {\n      var param = _matches[1][0].toLowerCase() + _matches[1].substr(1);\n\n      params[computeParamNameFunc(param)] = dataset[key];\n    }\n  }\n\n  return params;\n}\n/**\n * Whether the element have a next node in the document order.\n * This means either:\n *  a. The element itself has a nextSibling.\n *  b. Any of the element ancestors has a nextSibling.\n * @param {!Element} element\n * @param {?Node} opt_stopNode\n * @return {boolean}\n */\n\n\nfunction hasNextNodeInDocumentOrder(element, opt_stopNode) {\n  var currentElement = element;\n\n  do {\n    if (currentElement.nextSibling) {\n      return true;\n    }\n  } while ((currentElement = currentElement.parentNode) && currentElement != opt_stopNode);\n\n  return false;\n}\n/**\n * Returns a clone of the content of a template element.\n *\n * Polyfill to replace .content access for browsers that do not support\n * HTMLTemplateElements natively.\n *\n * @param {!HTMLTemplateElement|!Element} template\n * @return {!DocumentFragment}\n */\n\n\nfunction templateContentClone(template) {\n  if ('content' in template) {\n    return template.content.cloneNode(true);\n  } else {\n    var content = template.ownerDocument.createDocumentFragment();\n    copyChildren(template, content);\n    return content;\n  }\n}\n/**\n * Iterate over an array-like.\n * Test cases: https://jsbench.github.io/#f638cacc866a1b2d6e517e6cfa900d6b\n * @param {!IArrayLike<T>} iterable\n * @param {function(T, number)} cb\n * @template T\n */\n\n\nfunction iterateCursor(iterable, cb) {\n  var length = iterable.length;\n\n  for (var i = 0; i < length; i++) {\n    cb(iterable[i], i);\n  }\n}\n/**\n * This method wraps around window's open method. It first tries to execute\n * `open` call with the provided target and if it fails, it retries the call\n * with the `_top` target. This is necessary given that in some embedding\n * scenarios, such as iOS' WKWebView, navigation to `_blank` and other targets\n * is blocked by default.\n *\n * @param {!Window} win\n * @param {string} url\n * @param {string} target\n * @param {string=} opt_features\n * @return {?Window}\n */\n\n\nfunction openWindowDialog(win, url, target, opt_features) {\n  // Try first with the specified target. If we're inside the WKWebView or\n  // a similar environments, this method is expected to fail by default for\n  // all targets except `_top`.\n  var res;\n\n  try {\n    res = win.open(url, target, opt_features);\n  } catch (e) {\n    (0, _log.dev)().error('DOM', 'Failed to open url on target: ', target, e);\n  } // Then try with `_top` target.\n\n\n  if (!res && target != '_top' && !(0, _string.includes)(opt_features || '', 'noopener')) {\n    res = win.open(url, '_top');\n  }\n\n  return res;\n}\n/**\n * Whether the element is a script tag with application/json type.\n * @param {!Element} element\n * @return {boolean}\n */\n\n\nfunction isJsonScriptTag(element) {\n  return element.tagName == 'SCRIPT' && element.hasAttribute('type') && element.getAttribute('type').toUpperCase() == 'APPLICATION/JSON';\n}\n/**\n * Whether the element is a script tag with application/json type.\n * @param {!Element} element\n * @return {boolean}\n */\n\n\nfunction isJsonLdScriptTag(element) {\n  return element.tagName == 'SCRIPT' && element.getAttribute('type').toUpperCase() == 'APPLICATION/LD+JSON';\n}\n/**\n * Whether the page's direction is right to left or not.\n * @param {!Document} doc\n * @return {boolean}\n */\n\n\nfunction isRTL(doc) {\n  var dir = doc.body.getAttribute('dir') || doc.documentElement.getAttribute('dir') || 'ltr';\n  return dir == 'rtl';\n}\n/**\n * Escapes `<`, `>` and other HTML charcaters with their escaped forms.\n * @param {string} text\n * @return {string}\n */\n\n\nfunction escapeHtml(text) {\n  if (!text) {\n    return text;\n  }\n\n  return text.replace(HTML_ESCAPE_REGEX, escapeHtmlChar);\n}\n/**\n * @param {string} c\n * @return {string}\n */\n\n\nfunction escapeHtmlChar(c) {\n  return HTML_ESCAPE_CHARS[c];\n}\n/**\n * Tries to focus on the given element; fails silently if browser throws an\n * exception.\n * @param {!Element} element\n */\n\n\nfunction tryFocus(element) {\n  try {\n    element.\n    /*OK*/\n    focus();\n  } catch (e) {// IE <= 7 may throw exceptions when focusing on hidden items.\n  }\n}\n/**\n * Whether the given window is in an iframe or not.\n * @param {!Window} win\n * @return {boolean}\n */\n\n\nfunction isIframed(win) {\n  return win.parent && win.parent != win;\n}\n/**\n * Determines if this element is an AMP element\n * @param {!Element} element\n * @return {boolean}\n */\n\n\nfunction isAmpElement(element) {\n  var tag = element.tagName; // Use prefix to recognize AMP element. This is necessary because stub\n  // may not be attached yet.\n\n  return (0, _string.startsWith)(tag, 'AMP-') && // Some \"amp-*\" elements are not really AMP elements. :smh:\n  !(tag == 'AMP-STICKY-AD-TOP-PADDING' || tag == 'AMP-BODY');\n}\n/**\n * Return a promise that resolve when an AMP element upgrade from HTMLElement\n * to CustomElement\n * @param {!Element} element\n * @return {!Promise<!Element>}\n */\n\n\nfunction whenUpgradedToCustomElement(element) {\n  (0, _log.devAssert)(isAmpElement(element), 'element is not AmpElement');\n\n  if (element.createdCallback) {\n    // Element already is CustomElement;\n    return Promise.resolve(element);\n  } // If Element is still HTMLElement, wait for it to upgrade to customElement\n  // Note: use pure string to avoid obfuscation between versions.\n\n\n  if (!element[UPGRADE_TO_CUSTOMELEMENT_PROMISE]) {\n    var deferred = new _promise.Deferred();\n    element[UPGRADE_TO_CUSTOMELEMENT_PROMISE] = deferred.promise;\n    element[UPGRADE_TO_CUSTOMELEMENT_RESOLVER] = deferred.resolve;\n  }\n\n  return element[UPGRADE_TO_CUSTOMELEMENT_PROMISE];\n}\n/**\n * Replacement for `Element.requestFullscreen()` method.\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullscreen\n * @param {!Element} element\n */\n\n\nfunction fullscreenEnter(element) {\n  var requestFs = element.requestFullscreen || element.requestFullScreen || element.webkitRequestFullscreen || element.webkitEnterFullscreen || element.msRequestFullscreen || element.mozRequestFullScreen;\n\n  if (requestFs) {\n    requestFs.call(element);\n  }\n}\n/**\n * Replacement for `Document.exitFullscreen()` method.\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/exitFullscreen\n * @param {!Element} element\n */\n\n\nfunction fullscreenExit(element) {\n  var elementBoundExit = element.cancelFullScreen || element.exitFullscreen || element.webkitExitFullscreen || element.webkitCancelFullScreen || element.mozCancelFullScreen || element.msExitFullscreen;\n\n  if (elementBoundExit) {\n    elementBoundExit.call(element);\n    return;\n  }\n\n  var ownerDocument = element.ownerDocument;\n\n  if (!ownerDocument) {\n    return;\n  }\n\n  var docBoundExit = ownerDocument.cancelFullScreen || ownerDocument.exitFullscreencancelFullScreen || ownerDocument.webkitExitFullscreencancelFullScreen || ownerDocument.webkitCancelFullScreencancelFullScreen || ownerDocument.mozCancelFullScreencancelFullScreen || ownerDocument.msExitFullscreen;\n\n  if (docBoundExit) {\n    docBoundExit.call(ownerDocument);\n  }\n}\n/**\n * Replacement for `Document.fullscreenElement`.\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/fullscreenElement\n * @param {!Element} element\n * @return {boolean}\n */\n\n\nfunction isFullscreenElement(element) {\n  var webkitDisplayingFullscreen = element.webkitDisplayingFullscreen;\n\n  if (webkitDisplayingFullscreen !== undefined) {\n    return webkitDisplayingFullscreen;\n  }\n\n  var ownerDocument = element.ownerDocument;\n\n  if (!ownerDocument) {\n    return false;\n  }\n\n  var fullscreenElement = ownerDocument.fullscreenElement || ownerDocument.webkitFullscreenElement || ownerDocument.mozFullScreenElement || ownerDocument.webkitCurrentFullScreenElement;\n  return fullscreenElement == element;\n}\n/**\n * Returns true if node is not disabled.\n *\n * IE8 can return false positives, see {@link matches}.\n * @param {!Element} element\n * @return {boolean}\n * @see https://www.w3.org/TR/html5/forms.html#concept-fe-disabled\n */\n\n\nfunction isEnabled(element) {\n  return !(element.disabled || matches(element, ':disabled'));\n}\n/**\n * A sorting comparator that sorts elements in DOM tree order.\n * A first sibling is sorted to be before its nextSibling.\n * A parent node is sorted to be before a child.\n * See https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {!Element} element1\n * @param {!Element} element2\n * @return {number}\n */\n\n\nfunction domOrderComparator(element1, element2) {\n  if (element1 === element2) {\n    return 0;\n  }\n\n  var pos = element1.compareDocumentPosition(element2);\n  var precedingOrContains = Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINS; // if fe2 is preceding or contains fe1 then, fe1 is after fe2\n\n  if (pos & precedingOrContains) {\n    return 1;\n  } // if fe2 is following or contained by fe1, then fe1 is before fe2\n\n\n  return -1;\n}\n/**\n * Like `Element.prototype.toggleAttribute`. This either toggles an attribute\n * on by adding an attribute with an empty value, or toggles it off by removing\n * the attribute. This does not mutate the element if the new state matches\n * the existing state.\n * @param {!Element} element An element to toggle the attribute for.\n * @param {string} name The name of the attribute.\n * @param {boolean=} forced Whether the attribute should be forced on/off. If\n *    not specified, it will be toggled from the current state.\n * @return {boolean} Whether or not the element now has the attribute.\n */\n\n\nfunction toggleAttribute(element, name, forced) {\n  var hasAttribute = element.hasAttribute(name);\n  var enabled = forced !== undefined ? forced : !hasAttribute;\n\n  if (enabled !== hasAttribute) {\n    if (enabled) {\n      element.setAttribute(name, '');\n    } else {\n      element.removeAttribute(name);\n    }\n  }\n\n  return enabled;\n}\n/**\n * @param {!Window} win\n * @return {number} The width of the vertical scrollbar, in pixels.\n */\n\n\nfunction getVerticalScrollbarWidth(win) {\n  var documentElement = win.document.documentElement;\n  var windowWidth = win.\n  /*OK*/\n  innerWidth;\n  var documentWidth = documentElement.\n  /*OK*/\n  clientWidth;\n  return windowWidth - documentWidth;\n}\n\n},{\"./css\":4,\"./log\":8,\"./string\":14,\"./types\":15,\"./utils/object\":22,\"./utils/promise\":23}],6:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.isAmp4Email = isAmp4Email;\nexports.isAmphtml = isAmphtml;\n\n/**\n * Copyright 2019 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Checks that the document is of an AMP format type.\n * @param {!Array<string>} formats\n * @param {!Document} doc\n * @return {boolean}\n */\nfunction isAmpFormatType(formats, doc) {\n  var html = doc.documentElement;\n  var isFormatType = formats.some(function (format) {\n    return html.hasAttribute(format);\n  });\n  return isFormatType;\n}\n/**\n * @param {!Document} doc\n * @return {boolean}\n */\n\n\nfunction isAmp4Email(doc) {\n  return isAmpFormatType(['⚡4email', 'amp4email'], doc);\n}\n/**\n * @param {!Document} doc\n * @return {boolean}\n */\n\n\nfunction isAmphtml(doc) {\n  return isAmpFormatType(['⚡', 'amp'], doc);\n}\n\n},{}],7:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.internalRuntimeVersion = internalRuntimeVersion;\n\n/**\n * Copyright 2019 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Returns the internal AMP runtime version. Note that this is not the RTV,\n * which is a prefix and the runtime version.\n *\n * The call sites for this function are replaced with a compile time constant\n * string.\n *\n * @return {string}\n */\nfunction internalRuntimeVersion() {\n  return '$internalRuntimeVersion$';\n}\n\n},{}],8:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.isUserErrorMessage = isUserErrorMessage;\nexports.isUserErrorEmbed = isUserErrorEmbed;\nexports.setReportError = setReportError;\nexports.overrideLogLevel = overrideLogLevel;\nexports.duplicateErrorIfNecessary = duplicateErrorIfNecessary;\nexports.createErrorVargs = createErrorVargs;\nexports.rethrowAsync = rethrowAsync;\nexports.initLogConstructor = initLogConstructor;\nexports.resetLogConstructorForTesting = resetLogConstructorForTesting;\nexports.user = user;\nexports.dev = dev;\nexports.isFromEmbed = isFromEmbed;\nexports.devAssert = devAssert;\nexports.userAssert = userAssert;\nexports.Log = exports.LogLevel = exports.USER_ERROR_EMBED_SENTINEL = exports.USER_ERROR_SENTINEL = void 0;\n\nvar _mode = require(\"./mode\");\n\nvar _modeObject = require(\"./mode-object\");\n\nvar _internalVersion = require(\"./internal-version\");\n\nvar _types = require(\"./types\");\n\nvar _function = require(\"./utils/function\");\n\nvar _config = require(\"./config\");\n\n/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar noop = function noop() {};\n/**\n * Triple zero width space.\n *\n * This is added to user error messages, so that we can later identify\n * them, when the only thing that we have is the message. This is the\n * case in many browsers when the global exception handler is invoked.\n *\n * @const {string}\n */\n\n\nvar USER_ERROR_SENTINEL = \"\\u200B\\u200B\\u200B\";\n/**\n * Four zero width space.\n *\n * @const {string}\n */\n\nexports.USER_ERROR_SENTINEL = USER_ERROR_SENTINEL;\nvar USER_ERROR_EMBED_SENTINEL = \"\\u200B\\u200B\\u200B\\u200B\";\n/**\n * @param {string} message\n * @return {boolean} Whether this message was a user error.\n */\n\nexports.USER_ERROR_EMBED_SENTINEL = USER_ERROR_EMBED_SENTINEL;\n\nfunction isUserErrorMessage(message) {\n  return message.indexOf(USER_ERROR_SENTINEL) >= 0;\n}\n/**\n * @param {string} message\n * @return {boolean} Whether this message was a a user error from an iframe embed.\n */\n\n\nfunction isUserErrorEmbed(message) {\n  return message.indexOf(USER_ERROR_EMBED_SENTINEL) >= 0;\n}\n/**\n * @enum {number}\n * @private Visible for testing only.\n */\n\n\nvar LogLevel = {\n  OFF: 0,\n  ERROR: 1,\n  WARN: 2,\n  INFO: 3,\n  FINE: 4\n};\n/**\n * Sets reportError function. Called from error.js to break cyclic\n * dependency.\n * @param {function(*, !Element=)|undefined} fn\n */\n\nexports.LogLevel = LogLevel;\n\nfunction setReportError(fn) {\n  self.__AMP_REPORT_ERROR = fn;\n}\n/**\n * @type {!LogLevel|undefined}\n * @private\n */\n\n\nvar levelOverride_ = undefined;\n/**\n * @param {!LogLevel} level\n */\n\nfunction overrideLogLevel(level) {\n  levelOverride_ = level;\n}\n/**\n * Prefixes `internalRuntimeVersion` with the `01` channel signifier (for prod.) for\n * extracted message URLs.\n * (Specific channel is irrelevant: message tables are invariant on internal version.)\n * @return {string}\n */\n\n\nvar messageUrlRtv = function messageUrlRtv() {\n  return \"01\" + (0, _internalVersion.internalRuntimeVersion)();\n};\n/**\n * Gets a URL to display a message on amp.dev.\n * @param {string} id\n * @param {!Array} interpolatedParts\n * @return {string}\n */\n\n\nvar externalMessageUrl = function externalMessageUrl(id, interpolatedParts) {\n  return interpolatedParts.reduce(function (prefix, arg) {\n    return prefix + \"&s[]=\" + messageArgToEncodedComponent(arg);\n  }, \"https://log.amp.dev/?v=\" + messageUrlRtv() + \"&id=\" + encodeURIComponent(id));\n};\n/**\n * URL to simple log messages table JSON file, which contains an Object<string, string>\n * which maps message id to full message template.\n * @return {string}\n */\n\n\nvar externalMessagesSimpleTableUrl = function externalMessagesSimpleTableUrl() {\n  return _config.urls.cdn + \"/rtv/\" + messageUrlRtv() + \"/log-messages.simple.json\";\n};\n/**\n * @param {*} arg\n * @return {string}\n */\n\n\nvar messageArgToEncodedComponent = function messageArgToEncodedComponent(arg) {\n  return encodeURIComponent(String(elementStringOrPassthru(arg)));\n};\n/**\n * Logging class. Use of sentinel string instead of a boolean to check user/dev\n * errors because errors could be rethrown by some native code as a new error,\n * and only a message would survive. Also, some browser don’t support a 5th\n * error object argument in window.onerror. List of supporting browser can be\n * found here:\n * https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html\n * @final\n * @private Visible for testing only.\n */\n\n\nvar Log =\n/*#__PURE__*/\nfunction () {\n  /**\n   * opt_suffix will be appended to error message to identify the type of the\n   * error message. We can't rely on the error object to pass along the type\n   * because some browsers do not have this param in its window.onerror API.\n   * See:\n   * https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html\n   *\n   * @param {!Window} win\n   * @param {function(!./mode.ModeDef):!LogLevel} levelFunc\n   * @param {string=} opt_suffix\n   */\n  function Log(win, levelFunc, opt_suffix) {\n    var _this = this;\n\n    if (opt_suffix === void 0) {\n      opt_suffix = '';\n    }\n\n    /**\n     * In tests we use the main test window instead of the iframe where\n     * the tests runs because only the former is relayed to the console.\n     * @const {!Window}\n     */\n    this.win = (0, _mode.getMode)().test && win.__AMP_TEST_IFRAME ? win.parent : win;\n    /** @private @const {function(!./mode.ModeDef):!LogLevel} */\n\n    this.levelFunc_ = levelFunc;\n    /** @private @const {!LogLevel} */\n\n    this.level_ = this.defaultLevel_();\n    /** @private @const {string} */\n\n    this.suffix_ = opt_suffix;\n    /** @private {?JsonObject} */\n\n    this.messages_ = null;\n    this.fetchExternalMessagesOnce_ = (0, _function.once)(function () {\n      win.fetch(externalMessagesSimpleTableUrl()).then(function (response) {\n        return response.json();\n      }, noop).then(function (opt_messages) {\n        if (opt_messages) {\n          _this.messages_ =\n          /** @type {!JsonObject} */\n          opt_messages;\n        }\n      });\n    });\n  }\n  /**\n   * @return {!LogLevel}\n   * @private\n   */\n\n\n  var _proto = Log.prototype;\n\n  _proto.getLevel_ = function getLevel_() {\n    return levelOverride_ !== undefined ? levelOverride_ : this.level_;\n  }\n  /**\n   * @return {!LogLevel}\n   * @private\n   */\n  ;\n\n  _proto.defaultLevel_ = function defaultLevel_() {\n    // No console - can't enable logging.\n    if (!this.win.console || !this.win.console.log) {\n      return LogLevel.OFF;\n    } // Logging has been explicitly disabled.\n\n\n    if ((0, _mode.getMode)().log == '0') {\n      return LogLevel.OFF;\n    } // Logging is enabled for tests directly.\n\n\n    if ((0, _mode.getMode)().test && this.win.ENABLE_LOG) {\n      return LogLevel.FINE;\n    } // LocalDev by default allows INFO level, unless overriden by `#log`.\n\n\n    if ((0, _mode.getMode)().localDev && !(0, _mode.getMode)().log) {\n      return LogLevel.INFO;\n    } // Delegate to the specific resolver.\n\n\n    return this.levelFunc_((0, _modeObject.getModeObject)());\n  }\n  /**\n   * @param {string} tag\n   * @param {string} level\n   * @param {!Array} messages\n   */\n  ;\n\n  _proto.msg_ = function msg_(tag, level, messages) {\n    if (this.getLevel_() != LogLevel.OFF) {\n      var fn = this.win.console.log;\n\n      if (level == 'ERROR') {\n        fn = this.win.console.error || fn;\n      } else if (level == 'INFO') {\n        fn = this.win.console.info || fn;\n      } else if (level == 'WARN') {\n        fn = this.win.console.warn || fn;\n      }\n\n      var args = this.maybeExpandMessageArgs_(messages); // Prefix console message with \"[tag]\".\n\n      var prefix = \"[\" + tag + \"]\";\n\n      if (typeof args[0] === 'string') {\n        // Prepend string to avoid breaking string substitutions e.g. %s.\n        args[0] = prefix + ' ' + args[0];\n      } else {\n        args.unshift(prefix);\n      }\n\n      fn.apply(this.win.console, args);\n    }\n  }\n  /**\n   * Whether the logging is enabled.\n   * @return {boolean}\n   */\n  ;\n\n  _proto.isEnabled = function isEnabled() {\n    return this.getLevel_() != LogLevel.OFF;\n  }\n  /**\n   * Reports a fine-grained message.\n   * @param {string} tag\n   * @param {...*} var_args\n   */\n  ;\n\n  _proto.fine = function fine(tag, var_args) {\n    if (this.getLevel_() >= LogLevel.FINE) {\n      this.msg_(tag, 'FINE', Array.prototype.slice.call(arguments, 1));\n    }\n  }\n  /**\n   * Reports a informational message.\n   * @param {string} tag\n   * @param {...*} var_args\n   */\n  ;\n\n  _proto.info = function info(tag, var_args) {\n    if (this.getLevel_() >= LogLevel.INFO) {\n      this.msg_(tag, 'INFO', Array.prototype.slice.call(arguments, 1));\n    }\n  }\n  /**\n   * Reports a warning message.\n   * @param {string} tag\n   * @param {...*} var_args\n   */\n  ;\n\n  _proto.warn = function warn(tag, var_args) {\n    if (this.getLevel_() >= LogLevel.WARN) {\n      this.msg_(tag, 'WARN', Array.prototype.slice.call(arguments, 1));\n    }\n  }\n  /**\n   * Reports an error message. If the logging is disabled, the error is rethrown\n   * asynchronously.\n   * @param {string} tag\n   * @param {...*} var_args\n   * @return {!Error|undefined}\n   * @private\n   */\n  ;\n\n  _proto.error_ = function error_(tag, var_args) {\n    if (this.getLevel_() >= LogLevel.ERROR) {\n      this.msg_(tag, 'ERROR', Array.prototype.slice.call(arguments, 1));\n    } else {\n      var error = createErrorVargs.apply(null, Array.prototype.slice.call(arguments, 1));\n      this.prepareError_(error);\n      return error;\n    }\n  }\n  /**\n   * Reports an error message.\n   * @param {string} tag\n   * @param {...*} var_args\n   */\n  ;\n\n  _proto.error = function error(tag, var_args) {\n    var error = this.error_.apply(this, arguments);\n\n    if (error) {\n      error.name = tag || error.name; // __AMP_REPORT_ERROR is installed globally per window in the entry point.\n\n      self.__AMP_REPORT_ERROR(error);\n    }\n  }\n  /**\n   * Reports an error message and marks with an expected property. If the\n   * logging is disabled, the error is rethrown asynchronously.\n   * @param {string} unusedTag\n   * @param {...*} var_args\n   */\n  ;\n\n  _proto.expectedError = function expectedError(unusedTag, var_args) {\n    var error = this.error_.apply(this, arguments);\n\n    if (error) {\n      error.expected = true; // __AMP_REPORT_ERROR is installed globally per window in the entry point.\n\n      self.__AMP_REPORT_ERROR(error);\n    }\n  }\n  /**\n   * Creates an error object.\n   * @param {...*} var_args\n   * @return {!Error}\n   */\n  ;\n\n  _proto.createError = function createError(var_args) {\n    var error = createErrorVargs.apply(null, arguments);\n    this.prepareError_(error);\n    return error;\n  }\n  /**\n   * Creates an error object with its expected property set to true.\n   * @param {...*} var_args\n   * @return {!Error}\n   */\n  ;\n\n  _proto.createExpectedError = function createExpectedError(var_args) {\n    var error = createErrorVargs.apply(null, arguments);\n    this.prepareError_(error);\n    error.expected = true;\n    return error;\n  }\n  /**\n   * Throws an error if the first argument isn't trueish.\n   *\n   * Supports argument substitution into the message via %s placeholders.\n   *\n   * Throws an error object that has two extra properties:\n   * - associatedElement: This is the first element provided in the var args.\n   *   It can be used for improved display of error messages.\n   * - messageArray: The elements of the substituted message as non-stringified\n   *   elements in an array. When e.g. passed to console.error this yields\n   *   native displays of things like HTML elements.\n   *\n   * NOTE: for an explanation of the tempate R implementation see\n   * https://github.com/google/closure-library/blob/08858804/closure/goog/asserts/asserts.js#L192-L213\n   *\n   * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n   *     not evaluate to true.\n   * @param {!Array|string=} opt_message The assertion message\n   * @param {...*} var_args Arguments substituted into %s in the message.\n   * @return {R} The value of shouldBeTrueish.\n   * @throws {!Error} When `value` is `null` or `undefined`.\n   * @template T\n   * @template R :=\n   *     mapunion(T, (V) =>\n   *         cond(eq(V, 'null'),\n   *             none(),\n   *             cond(eq(V, 'undefined'),\n   *                 none(),\n   *                 V)))\n   *  =:\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  ;\n\n  _proto.assert = function assert(shouldBeTrueish, opt_message, var_args) {\n    var firstElement;\n\n    if ((0, _types.isArray)(opt_message)) {\n      return this.assert.apply(this, [shouldBeTrueish].concat(this.expandMessageArgs_(\n      /** @type {!Array} */\n      opt_message)));\n    }\n\n    if (!shouldBeTrueish) {\n      var message = opt_message || 'Assertion failed';\n      var splitMessage = message.split('%s');\n      var first = splitMessage.shift();\n      var formatted = first;\n      var messageArray = [];\n      var i = 2;\n      pushIfNonEmpty(messageArray, first);\n\n      while (splitMessage.length > 0) {\n        var nextConstant = splitMessage.shift();\n        var val = arguments[i++];\n\n        if (val && val.tagName) {\n          firstElement = val;\n        }\n\n        messageArray.push(val);\n        pushIfNonEmpty(messageArray, nextConstant.trim());\n        formatted += stringOrElementString(val) + nextConstant;\n      }\n\n      var e = new Error(formatted);\n      e.fromAssert = true;\n      e.associatedElement = firstElement;\n      e.messageArray = messageArray;\n      this.prepareError_(e); // __AMP_REPORT_ERROR is installed globally per window in the entry point.\n\n      self.__AMP_REPORT_ERROR(e);\n\n      throw e;\n    }\n\n    return shouldBeTrueish;\n  }\n  /**\n   * Throws an error if the first argument isn't an Element\n   *\n   * Otherwise see `assert` for usage\n   *\n   * @param {*} shouldBeElement\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {!Element} The value of shouldBeTrueish.\n   * @template T\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  ;\n\n  _proto.assertElement = function assertElement(shouldBeElement, opt_message) {\n    var shouldBeTrueish = shouldBeElement && shouldBeElement.nodeType == 1;\n    this.assertType_(shouldBeElement, shouldBeTrueish, 'Element expected', opt_message);\n    return (\n      /** @type {!Element} */\n      shouldBeElement\n    );\n  }\n  /**\n   * Throws an error if the first argument isn't a string. The string can\n   * be empty.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeString\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {string} The string value. Can be an empty string.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  ;\n\n  _proto.assertString = function assertString(shouldBeString, opt_message) {\n    this.assertType_(shouldBeString, typeof shouldBeString == 'string', 'String expected', opt_message);\n    return (\n      /** @type {string} */\n      shouldBeString\n    );\n  }\n  /**\n   * Throws an error if the first argument isn't a number. The allowed values\n   * include `0` and `NaN`.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeNumber\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {number} The number value. The allowed values include `0`\n   *   and `NaN`.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  ;\n\n  _proto.assertNumber = function assertNumber(shouldBeNumber, opt_message) {\n    this.assertType_(shouldBeNumber, typeof shouldBeNumber == 'number', 'Number expected', opt_message);\n    return (\n      /** @type {number} */\n      shouldBeNumber\n    );\n  }\n  /**\n   * Throws an error if the first argument is not an array.\n   * The array can be empty.\n   *\n   * @param {*} shouldBeArray\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {!Array} The array value\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  ;\n\n  _proto.assertArray = function assertArray(shouldBeArray, opt_message) {\n    this.assertType_(shouldBeArray, (0, _types.isArray)(shouldBeArray), 'Array expected', opt_message);\n    return (\n      /** @type {!Array} */\n      shouldBeArray\n    );\n  }\n  /**\n   * Throws an error if the first argument isn't a boolean.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeBoolean\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {boolean} The boolean value.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  ;\n\n  _proto.assertBoolean = function assertBoolean(shouldBeBoolean, opt_message) {\n    this.assertType_(shouldBeBoolean, !!shouldBeBoolean === shouldBeBoolean, 'Boolean expected', opt_message);\n    return (\n      /** @type {boolean} */\n      shouldBeBoolean\n    );\n  }\n  /**\n   * Asserts and returns the enum value. If the enum doesn't contain such a\n   * value, the error is thrown.\n   *\n   * @param {!Object<T>} enumObj\n   * @param {string} s\n   * @param {string=} opt_enumName\n   * @return {T}\n   * @template T\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  ;\n\n  _proto.assertEnumValue = function assertEnumValue(enumObj, s, opt_enumName) {\n    if ((0, _types.isEnumValue)(enumObj, s)) {\n      return s;\n    }\n\n    this.assert(false, 'Unknown %s value: \"%s\"', opt_enumName || 'enum', s);\n  }\n  /**\n   * @param {!Error} error\n   * @private\n   */\n  ;\n\n  _proto.prepareError_ = function prepareError_(error) {\n    error = duplicateErrorIfNecessary(error);\n\n    if (this.suffix_) {\n      if (!error.message) {\n        error.message = this.suffix_;\n      } else if (error.message.indexOf(this.suffix_) == -1) {\n        error.message += this.suffix_;\n      }\n    } else if (isUserErrorMessage(error.message)) {\n      error.message = error.message.replace(USER_ERROR_SENTINEL, '');\n    }\n  }\n  /**\n   * @param {!Array} args\n   * @return {!Array}\n   * @private\n   */\n  ;\n\n  _proto.maybeExpandMessageArgs_ = function maybeExpandMessageArgs_(args) {\n    if ((0, _types.isArray)(args[0])) {\n      return this.expandMessageArgs_(\n      /** @type {!Array} */\n      args[0]);\n    }\n\n    return args;\n  }\n  /**\n   * Either redirects a pair of (errorId, ...args) to a URL where the full\n   * message is displayed, or displays it from a fetched table.\n   *\n   * This method is used by the output of the `transform-log-methods` babel\n   * plugin. It should not be used directly. Use the (*error|assert*|info|warn)\n   * methods instead.\n   *\n   * @param {!Array} parts\n   * @return {!Array}\n   * @private\n   */\n  ;\n\n  _proto.expandMessageArgs_ = function expandMessageArgs_(parts) {\n    // First value should exist.\n    var id = parts.shift(); // Best effort fetch of message template table.\n    // Since this is async, the first few logs might be indirected to a URL even\n    // if in development mode. Message table is ~small so this should be a short\n    // gap.\n\n    if ((0, _mode.getMode)(this.win).development) {\n      this.fetchExternalMessagesOnce_();\n    }\n\n    if (this.messages_ && id in this.messages_) {\n      return [this.messages_[id]].concat(parts);\n    }\n\n    return [\"More info at \" + externalMessageUrl(id, parts)];\n  }\n  /**\n   * Asserts types, backbone of `assertNumber`, `assertString`, etc.\n   *\n   * It understands array-based \"id\"-contracted messages.\n   *\n   * Otherwise creates a sprintf syntax string containing the optional message or the\n   * default. An interpolation token is added at the end to include the `subject`.\n   * @param {*} subject\n   * @param {*} assertion\n   * @param {string} defaultMessage\n   * @param {!Array|string=} opt_message\n   * @private\n   */\n  ;\n\n  _proto.assertType_ = function assertType_(subject, assertion, defaultMessage, opt_message) {\n    if ((0, _types.isArray)(opt_message)) {\n      this.assert(assertion, opt_message.concat(subject));\n    } else {\n      this.assert(assertion, (opt_message || defaultMessage) + \": %s\", subject);\n    }\n  };\n\n  return Log;\n}();\n/**\n * @param {string|!Element} val\n * @return {string}\n */\n\n\nexports.Log = Log;\n\nvar stringOrElementString = function stringOrElementString(val) {\n  return (\n    /** @type {string} */\n    elementStringOrPassthru(val)\n  );\n};\n/**\n * @param {*} val\n * @return {*}\n */\n\n\nfunction elementStringOrPassthru(val) {\n  // Do check equivalent to `val instanceof Element` without cross-window bug\n  if (val && val.nodeType == 1) {\n    return val.tagName.toLowerCase() + (val.id ? '#' + val.id : '');\n  }\n\n  return val;\n}\n/**\n * @param {!Array} array\n * @param {*} val\n */\n\n\nfunction pushIfNonEmpty(array, val) {\n  if (val != '') {\n    array.push(val);\n  }\n}\n/**\n * Some exceptions (DOMException, namely) have read-only message.\n * @param {!Error} error\n * @return {!Error};\n */\n\n\nfunction duplicateErrorIfNecessary(error) {\n  var messageProperty = Object.getOwnPropertyDescriptor(error, 'message');\n\n  if (messageProperty && messageProperty.writable) {\n    return error;\n  }\n\n  var message = error.message,\n      stack = error.stack;\n  var e = new Error(message); // Copy all the extraneous things we attach.\n\n  for (var prop in error) {\n    e[prop] = error[prop];\n  } // Ensure these are copied.\n\n\n  e.stack = stack;\n  return e;\n}\n/**\n * @param {...*} var_args\n * @return {!Error}\n * @visibleForTesting\n */\n\n\nfunction createErrorVargs(var_args) {\n  var error = null;\n  var message = '';\n\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i];\n\n    if (arg instanceof Error && !error) {\n      error = duplicateErrorIfNecessary(arg);\n    } else {\n      if (message) {\n        message += ' ';\n      }\n\n      message += arg;\n    }\n  }\n\n  if (!error) {\n    error = new Error(message);\n  } else if (message) {\n    error.message = message + ': ' + error.message;\n  }\n\n  return error;\n}\n/**\n * Rethrows the error without terminating the current context. This preserves\n * whether the original error designation is a user error or a dev error.\n * @param {...*} var_args\n */\n\n\nfunction rethrowAsync(var_args) {\n  var error = createErrorVargs.apply(null, arguments);\n  setTimeout(function () {\n    // reportError is installed globally per window in the entry point.\n    self.__AMP_REPORT_ERROR(error);\n\n    throw error;\n  });\n}\n/**\n * Cache for logs. We do not use a Service since the service module depends\n * on Log and closure literally can't even.\n * @type {{user: ?Log, dev: ?Log, userForEmbed: ?Log}}\n */\n\n\nself.__AMP_LOG = self.__AMP_LOG || {\n  user: null,\n  dev: null,\n  userForEmbed: null\n};\nvar logs = self.__AMP_LOG;\n/**\n * Eventually holds a constructor for Log objects. Lazily initialized, so we\n * can avoid ever referencing the real constructor except in JS binaries\n * that actually want to include the implementation.\n * @type {?Function}\n */\n\nvar logConstructor = null;\n/**\n * Initializes log contructor.\n */\n\nfunction initLogConstructor() {\n  logConstructor = Log; // Initialize instances for use. If a binary (an extension for example) that\n  // does not call `initLogConstructor` invokes `dev()` or `user()` earlier than\n  // the binary that does call `initLogConstructor` (amp.js), the extension will\n  // throw an error as that extension will never be able to initialize the log\n  // instances and we also don't want it to call `initLogConstructor` either\n  // (since that will cause the Log implementation to be bundled into that\n  // binary). So we must initialize the instances eagerly so that they are ready\n  // for use (stored globally) after the main binary calls `initLogConstructor`.\n\n  dev();\n  user();\n}\n/**\n * Resets log contructor for testing.\n */\n\n\nfunction resetLogConstructorForTesting() {\n  logConstructor = null;\n}\n/**\n * Publisher level log.\n *\n * Enabled in the following conditions:\n *  1. Not disabled using `#log=0`.\n *  2. Development mode is enabled via `#development=1` or logging is explicitly\n *     enabled via `#log=D` where D >= 1.\n *  3. AMP.setLogLevel(D) is called, where D >= 1.\n *\n * @param {!Element=} opt_element\n * @return {!Log}\n */\n\n\nfunction user(opt_element) {\n  if (!logs.user) {\n    logs.user = getUserLogger(USER_ERROR_SENTINEL);\n  }\n\n  if (!isFromEmbed(logs.user.win, opt_element)) {\n    return logs.user;\n  } else {\n    if (logs.userForEmbed) {\n      return logs.userForEmbed;\n    }\n\n    return logs.userForEmbed = getUserLogger(USER_ERROR_EMBED_SENTINEL);\n  }\n}\n/**\n * Getter for user logger\n * @param {string=} suffix\n * @return {!Log}\n */\n\n\nfunction getUserLogger(suffix) {\n  if (!logConstructor) {\n    throw new Error('failed to call initLogConstructor');\n  }\n\n  return new logConstructor(self, function (mode) {\n    var logNum = parseInt(mode.log, 10);\n\n    if (mode.development || logNum >= 1) {\n      return LogLevel.FINE;\n    }\n\n    return LogLevel.WARN;\n  }, suffix);\n}\n/**\n * AMP development log. Calls to `devLog().assert` and `dev.fine` are stripped\n * in the PROD binary. However, `devLog().assert` result is preserved in either\n * case.\n *\n * Enabled in the following conditions:\n *  1. Not disabled using `#log=0`.\n *  2. Logging is explicitly enabled via `#log=D`, where D >= 2.\n *  3. AMP.setLogLevel(D) is called, where D >= 2.\n *\n * @return {!Log}\n */\n\n\nfunction dev() {\n  if (logs.dev) {\n    return logs.dev;\n  }\n\n  if (!logConstructor) {\n    throw new Error('failed to call initLogConstructor');\n  }\n\n  return logs.dev = new logConstructor(self, function (mode) {\n    var logNum = parseInt(mode.log, 10);\n\n    if (logNum >= 3) {\n      return LogLevel.FINE;\n    }\n\n    if (logNum >= 2) {\n      return LogLevel.INFO;\n    }\n\n    return LogLevel.OFF;\n  });\n}\n/**\n * @param {!Window} win\n * @param {!Element=} opt_element\n * @return {boolean} isEmbed\n */\n\n\nfunction isFromEmbed(win, opt_element) {\n  if (!opt_element) {\n    return false;\n  }\n\n  return opt_element.ownerDocument.defaultView != win;\n}\n/**\n * Throws an error if the first argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - associatedElement: This is the first element provided in the var args.\n *   It can be used for improved display of error messages.\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n *\n * NOTE: for an explanation of the tempate R implementation see\n * https://github.com/google/closure-library/blob/08858804/closure/goog/asserts/asserts.js#L192-L213\n *\n * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n *     not evaluate to true.\n * @param {!Array|string=} opt_message The assertion message\n * @param {*=} opt_1 Optional argument (Var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {R} The value of shouldBeTrueish.\n * @template T\n * @template R :=\n *     mapunion(T, (V) =>\n *         cond(eq(V, 'null'),\n *             none(),\n *             cond(eq(V, 'undefined'),\n *                 none(),\n *                 V)))\n *  =:\n * @throws {!Error} When `value` is `null` or `undefined`.\n * @closurePrimitive {asserts.matchesReturn}\n */\n\n\nfunction devAssert(shouldBeTrueish, opt_message, opt_1, opt_2, opt_3, opt_4, opt_5, opt_6, opt_7, opt_8, opt_9) {\n  if ((0, _mode.getMode)().minified) {\n    return shouldBeTrueish;\n  }\n\n  return dev().\n  /*Orig call*/\n  assert(shouldBeTrueish, opt_message, opt_1, opt_2, opt_3, opt_4, opt_5, opt_6, opt_7, opt_8, opt_9);\n}\n/**\n * Throws an error if the first argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - associatedElement: This is the first element provided in the var args.\n *   It can be used for improved display of error messages.\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n *\n * NOTE: for an explanation of the tempate R implementation see\n * https://github.com/google/closure-library/blob/08858804/closure/goog/asserts/asserts.js#L192-L213\n *\n * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n *     not evaluate to true.\n * @param {!Array|string=} opt_message The assertion message\n * @param {*=} opt_1 Optional argument (Var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {R} The value of shouldBeTrueish.\n * @template T\n * @template R :=\n *     mapunion(T, (V) =>\n *         cond(eq(V, 'null'),\n *             none(),\n *             cond(eq(V, 'undefined'),\n *                 none(),\n *                 V)))\n *  =:\n * @throws {!Error} When `value` is `null` or `undefined`.\n * @closurePrimitive {asserts.matchesReturn}\n */\n\n\nfunction userAssert(shouldBeTrueish, opt_message, opt_1, opt_2, opt_3, opt_4, opt_5, opt_6, opt_7, opt_8, opt_9) {\n  return user().\n  /*Orig call*/\n  assert(shouldBeTrueish, opt_message, opt_1, opt_2, opt_3, opt_4, opt_5, opt_6, opt_7, opt_8, opt_9);\n}\n\n},{\"./config\":3,\"./internal-version\":7,\"./mode\":10,\"./mode-object\":9,\"./types\":15,\"./utils/function\":20}],9:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.getModeObject = getModeObject;\n\nvar _mode = require(\"./mode\");\n\n/**\n * Copyright 2016 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Provides info about the current app. This return value may be cached and\n * passed around as it will always be DCE'd.\n * @param {?Window=} opt_win\n * @return {!./mode.ModeDef}\n */\nfunction getModeObject(opt_win) {\n  return {\n    localDev: (0, _mode.getMode)(opt_win).localDev,\n    development: (0, _mode.getMode)(opt_win).development,\n    filter: (0, _mode.getMode)(opt_win).filter,\n    minified: (0, _mode.getMode)(opt_win).minified,\n    lite: (0, _mode.getMode)(opt_win).lite,\n    test: (0, _mode.getMode)(opt_win).test,\n    log: (0, _mode.getMode)(opt_win).log,\n    version: (0, _mode.getMode)(opt_win).version,\n    rtvVersion: (0, _mode.getMode)(opt_win).rtvVersion,\n    singlePassType: (0, _mode.getMode)(opt_win).singlePassType\n  };\n}\n\n},{\"./mode\":10}],10:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.getMode = getMode;\nexports.getRtvVersionForTesting = getRtvVersionForTesting;\nexports.resetRtvVersionForTesting = resetRtvVersionForTesting;\nexports.ModeDef = void 0;\n\nvar _internalVersion = require(\"./internal-version\");\n\nvar _urlParseQueryString = require(\"./url-parse-query-string\");\n\n/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @typedef {{\n *   localDev: boolean,\n *   development: boolean,\n *   filter: (string|undefined),\n *   minified: boolean,\n *   lite: boolean,\n *   test: boolean,\n *   log: (string|undefined),\n *   version: string,\n *   rtvVersion: string,\n *   runtime: (null|string|undefined),\n *   a4aId: (null|string|undefined),\n *   singlePassType: (string|undefined)\n * }}\n */\nvar ModeDef;\n/**\n * `rtvVersion` is the prefixed version we serve off of the cdn.\n * The prefix denotes canary(00) or prod(01) or an experiment version ( > 01).\n * @type {string}\n */\n\nexports.ModeDef = ModeDef;\nvar rtvVersion = '';\n/**\n * Provides info about the current app.\n * @param {?Window=} opt_win\n * @return {!ModeDef}\n */\n\nfunction getMode(opt_win) {\n  var win = opt_win || self;\n\n  if (win.__AMP_MODE) {\n    return win.__AMP_MODE;\n  }\n\n  return win.__AMP_MODE = getMode_(win);\n}\n/**\n * Provides info about the current app.\n * @param {!Window} win\n * @return {!ModeDef}\n */\n\n\nfunction getMode_(win) {\n  // TODO(erwinmombay): simplify the logic here\n  var AMP_CONFIG = self.AMP_CONFIG || {}; // Magic constants that are replaced by closure compiler.\n  // IS_MINIFIED is always replaced with true when closure compiler is used\n  // while IS_DEV is only replaced when `gulp dist` is called without the\n  // --fortesting flag.\n\n  var IS_DEV = true;\n  var IS_MINIFIED = false;\n  var localDevEnabled = !!AMP_CONFIG.localDev;\n  var runningTests = !!AMP_CONFIG.test || IS_DEV && !!(win.__AMP_TEST || win.__karma__);\n  var runningTestsOnIe = win.__karma__ && win.__karma__.config.amp.testOnIe;\n  var isLocalDev = IS_DEV && (localDevEnabled || runningTests);\n  var hashQuery = (0, _urlParseQueryString.parseQueryString_)( // location.originalHash is set by the viewer when it removes the fragment\n  // from the URL.\n  win.location.originalHash || win.location.hash);\n  var singlePassType = AMP_CONFIG.spt;\n  var searchQuery = (0, _urlParseQueryString.parseQueryString_)(win.location.search);\n\n  if (!rtvVersion) {\n    rtvVersion = getRtvVersion(win, isLocalDev);\n  } // The `minified`, `test` and `localDev` properties are replaced\n  // as boolean literals when we run `gulp dist` without the `--fortesting`\n  // flags. This improved DCE on the production file we deploy as the code\n  // paths for localhost/testing/development are eliminated.\n\n\n  return {\n    localDev: isLocalDev,\n    // Triggers validation or enable pub level logging. Validation can be\n    // bypassed via #validate=0.\n    // Note that AMP_DEV_MODE flag is used for testing purposes.\n    // Use Array.indexOf instead of Array.includes because of #24219\n    development: !!(['1', 'actions', 'amp', 'amp4ads', 'amp4email'].indexOf(hashQuery['development']) >= 0 || win.AMP_DEV_MODE),\n    examiner: hashQuery['development'] == '2',\n    // Allows filtering validation errors by error category. For the\n    // available categories, see ErrorCategory in validator/validator.proto.\n    filter: hashQuery['filter'],\n    // amp-geo override\n    geoOverride: hashQuery['amp-geo'],\n    // amp-user-location override\n    userLocationOverride: hashQuery['amp-user-location'],\n    minified: IS_MINIFIED,\n    // Whether document is in an amp-lite viewer. It signal that the user\n    // would prefer to use less bandwidth.\n    lite: searchQuery['amp_lite'] != undefined,\n    test: runningTests,\n    testIe: runningTestsOnIe,\n    log: hashQuery['log'],\n    version: (0, _internalVersion.internalRuntimeVersion)(),\n    rtvVersion: rtvVersion,\n    singlePassType: singlePassType\n  };\n}\n/**\n * Retrieve the `rtvVersion` which will have a numeric prefix\n * denoting canary/prod/experiment (unless `isLocalDev` is true).\n *\n * @param {!Window} win\n * @param {boolean} isLocalDev\n * @return {string}\n */\n\n\nfunction getRtvVersion(win, isLocalDev) {\n  // If it's local dev then we won't actually have a full version so\n  // just use the version.\n  if (isLocalDev) {\n    return (0, _internalVersion.internalRuntimeVersion)();\n  }\n\n  if (win.AMP_CONFIG && win.AMP_CONFIG.v) {\n    return win.AMP_CONFIG.v;\n  } // Currently `internalRuntimeVersion` and thus `mode.version` contain only\n  // major version. The full version however must also carry the minor version.\n  // We will default to production default `01` minor version for now.\n  // TODO(erwinmombay): decide whether internalRuntimeVersion should contain\n  // minor version.\n\n\n  return \"01\" + (0, _internalVersion.internalRuntimeVersion)();\n}\n/**\n * @param {!Window} win\n * @param {boolean} isLocalDev\n * @return {string}\n * @visibleForTesting\n */\n\n\nfunction getRtvVersionForTesting(win, isLocalDev) {\n  return getRtvVersion(win, isLocalDev);\n}\n/** @visibleForTesting */\n\n\nfunction resetRtvVersionForTesting() {\n  rtvVersion = '';\n}\n\n},{\"./internal-version\":7,\"./url-parse-query-string\":16}],11:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.purifyHtml = purifyHtml;\nexports.createPurifier = createPurifier;\nexports.getAllowedTags = getAllowedTags;\nexports.validateAttributeChange = validateAttributeChange;\nexports.purifyTagsForTripleMustache = purifyTagsForTripleMustache;\nexports.DomPurifyDef = void 0;\n\nvar _sanitation = require(\"./sanitation\");\n\nvar _log = require(\"./log\");\n\nvar _format = require(\"./format\");\n\nvar _dom = require(\"./dom\");\n\nvar _urlRewrite = require(\"./url-rewrite\");\n\nvar _string = require(\"./string\");\n\nvar _purify = _interopRequireDefault(require(\"dompurify/dist/purify.es\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @typedef {{addHook: !Function, removeAllHooks: !Function, sanitize: !Function}}\n */\nvar DomPurifyDef; // TODO(choumx): Convert this into a class to avoid import side effects.\n\n/** @private @const {!DomPurifyDef} */\n\nexports.DomPurifyDef = DomPurifyDef;\nvar DomPurify = (0, _purify.default)(self);\n/** @private @const {string} */\n\nvar TAG = 'purifier';\n/**\n * Tags that are only whitelisted for specific values of given attributes.\n * @private @const {!Object<string, {attribute: string, values: !Array<string>}>}\n */\n\nvar WHITELISTED_TAGS_BY_ATTRS = {\n  'script': {\n    'attribute': 'type',\n    'values': ['application/json', 'application/ld+json']\n  }\n};\nvar PURIFY_PROFILES =\n/** @type {!DomPurifyConfig} */\n{\n  USE_PROFILES: {\n    html: true,\n    svg: true,\n    svgFilters: true\n  }\n};\n/**\n * Monotonically increasing counter used for keying nodes.\n * @private {number}\n */\n\nvar KEY_COUNTER = 1;\n/**\n * Returns a <body> element containing the sanitized `dirty` markup.\n * Uses the standard DOMPurify config.\n * @param {string} dirty\n * @param {!Document} doc\n * @return {!Node}\n */\n\nfunction purifyHtml(dirty, doc) {\n  var config = standardPurifyConfig();\n  addPurifyHooks(DomPurify, doc);\n  var body = DomPurify.sanitize(dirty, config);\n  DomPurify.removeAllHooks();\n  return body;\n}\n/**\n * Creates a new DOMPurify instance with a custom DOMPurify configuration.\n * @param {!Document} doc\n * @param {!JsonObject=} opt_config\n * @return {!DomPurifyDef}\n */\n\n\nfunction createPurifier(doc, opt_config) {\n  var domPurify = (0, _purify.default)(self);\n  var config = Object.assign(opt_config || {}, standardPurifyConfig());\n  domPurify.setConfig(config);\n  addPurifyHooks(domPurify, doc);\n  return domPurify;\n}\n/**\n * Returns standard DOMPurify config for escaped templates.\n * Do not use for unescaped templates.\n *\n * NOTE: See that we use DomPurifyConfig found in\n * build-system/dompurify.extern.js as the exact type. This is to prevent\n * closure compiler from optimizing these fields here in this file and in the\n * 3rd party library file. See #19624 for further information.\n *\n * @return {!DomPurifyConfig}\n */\n\n\nfunction standardPurifyConfig() {\n  var config = Object.assign({}, PURIFY_PROFILES,\n  /** @type {!DomPurifyConfig} */\n  {\n    ADD_ATTR: _sanitation.WHITELISTED_ATTRS,\n    // <use> is an SVG element that is not allowed by default in DOMPurify.\n    // See afterSanitizeAttributes() for special handling.\n    ADD_TAGS: ['use'],\n    FORBID_TAGS: Object.keys(_sanitation.BLACKLISTED_TAGS),\n    // Avoid reparenting of some elements to document head e.g. <script>.\n    FORCE_BODY: true,\n    // Avoid need for serializing to/from string by returning Node directly.\n    RETURN_DOM: true,\n    // Allows native app deeplinks. DOMPurify's remaining checks are\n    // sufficient to prevent code execution.\n    ALLOW_UNKNOWN_PROTOCOLS: true\n  });\n  return (\n    /** @type {!DomPurifyConfig} */\n    config\n  );\n}\n/**\n * Gets a copy of the map of allowed tag names (standard DOMPurify config).\n * @return {!Object<string, boolean>}\n */\n\n\nfunction getAllowedTags() {\n  var allowedTags = {}; // Use this hook to extract purifier's allowed tags.\n\n  DomPurify.addHook('uponSanitizeElement', function (node, data) {\n    Object.assign(allowedTags, data.allowedTags);\n  }); // Sanitize dummy markup so that the hook is invoked.\n\n  DomPurify.sanitize('<p></p>');\n  Object.keys(_sanitation.BLACKLISTED_TAGS).forEach(function (tag) {\n    allowedTags[tag] = false;\n  }); // Pops the last hook added.\n\n  DomPurify.removeHook('uponSanitizeElement');\n  return allowedTags;\n}\n/**\n * Adds AMP hooks to given DOMPurify object.\n * @param {!DomPurifyDef} purifier\n * @param {!Document} doc\n */\n\n\nfunction addPurifyHooks(purifier, doc) {\n  var isEmail = (0, _format.isAmp4Email)(doc); // Reference to DOMPurify's `allowedTags` whitelist.\n\n  var allowedTags;\n  var allowedTagsChanges = []; // Reference to DOMPurify's `allowedAttributes` whitelist.\n\n  var allowedAttributes;\n  var allowedAttributesChanges = [];\n  /**\n   * @param {!Node} node\n   * @param {{tagName: string, allowedTags: !Object<string, boolean>}} data\n   */\n\n  var uponSanitizeElement = function uponSanitizeElement(node, data) {\n    var tagName = data.tagName;\n    allowedTags = data.allowedTags; // Allow all AMP elements.\n\n    if ((0, _string.startsWith)(tagName, 'amp-')) {\n      // Enforce AMP4EMAIL tag whitelist at runtime.\n      allowedTags[tagName] = !isEmail || _sanitation.EMAIL_WHITELISTED_AMP_TAGS[tagName];\n    } // Set `target` attribute for <a> tags if necessary.\n\n\n    if (tagName === 'a') {\n      var element = (0, _log.dev)().assertElement(node);\n\n      if (element.hasAttribute('href') && !element.hasAttribute('target')) {\n        element.setAttribute('target', '_top');\n      }\n    } // Allow certain tags if they have an attribute with a whitelisted value.\n\n\n    var whitelist = WHITELISTED_TAGS_BY_ATTRS[tagName];\n\n    if (whitelist) {\n      var attribute = whitelist.attribute,\n          values = whitelist.values;\n\n      var _element = (0, _log.dev)().assertElement(node);\n\n      if (_element.hasAttribute(attribute) && values.includes(_element.getAttribute(attribute))) {\n        allowedTags[tagName] = true;\n        allowedTagsChanges.push(tagName);\n      }\n    }\n  };\n  /**\n   * @param {!Node} unusedNode\n   */\n\n\n  var afterSanitizeElements = function afterSanitizeElements(unusedNode) {\n    // DOMPurify doesn't have a attribute-specific tag whitelist API and\n    // `allowedTags` has a per-invocation scope, so we need to undo\n    // changes after sanitizing elements.\n    allowedTagsChanges.forEach(function (tag) {\n      delete allowedTags[tag];\n    });\n    allowedTagsChanges.length = 0;\n  };\n  /**\n   * @param {!Element} element\n   * @param {{attrName: string, attrValue: string, allowedAttributes: !Object<string, boolean>}} data\n   */\n\n\n  var uponSanitizeAttribute = function uponSanitizeAttribute(element, data) {\n    // Beware of DOM Clobbering when using properties or functions on `element`.\n    // DOMPurify checks a few of these for its internal usage (e.g. `nodeName`),\n    // but not others that may be used in custom hooks.\n    // See https://github.com/cure53/DOMPurify/wiki/Security-Goals-&-Threat-Model#security-goals\n    // and https://github.com/cure53/DOMPurify/blob/master/src/purify.js#L527.\n    var tagName = element.nodeName.toLowerCase();\n    var attrName = data.attrName;\n    var attrValue = data.attrValue;\n    allowedAttributes = data.allowedAttributes;\n\n    var allowAttribute = function allowAttribute() {\n      // Only add new attributes to `allowedAttributesChanges` to avoid removing\n      // default-supported attributes later erroneously.\n      if (!allowedAttributes[attrName]) {\n        allowedAttributes[attrName] = true;\n        allowedAttributesChanges.push(attrName);\n      }\n    }; // Allow all attributes for AMP elements. This avoids the need to whitelist\n    // nonstandard attributes for every component e.g. amp-lightbox[scrollable].\n\n\n    var isAmpElement = (0, _string.startsWith)(tagName, 'amp-');\n\n    if (isAmpElement) {\n      allowAttribute();\n    } else {\n      // `<A>` has special target rules:\n      // - Default target is \"_top\";\n      // - Allowed targets are \"_blank\", \"_top\";\n      // - All other targets are rewritted to \"_top\".\n      if (tagName == 'a' && attrName == 'target') {\n        var lowercaseValue = attrValue.toLowerCase();\n\n        if (!_sanitation.WHITELISTED_TARGETS.includes(lowercaseValue)) {\n          attrValue = '_top';\n        } else {\n          // Always use lowercase values for `target` attr.\n          attrValue = lowercaseValue;\n        }\n      } // For non-AMP elements, allow attributes in tag-specific whitelist.\n\n\n      var attrsByTags = _sanitation.WHITELISTED_ATTRS_BY_TAGS[tagName];\n\n      if (attrsByTags && attrsByTags.includes(attrName)) {\n        allowAttribute();\n      }\n    }\n\n    var bindingType = bindingTypeForAttr(attrName); // Rewrite classic bindings e.g. [foo]=\"bar\" -> data-amp-bind-foo=\"bar\".\n    // This is because DOMPurify eagerly removes attributes and re-adds them\n    // after sanitization, which fails because `[]` are not valid attr chars.\n\n    if (bindingType === BindingType.CLASSIC) {\n      var property = attrName.substring(1, attrName.length - 1);\n      element.setAttribute(\"\" + _sanitation.BIND_PREFIX + property, attrValue);\n    }\n\n    if (bindingType !== BindingType.NONE) {\n      // Set a custom attribute to mark this element as containing a binding.\n      // This is an optimization that obviates the need for DOM scan later.\n      element.setAttribute('i-amphtml-binding', '');\n    }\n\n    if ((0, _sanitation.isValidAttr)(tagName, attrName, attrValue,\n    /* doc */\n    doc,\n    /* opt_purify */\n    true)) {\n      if (attrValue && !(0, _string.startsWith)(attrName, 'data-amp-bind-')) {\n        attrValue = (0, _urlRewrite.rewriteAttributeValue)(tagName, attrName, attrValue);\n      }\n    } else {\n      data.keepAttr = false;\n      (0, _log.user)().error(TAG, 'Removed invalid attribute %s[%s=\"%s\"].', tagName, attrName, attrValue);\n    } // Update attribute value.\n\n\n    data.attrValue = attrValue;\n  };\n  /**\n   * @param {!Element} element\n   * @this {{removed: !Array}} Contains list of removed elements/attrs so far.\n   */\n\n\n  var afterSanitizeAttributes = function afterSanitizeAttributes(element) {\n    (0, _sanitation.markElementForDiffing)(element, function () {\n      return String(KEY_COUNTER++);\n    }); // DOMPurify doesn't have a tag-specific attribute whitelist API and\n    // `allowedAttributes` has a per-invocation scope, so we need to undo\n    // changes after sanitizing attributes.\n\n    allowedAttributesChanges.forEach(function (attr) {\n      delete allowedAttributes[attr];\n    });\n    allowedAttributesChanges.length = 0; // Only allow relative references in <use>.\n\n    var tagName = element.nodeName.toLowerCase();\n\n    if (tagName === 'use') {\n      ['href', 'xlink:href'].forEach(function (attr) {\n        if (element.hasAttribute(attr) && !(0, _string.startsWith)(element.getAttribute(attr), '#')) {\n          (0, _dom.removeElement)(element);\n          (0, _log.user)().error(TAG, 'Removed invalid <use>. use[href] must start with \"#\".');\n        }\n      });\n    }\n  };\n\n  purifier.addHook('uponSanitizeElement', uponSanitizeElement);\n  purifier.addHook('afterSanitizeElements', afterSanitizeElements);\n  purifier.addHook('uponSanitizeAttribute', uponSanitizeAttribute);\n  purifier.addHook('afterSanitizeAttributes', afterSanitizeAttributes);\n}\n/**\n * @enum {number}\n */\n\n\nvar BindingType = {\n  NONE: 0,\n  CLASSIC: 1,\n  ALTERNATIVE: 2\n};\n/**\n * @param {string} attrName\n * @return {BindingType}\n */\n\nfunction bindingTypeForAttr(attrName) {\n  if (attrName[0] == '[' && attrName[attrName.length - 1] == ']') {\n    return BindingType.CLASSIC;\n  }\n\n  if ((0, _string.startsWith)(attrName, _sanitation.BIND_PREFIX)) {\n    return BindingType.ALTERNATIVE;\n  }\n\n  return BindingType.NONE;\n}\n/**\n * Returns whether an attribute addition/modification/removal is valid.\n *\n * This function's behavior should match that of addPurifyHooks(), except\n * that it operates on attribute changes instead of rendering new HTML.\n *\n * @param {!DomPurifyDef} purifier\n * @param {!Node} node\n * @param {string} attr Lower-case attribute name.\n * @param {string|null} value\n * @return {boolean}\n */\n\n\nfunction validateAttributeChange(purifier, node, attr, value) {\n  var tag = node.nodeName.toLowerCase(); // Disallow change of attributes that are required for certain tags,\n  // e.g. script[type].\n\n  var whitelist = WHITELISTED_TAGS_BY_ATTRS[tag];\n\n  if (whitelist) {\n    var attribute = whitelist.attribute,\n        values = whitelist.values;\n\n    if (attribute === attr) {\n      if (value == null || !values.includes(value)) {\n        return false;\n      }\n    }\n  } // a[target] is required and only certain values are allowed.\n\n\n  if (tag === 'a' && attr === 'target') {\n    if (value == null || !_sanitation.WHITELISTED_TARGETS.includes(value)) {\n      return false;\n    }\n  } // By now, the attribute is safe to remove.  DOMPurify.isValidAttribute()\n  // expects non-null values.\n\n\n  if (value == null) {\n    return true;\n  } // Don't allow binding attributes for now.\n\n\n  if (bindingTypeForAttr(attr) !== BindingType.NONE) {\n    return false;\n  }\n\n  var pure = purifier.isValidAttribute(tag, attr, value);\n\n  if (!pure) {\n    // DOMPurify.isValidAttribute() by default rejects certain attributes that\n    // we should allow: (1) AMP element attributes, (2) tag-specific attributes.\n    // Reject if _not_ one of the above.\n    //\n    // TODO(choumx): This opts out of DOMPurify's attribute _value_ sanitization\n    // for the above, which assumes that the attributes don't have security\n    // implications beyond URLs etc. that are covered by isValidAttr().\n    // This is OK but we ought to contribute new hooks and remove this.\n    var attrsByTags = _sanitation.WHITELISTED_ATTRS_BY_TAGS[tag];\n    var whitelistedForTag = attrsByTags && attrsByTags.includes(attr);\n\n    if (!whitelistedForTag && !(0, _string.startsWith)(tag, 'amp-')) {\n      return false;\n    }\n  }\n\n  var doc = node.ownerDocument ? node.ownerDocument :\n  /** @type {!Document} */\n  node; // Perform AMP-specific attribute validation e.g. __amp_source_origin.\n\n  if (value && !(0, _sanitation.isValidAttr)(tag, attr, value, doc,\n  /* opt_purify */\n  true)) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Uses DOMPurify to sanitize HTML with stricter policy for unescaped templates\n * e.g. triple mustache.\n *\n * @param {string} html\n * @param {!Document=} doc\n * @return {string}\n */\n\n\nfunction purifyTagsForTripleMustache(html, doc) {\n  if (doc === void 0) {\n    doc = self.document;\n  }\n\n  // Reference to DOMPurify's `allowedTags` whitelist.\n  var allowedTags;\n  DomPurify.addHook('uponSanitizeElement', function (node, data) {\n    var tagName = data.tagName;\n    allowedTags = data.allowedTags;\n\n    if (tagName === 'template') {\n      var type = node.getAttribute('type');\n\n      if (type && type.toLowerCase() === 'amp-mustache') {\n        allowedTags['template'] = true;\n      }\n    }\n  });\n  DomPurify.addHook('afterSanitizeElements', function (unusedNode) {\n    // DOMPurify doesn't have an required-attribute tag whitelist API and\n    // `allowedTags` has a per-invocation scope, so we need to remove\n    // required-attribute tags after sanitizing each element.\n    allowedTags['template'] = false;\n  }); // <template> elements are parsed by the browser as document fragments and\n  // reparented to the head. So to support nested templates, we need\n  // RETURN_DOM_FRAGMENT to keep the <template> and FORCE_BODY to prevent\n  // reparenting. See https://github.com/cure53/DOMPurify/issues/285#issuecomment-397810671\n\n  var fragment = DomPurify.sanitize(html, {\n    'ALLOWED_TAGS': _sanitation.TRIPLE_MUSTACHE_WHITELISTED_TAGS,\n    'FORCE_BODY': true,\n    'RETURN_DOM_FRAGMENT': true\n  });\n  DomPurify.removeAllHooks(); // Serialize DocumentFragment to HTML. XMLSerializer would also work, but adds\n  // namespaces for all elements and attributes.\n\n  var div = doc.createElement('div');\n  div.appendChild(fragment);\n  return div.\n  /*OK*/\n  innerHTML;\n}\n\n},{\"./dom\":5,\"./format\":6,\"./log\":8,\"./sanitation\":12,\"./string\":14,\"./url-rewrite\":17,\"dompurify/dist/purify.es\":2}],12:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.markElementForDiffing = markElementForDiffing;\nexports.isValidAttr = isValidAttr;\nexports.WHITELISTED_TARGETS = exports.WHITELISTED_ATTRS_BY_TAGS = exports.WHITELISTED_ATTRS = exports.TRIPLE_MUSTACHE_WHITELISTED_TAGS = exports.EMAIL_WHITELISTED_AMP_TAGS = exports.BLACKLISTED_TAGS = exports.DIFFABLE_AMP_ELEMENTS = exports.DIFF_IGNORE = exports.DIFF_KEY = exports.BIND_PREFIX = void 0;\n\nvar _object = require(\"./utils/object\");\n\nvar _format = require(\"./format\");\n\nvar _urlRewrite = require(\"./url-rewrite\");\n\nvar _string = require(\"./string\");\n\n/**\n * Copyright 2019 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const {string} */\nvar BIND_PREFIX = 'data-amp-bind-';\n/** @const {string} */\n\nexports.BIND_PREFIX = BIND_PREFIX;\nvar DIFF_KEY = 'i-amphtml-key';\n/** @const {string} */\n\nexports.DIFF_KEY = DIFF_KEY;\nvar DIFF_IGNORE = 'i-amphtml-ignore';\n/**\n * Map of AMP element tag name to attributes that, if changed, require\n * replacement of the original element.\n * @const {!Object<string, !Array<string>>}\n */\n\nexports.DIFF_IGNORE = DIFF_IGNORE;\nvar DIFFABLE_AMP_ELEMENTS = {\n  'AMP-IMG': ['src', 'srcset', 'layout', 'width', 'height']\n};\n/**\n * Most AMP elements don't support ad hoc mutation and should be replaced\n * instead of DOM diff'ed. Some AMP elements can be manually diff'ed.\n *\n * Both of these cases require a special attribute to enable special handling in\n * the diffing algorithm. This function sets the appropriate attribute.\n *\n * @param {!Element} element\n * @param {function(): string} generateKey\n */\n\nexports.DIFFABLE_AMP_ELEMENTS = DIFFABLE_AMP_ELEMENTS;\n\nfunction markElementForDiffing(element, generateKey) {\n  var isAmpElement = (0, _string.startsWith)(element.tagName, 'AMP-'); // Don't DOM diff nodes with bindings because amp-bind scans newly rendered\n  // elements and discards _all_ old elements _before_ diffing, so preserving\n  // old elements would cause loss of functionality.\n\n  var hasBinding = element.hasAttribute('i-amphtml-binding');\n\n  if (!hasBinding && DIFFABLE_AMP_ELEMENTS[element.tagName]) {\n    // Nodes marked with \"ignore\" will not be touched (old element stays).\n    // We want this to allow manual diffing afterwards.\n    element.setAttribute(DIFF_IGNORE, '');\n  } else if (hasBinding || isAmpElement) {\n    // Diff'ed node pairs with unique \"key\" will always be replaced.\n    if (!element.hasAttribute(DIFF_KEY)) {\n      element.setAttribute(DIFF_KEY, generateKey());\n    }\n  }\n}\n/**\n * @const {!Object<string, boolean>}\n * @see https://github.com/ampproject/amphtml/blob/master/spec/amp-html-format.md\n */\n\n\nvar BLACKLISTED_TAGS = {\n  'applet': true,\n  'audio': true,\n  'base': true,\n  'embed': true,\n  'frame': true,\n  'frameset': true,\n  'iframe': true,\n  'img': true,\n  'link': true,\n  'meta': true,\n  'object': true,\n  'style': true,\n  'video': true\n};\n/**\n * AMP elements allowed in AMP4EMAIL, modulo:\n * - amp-list, which cannot be nested.\n * - amp-lightbox and amp-image-lightbox, which are deprecated.\n * @const {!Object<string, boolean>}\n * @see https://github.com/ampproject/amphtml/blob/master/spec/email/amp-email-components.md\n */\n\nexports.BLACKLISTED_TAGS = BLACKLISTED_TAGS;\nvar EMAIL_WHITELISTED_AMP_TAGS = {\n  'amp-accordion': true,\n  'amp-anim': true,\n  'amp-bind-macro': true,\n  'amp-carousel': true,\n  'amp-fit-text': true,\n  'amp-img': true,\n  'amp-layout': true,\n  'amp-selector': true,\n  'amp-sidebar': true,\n  'amp-state': true,\n  'amp-timeago': true\n};\n/**\n * Whitelist of tags allowed in triple mustache e.g. {{{name}}}.\n * Very restrictive by design since the triple mustache renders unescaped HTML\n * which, unlike double mustache, won't be processed by the AMP Validator.\n * @const {!Array<string>}\n */\n\nexports.EMAIL_WHITELISTED_AMP_TAGS = EMAIL_WHITELISTED_AMP_TAGS;\nvar TRIPLE_MUSTACHE_WHITELISTED_TAGS = ['a', 'b', 'br', 'caption', 'colgroup', 'code', 'del', 'div', 'em', 'hr', 'i', 'ins', 'li', 'mark', 'ol', 'p', 'q', 's', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'time', 'td', 'th', 'thead', 'tfoot', 'tr', 'u', 'ul'];\n/**\n * Tag-agnostic attribute whitelisted used by both Caja and DOMPurify.\n * @const {!Array<string>}\n */\n\nexports.TRIPLE_MUSTACHE_WHITELISTED_TAGS = TRIPLE_MUSTACHE_WHITELISTED_TAGS;\nvar WHITELISTED_ATTRS = [// AMP-only attributes that don't exist in HTML.\n'amp-fx', 'fallback', 'heights', 'layout', 'min-font-size', 'max-font-size', 'on', 'option', 'placeholder', // Attributes related to amp-form.\n'submitting', 'submit-success', 'submit-error', 'validation-for', 'verify-error', 'visible-when-invalid', // HTML attributes that are scrubbed by Caja but we handle specially.\n'href', 'style', // Attributes for amp-bind that exist in \"[foo]\" form.\n'text', // Attributes for amp-subscriptions.\n'subscriptions-action', 'subscriptions-actions', 'subscriptions-decorate', 'subscriptions-dialog', 'subscriptions-display', 'subscriptions-section', 'subscriptions-service', // Attributes for amp-drilldown.\n'amp-drilldown-submenu', 'amp-drilldown-submenu-open', 'amp-drilldown-submenu-close', // A global attribute used for structured data.\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/itemprop\n'itemprop'];\n/**\n * Attributes that are only whitelisted for specific, non-AMP elements.\n * @const {!Object<string, !Array<string>>}\n */\n\nexports.WHITELISTED_ATTRS = WHITELISTED_ATTRS;\nvar WHITELISTED_ATTRS_BY_TAGS = {\n  'a': ['rel', 'target'],\n  'div': ['template'],\n  'form': ['action-xhr', 'verify-xhr', 'custom-validation-reporting', 'target'],\n  'input': ['mask-output'],\n  'template': ['type'],\n  'textarea': ['autoexpand']\n};\n/** @const {!Array<string>} */\n\nexports.WHITELISTED_ATTRS_BY_TAGS = WHITELISTED_ATTRS_BY_TAGS;\nvar WHITELISTED_TARGETS = ['_top', '_blank'];\n/** @const {!Array<string>} */\n\nexports.WHITELISTED_TARGETS = WHITELISTED_TARGETS;\nvar BLACKLISTED_ATTR_VALUES = Object.freeze([\n/*eslint no-script-url: 0*/\n'javascript:',\n/*eslint no-script-url: 0*/\n'vbscript:',\n/*eslint no-script-url: 0*/\n'data:',\n/*eslint no-script-url: 0*/\n'<script',\n/*eslint no-script-url: 0*/\n'</script']);\n/** @const {!Object<string, !Object<string, !RegExp>>} */\n\nvar BLACKLISTED_TAG_SPECIFIC_ATTR_VALUES = Object.freeze((0, _object.dict)({\n  'input': {\n    'type': /(?:image|button)/i\n  }\n}));\n/**\n * Rules in addition to BLACKLISTED_TAG_SPECIFIC_ATTR_VALUES for AMP4EMAIL.\n * @const {!Object<string, !Object<string, !RegExp>>}\n */\n\nvar EMAIL_BLACKLISTED_TAG_SPECIFIC_ATTR_VALUES = Object.freeze((0, _object.dict)({\n  'input': {\n    'type': /(?:button|file|image|password)/i\n  }\n}));\n/** @const {!Array<string>} */\n\nvar BLACKLISTED_FIELDS_ATTR = Object.freeze(['form', 'formaction', 'formmethod', 'formtarget', 'formnovalidate', 'formenctype']);\n/** @const {!Object<string, !Array<string>>} */\n\nvar BLACKLISTED_TAG_SPECIFIC_ATTRS = Object.freeze((0, _object.dict)({\n  'input': BLACKLISTED_FIELDS_ATTR,\n  'textarea': BLACKLISTED_FIELDS_ATTR,\n  'select': BLACKLISTED_FIELDS_ATTR\n}));\n/**\n * Rules in addition to BLACKLISTED_TAG_SPECIFIC_ATTRS for AMP4EMAIL.\n * @const {!Object<string, !Array<string>>}\n */\n\nvar EMAIL_BLACKLISTED_TAG_SPECIFIC_ATTRS = Object.freeze((0, _object.dict)({\n  'amp-anim': ['controls'],\n  'form': ['name']\n}));\n/**\n * Test for invalid `style` attribute values.\n *\n * !important avoids overriding AMP styles, while `position:fixed|sticky` is a\n * FixedLayer limitation (it only scans the style[amp-custom] stylesheet\n * for potential fixed/sticky elements). Note that the latter can be\n * circumvented with CSS comments -- not a big deal.\n *\n * @const {!RegExp}\n */\n\nvar INVALID_INLINE_STYLE_REGEX = /!important|position\\s*:\\s*fixed|position\\s*:\\s*sticky/i;\n/**\n * Whether the attribute/value is valid.\n * @param {string} tagName Lowercase tag name.\n * @param {string} attrName Lowercase attribute name.\n * @param {string} attrValue attribute value\n * @param {!Document} doc\n * @param {boolean} opt_purify Is true, skips some attribute sanitizations\n *     that are already covered by DOMPurify.\n * @return {boolean}\n */\n\nfunction isValidAttr(tagName, attrName, attrValue, doc, opt_purify) {\n  if (opt_purify === void 0) {\n    opt_purify = false;\n  }\n\n  if (!opt_purify) {\n    // \"on*\" attributes are not allowed.\n    if ((0, _string.startsWith)(attrName, 'on') && attrName != 'on') {\n      return false;\n    } // No attributes with \"javascript\" or other blacklisted substrings in them.\n\n\n    if (attrValue) {\n      var normalized = attrValue.toLowerCase().replace(/[\\s,\\u0000]+/g, '');\n\n      for (var i = 0; i < BLACKLISTED_ATTR_VALUES.length; i++) {\n        if (normalized.indexOf(BLACKLISTED_ATTR_VALUES[i]) >= 0) {\n          return false;\n        }\n      }\n    }\n  } // Don't allow certain inline style values.\n\n\n  if (attrName == 'style') {\n    return !INVALID_INLINE_STYLE_REGEX.test(attrValue);\n  } // Don't allow CSS class names with internal AMP prefix.\n\n\n  if (attrName == 'class' && attrValue && /(^|\\W)i-amphtml-/i.test(attrValue)) {\n    return false;\n  } // Don't allow '__amp_source_origin' in URLs.\n\n\n  if ((0, _urlRewrite.isUrlAttribute)(attrName) && /__amp_source_origin/.test(attrValue)) {\n    return false;\n  }\n\n  var isEmail = (0, _format.isAmp4Email)(doc); // Remove blacklisted attributes from specific tags e.g. input[formaction].\n\n  var attrBlacklist = Object.assign((0, _object.map)(), BLACKLISTED_TAG_SPECIFIC_ATTRS, isEmail ? EMAIL_BLACKLISTED_TAG_SPECIFIC_ATTRS : {})[tagName];\n\n  if (attrBlacklist && attrBlacklist.indexOf(attrName) != -1) {\n    return false;\n  } // Remove blacklisted values for specific attributes for specific tags\n  // e.g. input[type=image].\n\n\n  var attrValueBlacklist = Object.assign((0, _object.map)(), BLACKLISTED_TAG_SPECIFIC_ATTR_VALUES, isEmail ? EMAIL_BLACKLISTED_TAG_SPECIFIC_ATTR_VALUES : {})[tagName];\n\n  if (attrValueBlacklist) {\n    var blacklistedValuesRegex = attrValueBlacklist[attrName];\n\n    if (blacklistedValuesRegex && attrValue.search(blacklistedValuesRegex) != -1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n},{\"./format\":6,\"./string\":14,\"./url-rewrite\":17,\"./utils/object\":22}],13:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.srcsetFromElement = srcsetFromElement;\nexports.srcsetFromSrc = srcsetFromSrc;\nexports.parseSrcset = parseSrcset;\nexports.Srcset = void 0;\n\nvar _log = require(\"./log\");\n\n/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A single source within a srcset. Only one: width or DPR can be specified at\n * a time.\n * @typedef {{\n *   url: string,\n *   width: (number|undefined),\n *   dpr: (number|undefined)\n * }}\n */\nvar SrcsetSourceDef;\n/**\n * General grammar: (URL [NUM[w|x]],)*\n * Example 1: \"image1.png 100w, image2.png 50w\"\n * Example 2: \"image1.png 2x, image2.png\"\n * Example 3: \"image1,100w.png 100w, image2.png 50w\"\n */\n\nvar srcsetRegex = /(\\S+)(?:\\s+(?:(-?\\d+(?:\\.\\d+)?)([a-zA-Z]*)))?\\s*(?:,|$)/g;\n/**\n * Extracts `srcset` and fallbacks to `src` if not available.\n * @param {!Element} element\n * @return {!Srcset}\n */\n\nfunction srcsetFromElement(element) {\n  var srcsetAttr = element.getAttribute('srcset');\n\n  if (srcsetAttr) {\n    return parseSrcset(srcsetAttr);\n  } // We can't push `src` via `parseSrcset` because URLs in `src` are not always\n  // RFC compliant and can't be easily parsed as an `srcset`. For instance,\n  // they sometimes contain space characters.\n\n\n  var srcAttr = (0, _log.userAssert)(element.getAttribute('src'), 'Either non-empty \"srcset\" or \"src\" attribute must be specified: %s', element);\n  return srcsetFromSrc(srcAttr);\n}\n/**\n * Creates a Srcset from a `src` attribute value.\n * @param {string} src\n * @return {!Srcset}\n */\n\n\nfunction srcsetFromSrc(src) {\n  return new Srcset([{\n    url: src,\n    width: undefined,\n    dpr: 1\n  }]);\n}\n/**\n * Parses the text representation of srcset into Srcset object.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#Attributes.\n * See http://www.w3.org/html/wg/drafts/html/master/semantics.html#attr-img-srcset.\n * @param {string} s\n * @return {!Srcset}\n */\n\n\nfunction parseSrcset(s) {\n  var sources = [];\n  var match;\n\n  while (match = srcsetRegex.exec(s)) {\n    var url = match[1];\n    var width = void 0,\n        dpr = void 0;\n\n    if (match[2]) {\n      var type = match[3].toLowerCase();\n\n      if (type == 'w') {\n        width = parseInt(match[2], 10);\n      } else if (type == 'x') {\n        dpr = parseFloat(match[2]);\n      } else {\n        continue;\n      }\n    } else {\n      // If no \"w\" or \"x\" specified, we assume it's \"1x\".\n      dpr = 1;\n    }\n\n    sources.push({\n      url: url,\n      width: width,\n      dpr: dpr\n    });\n  }\n\n  return new Srcset(sources);\n}\n/**\n * A srcset object contains one or more sources.\n *\n * There are two types of sources: width-based and DPR-based. Only one type\n * of sources allowed to be specified within a single srcset. Depending on a\n * usecase, the components are free to choose any source that best corresponds\n * to the required rendering quality and network and CPU conditions. See\n * \"select\" method for details on how this selection is performed.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#Attributes\n */\n\n\nvar Srcset =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {!Array<!SrcsetSourceDef>} sources\n   */\n  function Srcset(sources) {\n    (0, _log.userAssert)(sources.length > 0, 'Srcset must have at least one source');\n    /** @private @const {!Array<!SrcsetSourceDef>} */\n\n    this.sources_ = sources; // Only one type of source specified can be used - width or DPR.\n\n    var hasWidth = false;\n    var hasDpr = false;\n\n    for (var i = 0; i < sources.length; i++) {\n      var source = sources[i];\n      hasWidth = hasWidth || !!source.width;\n      hasDpr = hasDpr || !!source.dpr;\n    }\n\n    (0, _log.userAssert)(!!(hasWidth ^ hasDpr), 'Srcset must have width or dpr sources, but not both'); // Source and assert duplicates.\n\n    sources.sort(hasWidth ? sortByWidth : sortByDpr);\n    /** @private @const {boolean} */\n\n    this.widthBased_ = hasWidth;\n  }\n  /**\n   * Performs selection for specified width and DPR. Here, width is the width\n   * in screen pixels and DPR is the device-pixel-ratio or pixel density of\n   * the device. Depending on the circumstances, such as low network conditions,\n   * it's possible to manipulate the result of this method by passing a lower\n   * DPR value.\n   *\n   * The source selection depends on whether this is width-based or DPR-based\n   * srcset.\n   *\n   * In a width-based source, the source's width is the physical width of a\n   * resource (e.g. an image). Depending on the provided DPR, this width is\n   * converted to the screen pixels as following:\n   *   pixelWidth = sourceWidth / DPR\n   *\n   * Then, the source closest to the requested \"width\" is selected using\n   * the \"pixelWidth\". The slight preference is given to the bigger sources to\n   * ensure the most optimal quality.\n   *\n   * In a DPR-based source, the source's DPR is used to return the source that\n   * is closest to the requested DPR.\n   *\n   * Based on\n   * http://www.w3.org/html/wg/drafts/html/master/semantics.html#attr-img-srcset.\n   * @param {number} width\n   * @param {number} dpr\n   * @return {string}\n   */\n\n\n  var _proto = Srcset.prototype;\n\n  _proto.select = function select(width, dpr) {\n    (0, _log.devAssert)(width, 'width=%s', width);\n    (0, _log.devAssert)(dpr, 'dpr=%s', dpr);\n    var index = 0;\n\n    if (this.widthBased_) {\n      index = this.selectByWidth_(width * dpr);\n    } else {\n      index = this.selectByDpr_(dpr);\n    }\n\n    return this.sources_[index].url;\n  }\n  /**\n   * @param {number} width\n   * @return {number}\n   * @private\n   */\n  ;\n\n  _proto.selectByWidth_ = function selectByWidth_(width) {\n    var sources = this.sources_;\n    var minIndex = 0;\n    var minScore = Infinity;\n    var minWidth = Infinity;\n\n    for (var i = 0; i < sources.length; i++) {\n      var sWidth = sources[i].width;\n      var score = Math.abs(sWidth - width); // Select the one that is closer with a slight preference toward larger\n      // widths. If smaller size is closer, enforce minimum ratio to ensure\n      // image isn't too distorted.\n\n      if (score <= minScore * 1.1 || width / minWidth > 1.2) {\n        minIndex = i;\n        minScore = score;\n        minWidth = sWidth;\n      } else {\n        break;\n      }\n    }\n\n    return minIndex;\n  }\n  /**\n   * @param {number} dpr\n   * @return {number}\n   * @private\n   */\n  ;\n\n  _proto.selectByDpr_ = function selectByDpr_(dpr) {\n    var sources = this.sources_;\n    var minIndex = 0;\n    var minScore = Infinity;\n\n    for (var i = 0; i < sources.length; i++) {\n      var score = Math.abs(sources[i].dpr - dpr);\n\n      if (score <= minScore) {\n        minIndex = i;\n        minScore = score;\n      } else {\n        break;\n      }\n    }\n\n    return minIndex;\n  }\n  /**\n   * Returns all URLs in the srcset.\n   * @return {!Array<string>}\n   */\n  ;\n\n  _proto.getUrls = function getUrls() {\n    return this.sources_.map(function (s) {\n      return s.url;\n    });\n  }\n  /**\n   * Reconstructs the string expression for this srcset.\n   * @param {function(string):string=} opt_mapper\n   * @return {string}\n   */\n  ;\n\n  _proto.stringify = function stringify(opt_mapper) {\n    var res = [];\n    var sources = this.sources_;\n\n    for (var i = 0; i < sources.length; i++) {\n      var source = sources[i];\n      var src = source.url;\n\n      if (opt_mapper) {\n        src = opt_mapper(src);\n      }\n\n      if (this.widthBased_) {\n        src += \" \" + source.width + \"w\";\n      } else {\n        src += \" \" + source.dpr + \"x\";\n      }\n\n      res.push(src);\n    }\n\n    return res.join(', ');\n  };\n\n  return Srcset;\n}();\n/**\n * Sorts by width\n *\n * @param {number} s1\n * @param {number} s2\n * @return {number}\n */\n\n\nexports.Srcset = Srcset;\n\nfunction sortByWidth(s1, s2) {\n  (0, _log.userAssert)(s1.width != s2.width, 'Duplicate width: %s', s1.width);\n  return s1.width - s2.width;\n}\n/**\n * Sorts by dpr\n *\n * @param {!Object} s1\n * @param {!Object} s2\n * @return {number}\n */\n\n\nfunction sortByDpr(s1, s2) {\n  (0, _log.userAssert)(s1.dpr != s2.dpr, 'Duplicate dpr: %s', s1.dpr);\n  return s1.dpr - s2.dpr;\n}\n\n},{\"./log\":8}],14:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.dashToCamelCase = dashToCamelCase;\nexports.camelCaseToDash = camelCaseToDash;\nexports.dashToUnderline = dashToUnderline;\nexports.endsWith = endsWith;\nexports.startsWith = startsWith;\nexports.includes = includes;\nexports.expandTemplate = expandTemplate;\nexports.stringHash32 = stringHash32;\nexports.trimEnd = trimEnd;\nexports.trimStart = trimStart;\nexports.padStart = padStart;\n\n/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @param {string} _match\n * @param {string} character\n * @return {string}\n */\nfunction toUpperCase(_match, character) {\n  return character.toUpperCase();\n}\n/**\n * @param {string} match\n * @return {string}\n */\n\n\nfunction prependDashAndToLowerCase(match) {\n  return '-' + match.toLowerCase();\n}\n/**\n * @param {string} name Attribute name containing dashes.\n * @return {string} Dashes removed and successive character sent to upper case.\n * visibleForTesting\n */\n\n\nfunction dashToCamelCase(name) {\n  return name.replace(/-([a-z])/g, toUpperCase);\n}\n/**\n * Converts a string that is in camelCase to one that is in dash-case.\n *\n * @param {string} string The string to convert.\n * @return {string} The string in dash-case.\n */\n\n\nfunction camelCaseToDash(string) {\n  return string.replace(/(?!^)[A-Z]/g, prependDashAndToLowerCase);\n}\n/**\n * @param {string} name Attribute name with dashes\n * @return {string} Dashes replaced by underlines.\n */\n\n\nfunction dashToUnderline(name) {\n  return name.replace('-', '_');\n}\n/**\n * Polyfill for String.prototype.endsWith.\n * @param {string} string\n * @param {string} suffix\n * @return {boolean}\n */\n\n\nfunction endsWith(string, suffix) {\n  var index = string.length - suffix.length;\n  return index >= 0 && string.indexOf(suffix, index) == index;\n}\n/**\n * Polyfill for String.prototype.startsWith.\n * @param {string} string\n * @param {string} prefix\n * @return {boolean}\n */\n\n\nfunction startsWith(string, prefix) {\n  if (prefix.length > string.length) {\n    return false;\n  }\n\n  return string.lastIndexOf(prefix, 0) == 0;\n}\n/**\n * Polyfill for String.prototype.includes.\n * @param {string} string\n * @param {string} substring\n * @param {number=} start\n * @return {boolean}\n */\n\n\nfunction includes(string, substring, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + substring.length > string.length) {\n    return false;\n  }\n\n  return string.indexOf(substring, start) !== -1;\n}\n/**\n * Expands placeholders in a given template string with values.\n *\n * Placeholders use ${key-name} syntax and are replaced with the value\n * returned from the given getter function.\n *\n * @param {string} template The template string to expand.\n * @param {function(string):*} getter Function used to retrieve a value for a\n *   placeholder. Returns values will be coerced into strings.\n * @param {number=} opt_maxIterations Number of times to expand the template.\n *   Defaults to 1, but should be set to a larger value your placeholder tokens\n *   can be expanded to other placeholder tokens. Take caution with large values\n *   as recursively expanding a string can be exponentially expensive.\n * @return {string}\n */\n\n\nfunction expandTemplate(template, getter, opt_maxIterations) {\n  var maxIterations = opt_maxIterations || 1;\n\n  var _loop = function _loop(i) {\n    var matches = 0;\n    template = template.replace(/\\${([^}]*)}/g, function (_a, b) {\n      matches++;\n      return getter(b);\n    });\n\n    if (!matches) {\n      return \"break\";\n    }\n  };\n\n  for (var i = 0; i < maxIterations; i++) {\n    var _ret = _loop(i);\n\n    if (_ret === \"break\") break;\n  }\n\n  return template;\n}\n/**\n * Hash function djb2a\n * This is intended to be a simple, fast hashing function using minimal code.\n * It does *not* have good cryptographic properties.\n * @param {string} str\n * @return {string} 32-bit unsigned hash of the string\n */\n\n\nfunction stringHash32(str) {\n  var length = str.length;\n  var hash = 5381;\n\n  for (var i = 0; i < length; i++) {\n    hash = hash * 33 ^ str.charCodeAt(i);\n  } // Convert from 32-bit signed to unsigned.\n\n\n  return String(hash >>> 0);\n}\n/**\n * Trims a string on the end, removing whitespace characters.\n * @param {string} str  A string to trim.\n * @return {string} The string, with trailing whitespace removed.\n */\n\n\nfunction trimEnd(str) {\n  // TODO(sparhami) Does this get inlined for an ES2019 build?\n  if (str.trimEnd) {\n    return str.trimEnd();\n  }\n\n  return ('_' + str).trim().slice(1);\n}\n/**\n * Trims any leading whitespace from a string.\n * @param {string} str  A string to trim.\n * @return {string} The string, with leading whitespace removed.\n */\n\n\nfunction trimStart(str) {\n  if (str.trimStart) {\n    return str.trimStart();\n  }\n\n  return (str + '_').trim().slice(0, -1);\n}\n/**\n * Pads the beginning of a string with a substring to a target length.\n * @param {string} s\n * @param {number} targetLength\n * @param {string} padString\n * @return {*} TODO(#23582): Specify return type\n */\n\n\nfunction padStart(s, targetLength, padString) {\n  if (s.length >= targetLength) {\n    return s;\n  }\n\n  targetLength = targetLength - s.length;\n  var padding = padString;\n\n  while (targetLength > padding.length) {\n    padding += padString;\n  }\n\n  return padding.slice(0, targetLength) + s;\n}\n\n},{}],15:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.isArray = isArray;\nexports.toArray = toArray;\nexports.isObject = isObject;\nexports.isFiniteNumber = isFiniteNumber;\nexports.isEnumValue = isEnumValue;\nexports.toWin = toWin;\n\n/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* @const */\nvar toString_ = Object.prototype.toString;\n/**\n * Returns the ECMA [[Class]] of a value\n * @param {*} value\n * @return {string}\n */\n\nfunction toString(value) {\n  return toString_.call(value);\n}\n/**\n * Determines if value is actually an Array.\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n/**\n * Converts an array-like object to an array.\n * @param {?IArrayLike<T>|string} arrayLike\n * @return {!Array<T>}\n * @template T\n */\n\n\nfunction toArray(arrayLike) {\n  return arrayLike ? Array.prototype.slice.call(arrayLike) : [];\n}\n/**\n * Determines if value is actually an Object.\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isObject(value) {\n  return toString(value) === '[object Object]';\n}\n/**\n * Determines if value is of number type and finite.\n * NaN and Infinity are not considered a finite number.\n * String numbers are not considered numbers.\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isFiniteNumber(value) {\n  return typeof value === 'number' && isFinite(value);\n}\n/**\n * Checks whether `s` is a valid value of `enumObj`.\n *\n * @param {!Object<T>} enumObj\n * @param {T} s\n * @return {boolean}\n * @template T\n */\n\n\nfunction isEnumValue(enumObj, s) {\n  for (var k in enumObj) {\n    if (enumObj[k] === s) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Externs declare that access `defaultView` from `document` or\n * `ownerDocument` is of type `(Window|null)` but most of our parameter types\n * assume that it is never null. This is OK in practice as we ever only get\n * null on disconnected documents or old IE.\n * This helper function casts it into just a simple Window return type.\n *\n * @param {!Window|null} winOrNull\n * @return {!Window}\n */\n\n\nfunction toWin(winOrNull) {\n  return (\n    /** @type {!Window} */\n    winOrNull\n  );\n}\n\n},{}],16:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.parseQueryString_ = parseQueryString_;\n\nvar _urlTryDecodeUriComponent = require(\"./url-try-decode-uri-component\");\n\n/**\n * Copyright 2017 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar regex = /(?:^[#?]?|&)([^=&]+)(?:=([^&]*))?/g;\n/**\n * Parses the query string of an URL. This method returns a simple key/value\n * map. If there are duplicate keys the latest value is returned.\n *\n * DO NOT import the function from this file. Instead, import parseQueryString\n * from `src/url.js`.\n *\n * @param {string} queryString\n * @return {!JsonObject}\n */\n\nfunction parseQueryString_(queryString) {\n  var params =\n  /** @type {!JsonObject} */\n  Object.create(null);\n\n  if (!queryString) {\n    return params;\n  }\n\n  var match;\n\n  while (match = regex.exec(queryString)) {\n    var name = (0, _urlTryDecodeUriComponent.tryDecodeUriComponent_)(match[1], match[1]);\n    var value = match[2] ? (0, _urlTryDecodeUriComponent.tryDecodeUriComponent_)(match[2], match[2]) : '';\n    params[name] = value;\n  }\n\n  return params;\n}\n\n},{\"./url-try-decode-uri-component\":18}],17:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.rewriteAttributesForElement = rewriteAttributesForElement;\nexports.rewriteAttributeValue = rewriteAttributeValue;\nexports.isUrlAttribute = isUrlAttribute;\nexports.resolveUrlAttr = resolveUrlAttr;\n\nvar _url = require(\"./url\");\n\nvar _srcset = require(\"./srcset\");\n\nvar _string = require(\"./string\");\n\nvar _config = require(\"./config\");\n\nvar _log = require(\"./log\");\n\n/**\n * Copyright 2019 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar TAG = 'URL-REWRITE';\n/** @private @const {string} */\n\nvar ORIGINAL_TARGET_VALUE = '__AMP_ORIGINAL_TARGET_VALUE_';\n/**\n * The same as rewriteAttributeValue() but actually updates the element and\n * modifies other related attribute(s) for special cases, i.e. `target` for <a>.\n * @param {!Element} element\n * @param {string} attrName\n * @param {string} attrValue\n * @param {!Location=} opt_location\n * @param {boolean=} opt_updateProperty\n * @return {string}\n */\n\nfunction rewriteAttributesForElement(element, attrName, attrValue, opt_location, opt_updateProperty) {\n  var tag = element.tagName.toLowerCase();\n  var attr = attrName.toLowerCase();\n  var rewrittenValue = rewriteAttributeValue(tag, attr, attrValue); // When served from proxy (CDN), changing an <a> tag from a hash link to a\n  // non-hash link requires updating `target` attribute per cache modification\n  // rules. @see amp-cache-modifications.md#url-rewrites\n\n  var isProxy = (0, _url.isProxyOrigin)(opt_location || self.location);\n\n  if (isProxy && tag === 'a' && attr === 'href') {\n    var oldValue = element.getAttribute(attr);\n    var newValueIsHash = rewrittenValue[0] === '#';\n    var oldValueIsHash = oldValue && oldValue[0] === '#';\n\n    if (newValueIsHash && !oldValueIsHash) {\n      // Save the original value of `target` so it can be restored (if needed).\n      if (!element[ORIGINAL_TARGET_VALUE]) {\n        element[ORIGINAL_TARGET_VALUE] = element.getAttribute('target');\n      }\n\n      element.removeAttribute('target');\n    } else if (oldValueIsHash && !newValueIsHash) {\n      // Restore the original value of `target` or default to `_top`.\n      element.setAttribute('target', element[ORIGINAL_TARGET_VALUE] || '_top');\n    }\n  }\n\n  if (opt_updateProperty) {\n    // Must be done first for <input> elements to correctly update the UI for\n    // the first change on Safari and Chrome.\n    element[attr] = rewrittenValue;\n  }\n\n  element.setAttribute(attr, rewrittenValue);\n  return rewrittenValue;\n}\n/**\n * If (tagName, attrName) is a CDN-rewritable URL attribute, returns the\n * rewritten URL value. Otherwise, returns the unchanged `attrValue`.\n * See resolveUrlAttr() for rewriting rules.\n * @param {string} tagName Lowercase tag name.\n * @param {string} attrName Lowercase attribute name.\n * @param {string} attrValue\n * @return {string}\n * @private\n * @visibleForTesting\n */\n\n\nfunction rewriteAttributeValue(tagName, attrName, attrValue) {\n  if (isUrlAttribute(attrName)) {\n    return resolveUrlAttr(tagName, attrName, attrValue, self.location);\n  }\n\n  return attrValue;\n}\n/**\n * @param {string} attrName Lowercase attribute name.\n * @return {boolean}\n */\n\n\nfunction isUrlAttribute(attrName) {\n  return attrName == 'src' || attrName == 'href' || attrName == 'srcset';\n}\n/**\n * Rewrites the URL attribute values. URLs are rewritten as following:\n * - If URL is absolute, it is not rewritten\n * - If URL is relative, it's rewritten as absolute against the source origin\n * - If resulting URL is a `http:` URL and it's for image, the URL is rewritten\n *   again to be served with AMP Cache (cdn.ampproject.org).\n *\n * @param {string} tagName Lowercase tag name.\n * @param {string} attrName Lowercase attribute name.\n * @param {string} attrValue\n * @param {!Location} windowLocation\n * @return {string}\n * @private\n * @visibleForTesting\n */\n\n\nfunction resolveUrlAttr(tagName, attrName, attrValue, windowLocation) {\n  (0, _url.checkCorsUrl)(attrValue);\n  var isProxyHost = (0, _url.isProxyOrigin)(windowLocation);\n  var baseUrl = (0, _url.parseUrlDeprecated)((0, _url.getSourceUrl)(windowLocation));\n\n  if (attrName == 'href' && !(0, _string.startsWith)(attrValue, '#')) {\n    return (0, _url.resolveRelativeUrl)(attrValue, baseUrl);\n  }\n\n  if (attrName == 'src') {\n    if (tagName == 'amp-img') {\n      return resolveImageUrlAttr(attrValue, baseUrl, isProxyHost);\n    }\n\n    return (0, _url.resolveRelativeUrl)(attrValue, baseUrl);\n  }\n\n  if (attrName == 'srcset') {\n    var srcset;\n\n    try {\n      srcset = (0, _srcset.parseSrcset)(attrValue);\n    } catch (e) {\n      // Do not fail the whole template just because one srcset is broken.\n      // An AMP element will pick it up and report properly.\n      (0, _log.user)().error(TAG, 'Failed to parse srcset: ', e);\n      return attrValue;\n    }\n\n    return srcset.stringify(function (url) {\n      return resolveImageUrlAttr(url, baseUrl, isProxyHost);\n    });\n  }\n\n  return attrValue;\n}\n/**\n * Non-HTTPs image URLs are rewritten via proxy.\n * @param {string} attrValue\n * @param {!Location} baseUrl\n * @param {boolean} isProxyHost\n * @return {string}\n */\n\n\nfunction resolveImageUrlAttr(attrValue, baseUrl, isProxyHost) {\n  var src = (0, _url.parseUrlDeprecated)((0, _url.resolveRelativeUrl)(attrValue, baseUrl)); // URLs such as `data:` or proxy URLs are returned as is. Unsafe protocols\n  // do not arrive here - already stripped by the sanitizer.\n\n  if (src.protocol == 'data:' || (0, _url.isProxyOrigin)(src) || !isProxyHost) {\n    return src.href;\n  } // Rewrite as a proxy URL.\n\n\n  return _config.urls.cdn + \"/i/\" + (src.protocol == 'https:' ? 's/' : '') + encodeURIComponent(src.host) + src.pathname + (src.search || '') + (src.hash || '');\n}\n\n},{\"./config\":3,\"./log\":8,\"./srcset\":13,\"./string\":14,\"./url\":19}],18:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.tryDecodeUriComponent_ = tryDecodeUriComponent_;\n\n/**\n * Copyright 2017 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Tries to decode a URI component, falling back to opt_fallback (or an empty\n * string)\n *\n * DO NOT import the function from this file. Instead, import\n * tryDecodeUriComponent from `src/url.js`.\n *\n * @param {string} component\n * @param {string=} fallback\n * @return {string}\n */\nfunction tryDecodeUriComponent_(component, fallback) {\n  if (fallback === void 0) {\n    fallback = '';\n  }\n\n  try {\n    return decodeURIComponent(component);\n  } catch (e) {\n    return fallback;\n  }\n}\n\n},{}],19:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.getWinOrigin = getWinOrigin;\nexports.parseUrlDeprecated = parseUrlDeprecated;\nexports.parseUrlWithA = parseUrlWithA;\nexports.appendEncodedParamStringToUrl = appendEncodedParamStringToUrl;\nexports.addParamToUrl = addParamToUrl;\nexports.addParamsToUrl = addParamsToUrl;\nexports.addMissingParamsToUrl = addMissingParamsToUrl;\nexports.serializeQueryString = serializeQueryString;\nexports.isSecureUrlDeprecated = isSecureUrlDeprecated;\nexports.assertHttpsUrl = assertHttpsUrl;\nexports.assertAbsoluteHttpOrHttpsUrl = assertAbsoluteHttpOrHttpsUrl;\nexports.parseQueryString = parseQueryString;\nexports.removeFragment = removeFragment;\nexports.getFragment = getFragment;\nexports.isProxyOrigin = isProxyOrigin;\nexports.getProxyServingType = getProxyServingType;\nexports.isLocalhostOrigin = isLocalhostOrigin;\nexports.isProtocolValid = isProtocolValid;\nexports.removeAmpJsParamsFromUrl = removeAmpJsParamsFromUrl;\nexports.removeSearch = removeSearch;\nexports.removeParamsFromSearch = removeParamsFromSearch;\nexports.getSourceUrl = getSourceUrl;\nexports.getSourceOrigin = getSourceOrigin;\nexports.resolveRelativeUrl = resolveRelativeUrl;\nexports.resolveRelativeUrlFallback_ = resolveRelativeUrlFallback_;\nexports.getCorsUrl = getCorsUrl;\nexports.checkCorsUrl = checkCorsUrl;\nexports.tryDecodeUriComponent = tryDecodeUriComponent;\nexports.SOURCE_ORIGIN_PARAM = void 0;\n\nvar _lruCache = require(\"./utils/lru-cache\");\n\nvar _object = require(\"./utils/object\");\n\nvar _string = require(\"./string\");\n\nvar _mode = require(\"./mode\");\n\nvar _types = require(\"./types\");\n\nvar _urlParseQueryString = require(\"./url-parse-query-string\");\n\nvar _urlTryDecodeUriComponent = require(\"./url-try-decode-uri-component\");\n\nvar _config = require(\"./config\");\n\nvar _log = require(\"./log\");\n\n/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @type {!JsonObject}\n */\nvar SERVING_TYPE_PREFIX = (0, _object.dict)({\n  // No viewer\n  'c': true,\n  // In viewer\n  'v': true,\n  // Ad landing page\n  'a': true,\n  // Ad\n  'ad': true,\n  // Actions viewer\n  'action': true\n});\n/**\n * Cached a-tag to avoid memory allocation during URL parsing.\n * @type {HTMLAnchorElement}\n */\n\nvar a;\n/**\n * We cached all parsed URLs. As of now there are no use cases\n * of AMP docs that would ever parse an actual large number of URLs,\n * but we often parse the same one over and over again.\n * @type {LruCache}\n */\n\nvar cache;\n/** @private @const Matches amp_js_* parameters in query string. */\n\nvar AMP_JS_PARAMS_REGEX = /[?&]amp_js[^&]*/;\n/** @private @const Matches amp_gsa parameters in query string. */\n\nvar AMP_GSA_PARAMS_REGEX = /[?&]amp_gsa[^&]*/;\n/** @private @const Matches amp_r parameters in query string. */\n\nvar AMP_R_PARAMS_REGEX = /[?&]amp_r[^&]*/;\n/** @private @const Matches amp_kit parameters in query string. */\n\nvar AMP_KIT_PARAMS_REGEX = /[?&]amp_kit[^&]*/;\n/** @private @const Matches usqp parameters from goog experiment in query string. */\n\nvar GOOGLE_EXPERIMENT_PARAMS_REGEX = /[?&]usqp[^&]*/;\nvar INVALID_PROTOCOLS = [\n/*eslint no-script-url: 0*/\n'javascript:',\n/*eslint no-script-url: 0*/\n'data:',\n/*eslint no-script-url: 0*/\n'vbscript:'];\n/** @const {string} */\n\nvar SOURCE_ORIGIN_PARAM = '__amp_source_origin';\n/**\n * Returns the correct origin for a given window.\n * @param {!Window} win\n * @return {string} origin\n */\n\nexports.SOURCE_ORIGIN_PARAM = SOURCE_ORIGIN_PARAM;\n\nfunction getWinOrigin(win) {\n  return win.origin || parseUrlDeprecated(win.location.href).origin;\n}\n/**\n * Returns a Location-like object for the given URL. If it is relative,\n * the URL gets resolved.\n * Consider the returned object immutable. This is enforced during\n * testing by freezing the object.\n * @param {string} url\n * @param {boolean=} opt_nocache\n * @return {!Location}\n */\n\n\nfunction parseUrlDeprecated(url, opt_nocache) {\n  if (!a) {\n    a =\n    /** @type {!HTMLAnchorElement} */\n    self.document.createElement('a');\n    cache = self.__AMP_URL_CACHE || (self.__AMP_URL_CACHE = new _lruCache.LruCache(100));\n  }\n\n  return parseUrlWithA(a, url, opt_nocache ? null : cache);\n}\n/**\n * Returns a Location-like object for the given URL. If it is relative,\n * the URL gets resolved.\n * Consider the returned object immutable. This is enforced during\n * testing by freezing the object.\n * @param {!HTMLAnchorElement} a\n * @param {string} url\n * @param {LruCache=} opt_cache\n * @return {!Location}\n * @restricted\n */\n\n\nfunction parseUrlWithA(a, url, opt_cache) {\n  if (opt_cache && opt_cache.has(url)) {\n    return opt_cache.get(url);\n  }\n\n  a.href = url; // IE11 doesn't provide full URL components when parsing relative URLs.\n  // Assigning to itself again does the trick #3449.\n\n  if (!a.protocol) {\n    a.href = a.href;\n  }\n\n  var info =\n  /** @type {!Location} */\n  {\n    href: a.href,\n    protocol: a.protocol,\n    host: a.host,\n    hostname: a.hostname,\n    port: a.port == '0' ? '' : a.port,\n    pathname: a.pathname,\n    search: a.search,\n    hash: a.hash,\n    origin: null // Set below.\n\n  }; // Some IE11 specific polyfills.\n  // 1) IE11 strips out the leading '/' in the pathname.\n\n  if (info.pathname[0] !== '/') {\n    info.pathname = '/' + info.pathname;\n  } // 2) For URLs with implicit ports, IE11 parses to default ports while\n  // other browsers leave the port field empty.\n\n\n  if (info.protocol == 'http:' && info.port == 80 || info.protocol == 'https:' && info.port == 443) {\n    info.port = '';\n    info.host = info.hostname;\n  } // For data URI a.origin is equal to the string 'null' which is not useful.\n  // We instead return the actual origin which is the full URL.\n\n\n  var origin;\n\n  if (a.origin && a.origin != 'null') {\n    origin = a.origin;\n  } else if (info.protocol == 'data:' || !info.host) {\n    origin = info.href;\n  } else {\n    origin = info.protocol + '//' + info.host;\n  }\n\n  info.origin = origin; // Freeze during testing to avoid accidental mutation.\n\n  var frozen = (0, _mode.getMode)().test && Object.freeze ? Object.freeze(info) : info;\n\n  if (opt_cache) {\n    opt_cache.put(url, frozen);\n  }\n\n  return frozen;\n}\n/**\n * Appends the string just before the fragment part (or optionally\n * to the front of the query string) of the URL.\n * @param {string} url\n * @param {string} paramString\n * @param {boolean=} opt_addToFront\n * @return {string}\n */\n\n\nfunction appendEncodedParamStringToUrl(url, paramString, opt_addToFront) {\n  if (!paramString) {\n    return url;\n  }\n\n  var mainAndFragment = url.split('#', 2);\n  var mainAndQuery = mainAndFragment[0].split('?', 2);\n  var newUrl = mainAndQuery[0] + (mainAndQuery[1] ? opt_addToFront ? \"?\" + paramString + \"&\" + mainAndQuery[1] : \"?\" + mainAndQuery[1] + \"&\" + paramString : \"?\" + paramString);\n  newUrl += mainAndFragment[1] ? \"#\" + mainAndFragment[1] : '';\n  return newUrl;\n}\n/**\n * Appends a query string field and value to a url. `key` and `value`\n * will be ran through `encodeURIComponent` before appending.\n * @param {string} url\n * @param {string} key\n * @param {string} value\n * @param {boolean=} opt_addToFront\n * @return {string}\n */\n\n\nfunction addParamToUrl(url, key, value, opt_addToFront) {\n  var field = encodeURIComponent(key) + \"=\" + encodeURIComponent(value);\n  return appendEncodedParamStringToUrl(url, field, opt_addToFront);\n}\n/**\n * Appends query string fields and values to a url. The `params` objects'\n * `key`s and `value`s will be transformed into query string keys/values.\n * @param {string} url\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\n\n\nfunction addParamsToUrl(url, params) {\n  return appendEncodedParamStringToUrl(url, serializeQueryString(params));\n}\n/**\n * Append query string fields and values to a url, only if the key does not\n * exist in current query string.\n * @param {string} url\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\n\n\nfunction addMissingParamsToUrl(url, params) {\n  var location = parseUrlDeprecated(url);\n  var existingParams = parseQueryString(location.search);\n  var paramsToAdd = (0, _object.dict)({});\n  var keys = Object.keys(params);\n\n  for (var i = 0; i < keys.length; i++) {\n    if (!(0, _object.hasOwn)(existingParams, keys[i])) {\n      paramsToAdd[keys[i]] = params[keys[i]];\n    }\n  }\n\n  return addParamsToUrl(url, paramsToAdd);\n}\n/**\n * Serializes the passed parameter map into a query string with both keys\n * and values encoded.\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\n\n\nfunction serializeQueryString(params) {\n  var s = [];\n\n  for (var k in params) {\n    var v = params[k];\n\n    if (v == null) {\n      continue;\n    } else if ((0, _types.isArray)(v)) {\n      for (var i = 0; i < v.length; i++) {\n        var sv =\n        /** @type {string} */\n        v[i];\n        s.push(encodeURIComponent(k) + \"=\" + encodeURIComponent(sv));\n      }\n    } else {\n      var _sv =\n      /** @type {string} */\n      v;\n      s.push(encodeURIComponent(k) + \"=\" + encodeURIComponent(_sv));\n    }\n  }\n\n  return s.join('&');\n}\n/**\n * Returns `true` if the URL is secure: either HTTPS or localhost (for testing).\n * @param {string|!Location} url\n * @return {boolean}\n */\n\n\nfunction isSecureUrlDeprecated(url) {\n  if (typeof url == 'string') {\n    url = parseUrlDeprecated(url);\n  }\n\n  return url.protocol == 'https:' || url.hostname == 'localhost' || url.hostname == '127.0.0.1' || (0, _string.endsWith)(url.hostname, '.localhost');\n}\n/**\n * Asserts that a given url is HTTPS or protocol relative. It's a user-level\n * assert.\n *\n * Provides an exception for localhost.\n *\n * @param {?string|undefined} urlString\n * @param {!Element|string} elementContext Element where the url was found.\n * @param {string=} sourceName Used for error messages.\n * @return {string}\n */\n\n\nfunction assertHttpsUrl(urlString, elementContext, sourceName) {\n  if (sourceName === void 0) {\n    sourceName = 'source';\n  }\n\n  (0, _log.userAssert)(urlString != null, '%s %s must be available', elementContext, sourceName); // (erwinm, #4560): type cast necessary until #4560 is fixed.\n\n  var theUrlString =\n  /** @type {string} */\n  urlString;\n  (0, _log.userAssert)(isSecureUrlDeprecated(theUrlString) || /^(\\/\\/)/.test(theUrlString), '%s %s must start with ' + '\"https://\" or \"//\" or be relative and served from ' + 'either https or from localhost. Invalid value: %s', elementContext, sourceName, theUrlString);\n  return theUrlString;\n}\n/**\n * Asserts that a given url is an absolute HTTP or HTTPS URL.\n * @param {string} urlString\n * @return {string}\n */\n\n\nfunction assertAbsoluteHttpOrHttpsUrl(urlString) {\n  (0, _log.userAssert)(/^https?\\:/i.test(urlString), 'URL must start with \"http://\" or \"https://\". Invalid value: %s', urlString);\n  return parseUrlDeprecated(urlString).href;\n}\n/**\n * Parses the query string of an URL. This method returns a simple key/value\n * map. If there are duplicate keys the latest value is returned.\n *\n * This function is implemented in a separate file to avoid a circular\n * dependency.\n *\n * @param {string} queryString\n * @return {!JsonObject}\n */\n\n\nfunction parseQueryString(queryString) {\n  return (0, _urlParseQueryString.parseQueryString_)(queryString);\n}\n/**\n * Returns the URL without fragment. If URL doesn't contain fragment, the same\n * string is returned.\n * @param {string} url\n * @return {string}\n */\n\n\nfunction removeFragment(url) {\n  var index = url.indexOf('#');\n\n  if (index == -1) {\n    return url;\n  }\n\n  return url.substring(0, index);\n}\n/**\n * Returns the fragment from the URL. If the URL doesn't contain fragment,\n * the empty string is returned.\n * @param {string} url\n * @return {string}\n */\n\n\nfunction getFragment(url) {\n  var index = url.indexOf('#');\n\n  if (index == -1) {\n    return '';\n  }\n\n  return url.substring(index);\n}\n/**\n * Returns whether the URL has the origin of a proxy.\n * @param {string|!Location} url URL of an AMP document.\n * @return {boolean}\n */\n\n\nfunction isProxyOrigin(url) {\n  if (typeof url == 'string') {\n    url = parseUrlDeprecated(url);\n  }\n\n  return _config.urls.cdnProxyRegex.test(url.origin);\n}\n/**\n * For proxy-origin URLs, returns the serving type. Otherwise, returns null.\n * E.g., 'https://amp-com.cdn.ampproject.org/a/s/amp.com/amp_document.html'\n * returns 'a'.\n * @param {string|!Location} url URL of an AMP document.\n * @return {?string}\n */\n\n\nfunction getProxyServingType(url) {\n  if (typeof url == 'string') {\n    url = parseUrlDeprecated(url);\n  }\n\n  if (!isProxyOrigin(url)) {\n    return null;\n  }\n\n  var path = url.pathname.split('/', 2);\n  return path[1];\n}\n/**\n * Returns whether the URL origin is localhost.\n * @param {string|!Location} url URL of an AMP document.\n * @return {boolean}\n */\n\n\nfunction isLocalhostOrigin(url) {\n  if (typeof url == 'string') {\n    url = parseUrlDeprecated(url);\n  }\n\n  return _config.urls.localhostRegex.test(url.origin);\n}\n/**\n * Returns whether the URL has valid protocol.\n * Deep link protocol is valid, but not javascript etc.\n * @param {string|!Location} url\n * @return {boolean}\n */\n\n\nfunction isProtocolValid(url) {\n  if (!url) {\n    return true;\n  }\n\n  if (typeof url == 'string') {\n    url = parseUrlDeprecated(url);\n  }\n\n  return !INVALID_PROTOCOLS.includes(url.protocol);\n}\n/**\n * Returns a URL without AMP JS parameters.\n * @param {string} url\n * @return {string}\n */\n\n\nfunction removeAmpJsParamsFromUrl(url) {\n  var parsed = parseUrlDeprecated(url);\n  var search = removeAmpJsParamsFromSearch(parsed.search);\n  return parsed.origin + parsed.pathname + search + parsed.hash;\n}\n/**\n * Returns a URL without a query string.\n * @param {string} url\n * @return {string}\n */\n\n\nfunction removeSearch(url) {\n  var index = url.indexOf('?');\n\n  if (index == -1) {\n    return url;\n  }\n\n  var fragment = getFragment(url);\n  return url.substring(0, index) + fragment;\n}\n/**\n * Removes parameters that start with amp js parameter pattern and returns the\n * new search string.\n * @param {string} urlSearch\n * @return {string}\n */\n\n\nfunction removeAmpJsParamsFromSearch(urlSearch) {\n  if (!urlSearch || urlSearch == '?') {\n    return '';\n  }\n\n  var search = urlSearch.replace(AMP_JS_PARAMS_REGEX, '').replace(AMP_GSA_PARAMS_REGEX, '').replace(AMP_R_PARAMS_REGEX, '').replace(AMP_KIT_PARAMS_REGEX, '').replace(GOOGLE_EXPERIMENT_PARAMS_REGEX, '').replace(/^[?&]/, ''); // Removes first ? or &.\n\n  return search ? '?' + search : '';\n}\n/**\n * Removes parameters with param name and returns the new search string.\n * @param {string} urlSearch\n * @param {string} paramName\n * @return {string}\n */\n\n\nfunction removeParamsFromSearch(urlSearch, paramName) {\n  // TODO: reuse the function in removeAmpJsParamsFromSearch. Accept paramNames\n  // as an array.\n  if (!urlSearch || urlSearch == '?') {\n    return '';\n  }\n\n  var paramRegex = new RegExp(\"[?&]\" + paramName + \"=[^&]*\", 'g');\n  var search = urlSearch.replace(paramRegex, '').replace(/^[?&]/, '');\n  return search ? '?' + search : '';\n}\n/**\n * Returns the source URL of an AMP document for documents served\n * on a proxy origin or directly.\n * @param {string|!Location} url URL of an AMP document.\n * @return {string}\n */\n\n\nfunction getSourceUrl(url) {\n  if (typeof url == 'string') {\n    url = parseUrlDeprecated(url);\n  } // Not a proxy URL - return the URL itself.\n\n\n  if (!isProxyOrigin(url)) {\n    return url.href;\n  } // A proxy URL.\n  // Example path that is being matched here.\n  // https://cdn.ampproject.org/c/s/www.origin.com/foo/\n  // The /s/ is optional and signals a secure origin.\n\n\n  var path = url.pathname.split('/');\n  var prefix = path[1];\n  (0, _log.userAssert)(SERVING_TYPE_PREFIX[prefix], 'Unknown path prefix in url %s', url.href);\n  var domainOrHttpsSignal = path[2];\n  var origin = domainOrHttpsSignal == 's' ? 'https://' + decodeURIComponent(path[3]) : 'http://' + decodeURIComponent(domainOrHttpsSignal); // Sanity test that what we found looks like a domain.\n\n  (0, _log.userAssert)(origin.indexOf('.') > 0, 'Expected a . in origin %s', origin);\n  path.splice(1, domainOrHttpsSignal == 's' ? 3 : 2);\n  return origin + path.join('/') + removeAmpJsParamsFromSearch(url.search) + (url.hash || '');\n}\n/**\n * Returns the source origin of an AMP document for documents served\n * on a proxy origin or directly.\n * @param {string|!Location} url URL of an AMP document.\n * @return {string} The source origin of the URL.\n */\n\n\nfunction getSourceOrigin(url) {\n  return parseUrlDeprecated(getSourceUrl(url)).origin;\n}\n/**\n * Returns absolute URL resolved based on the relative URL and the base.\n * @param {string} relativeUrlString\n * @param {string|!Location} baseUrl\n * @return {string}\n */\n\n\nfunction resolveRelativeUrl(relativeUrlString, baseUrl) {\n  if (typeof baseUrl == 'string') {\n    baseUrl = parseUrlDeprecated(baseUrl);\n  }\n\n  if (typeof URL == 'function') {\n    return new URL(relativeUrlString, baseUrl.href).toString();\n  }\n\n  return resolveRelativeUrlFallback_(relativeUrlString, baseUrl);\n}\n/**\n * Fallback for URL resolver when URL class is not available.\n * @param {string} relativeUrlString\n * @param {string|!Location} baseUrl\n * @return {string}\n * @private Visible for testing.\n */\n\n\nfunction resolveRelativeUrlFallback_(relativeUrlString, baseUrl) {\n  if (typeof baseUrl == 'string') {\n    baseUrl = parseUrlDeprecated(baseUrl);\n  }\n\n  relativeUrlString = relativeUrlString.replace(/\\\\/g, '/');\n  var relativeUrl = parseUrlDeprecated(relativeUrlString); // Absolute URL.\n\n  if ((0, _string.startsWith)(relativeUrlString.toLowerCase(), relativeUrl.protocol)) {\n    return relativeUrl.href;\n  } // Protocol-relative URL.\n\n\n  if ((0, _string.startsWith)(relativeUrlString, '//')) {\n    return baseUrl.protocol + relativeUrlString;\n  } // Absolute path.\n\n\n  if ((0, _string.startsWith)(relativeUrlString, '/')) {\n    return baseUrl.origin + relativeUrlString;\n  } // Relative path.\n\n\n  return baseUrl.origin + baseUrl.pathname.replace(/\\/[^/]*$/, '/') + relativeUrlString;\n}\n/**\n * Add \"__amp_source_origin\" query parameter to the URL.\n * @param {!Window} win\n * @param {string} url\n * @return {string}\n */\n\n\nfunction getCorsUrl(win, url) {\n  checkCorsUrl(url);\n  var sourceOrigin = getSourceOrigin(win.location.href);\n  return addParamToUrl(url, SOURCE_ORIGIN_PARAM, sourceOrigin);\n}\n/**\n * Checks if the url has __amp_source_origin and throws if it does.\n * @param {string} url\n */\n\n\nfunction checkCorsUrl(url) {\n  var parsedUrl = parseUrlDeprecated(url);\n  var query = parseQueryString(parsedUrl.search);\n  (0, _log.userAssert)(!(SOURCE_ORIGIN_PARAM in query), 'Source origin is not allowed in %s', url);\n}\n/**\n * Tries to decode a URI component, falling back to opt_fallback (or an empty\n * string)\n *\n * @param {string} component\n * @param {string=} opt_fallback\n * @return {string}\n */\n\n\nfunction tryDecodeUriComponent(component, opt_fallback) {\n  return (0, _urlTryDecodeUriComponent.tryDecodeUriComponent_)(component, opt_fallback);\n}\n\n},{\"./config\":3,\"./log\":8,\"./mode\":10,\"./string\":14,\"./types\":15,\"./url-parse-query-string\":16,\"./url-try-decode-uri-component\":18,\"./utils/lru-cache\":21,\"./utils/object\":22}],20:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.once = once;\n\n/**\n * Copyright 2017 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO(rsimha, #15334): Enable this rule.\n\n/* eslint jsdoc/check-types: 0 */\n\n/**\n * Creates a function that is evaluated only once and returns the cached result\n * subsequently.\n *\n * Please note that `once` only takes the function definition into account,\n * so it will return the same cached value even when the arguments are\n * different.\n *\n * @param {function(...):T} fn\n * @return {function(...):T}\n * @template T\n */\nfunction once(fn) {\n  var evaluated = false;\n  var retValue = null;\n  var callback = fn;\n  return function () {\n    if (!evaluated) {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      retValue = callback.apply(self, args);\n      evaluated = true;\n      callback = null; // GC\n    }\n\n    return retValue;\n  };\n}\n\n},{}],21:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.LruCache = void 0;\n\nvar _log = require(\"../log\");\n\n/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const {string} */\nvar TAG = 'lru-cache';\n/**\n * @template T\n */\n\nvar LruCache =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {number} capacity\n   */\n  function LruCache(capacity) {\n    /** @private @const {number} */\n    this.capacity_ = capacity;\n    /** @private {number} */\n\n    this.size_ = 0;\n    /**\n     * An incrementing counter to define the last access.\n     * @private {number}\n     */\n\n    this.access_ = 0;\n    /** @private {!Object<(number|string), {payload: T, access: number}>} */\n\n    this.cache_ = Object.create(null);\n  }\n  /**\n   * Returns whether key is cached.\n   *\n   * @param {number|string} key\n   * @return {boolean}\n   */\n\n\n  var _proto = LruCache.prototype;\n\n  _proto.has = function has(key) {\n    return !!this.cache_[key];\n  }\n  /**\n   * @param {number|string} key\n   * @return {T} The cached payload.\n   */\n  ;\n\n  _proto.get = function get(key) {\n    var cacheable = this.cache_[key];\n\n    if (cacheable) {\n      cacheable.access = ++this.access_;\n      return cacheable.payload;\n    }\n\n    return undefined;\n  }\n  /**\n   * @param {number|string} key\n   * @param {T} payload The payload to cache.\n   */\n  ;\n\n  _proto.put = function put(key, payload) {\n    if (!this.has(key)) {\n      this.size_++;\n    }\n\n    this.cache_[key] = {\n      payload: payload,\n      access: this.access_\n    };\n    this.evict_();\n  }\n  /**\n   * Evicts the oldest cache entry, if we've exceeded capacity.\n   */\n  ;\n\n  _proto.evict_ = function evict_() {\n    if (this.size_ <= this.capacity_) {\n      return;\n    }\n\n    (0, _log.dev)().warn(TAG, 'Trimming LRU cache');\n    var cache = this.cache_;\n    var oldest = this.access_ + 1;\n    var oldestKey;\n\n    for (var key in cache) {\n      var access = cache[key].access;\n\n      if (access < oldest) {\n        oldest = access;\n        oldestKey = key;\n      }\n    }\n\n    if (oldestKey !== undefined) {\n      delete cache[oldestKey];\n      this.size_--;\n    }\n  };\n\n  return LruCache;\n}();\n\nexports.LruCache = LruCache;\n\n},{\"../log\":8}],22:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.map = map;\nexports.dict = dict;\nexports.hasOwn = hasOwn;\nexports.ownProperty = ownProperty;\nexports.deepMerge = deepMerge;\nexports.omit = omit;\n\nvar _types = require(\"../types\");\n\n/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* @const */\nvar hasOwn_ = Object.prototype.hasOwnProperty;\n/**\n * Returns a map-like object.\n * If opt_initial is provided, copies its own properties into the\n * newly created object.\n * @param {T=} opt_initial This should typically be an object literal.\n * @return {T}\n * @template T\n */\n\nfunction map(opt_initial) {\n  var obj = Object.create(null);\n\n  if (opt_initial) {\n    Object.assign(obj, opt_initial);\n  }\n\n  return obj;\n}\n/**\n * Return an empty JsonObject or makes the passed in object literal\n * an JsonObject.\n * The JsonObject type is just a simple object that is at-dict.\n * See\n * https://github.com/google/closure-compiler/wiki/@struct-and-@dict-Annotations\n * for what a dict is type-wise.\n * The linter enforces that the argument is, in fact, at-dict like.\n * @param {!Object=} opt_initial\n * @return {!JsonObject}\n */\n\n\nfunction dict(opt_initial) {\n  // We do not copy. The linter enforces that the passed in object is a literal\n  // and thus the caller cannot have a reference to it.\n  return (\n    /** @type {!JsonObject} */\n    opt_initial || {}\n  );\n}\n/**\n * Checks if the given key is a property in the map.\n *\n * @param {T}  obj a map like property.\n * @param {string}  key\n * @return {boolean}\n * @template T\n */\n\n\nfunction hasOwn(obj, key) {\n  return hasOwn_.call(obj, key);\n}\n/**\n * Returns obj[key] iff key is obj's own property (is not inherited).\n * Otherwise, returns undefined.\n *\n * @param {Object} obj\n * @param {string} key\n * @return {*}\n */\n\n\nfunction ownProperty(obj, key) {\n  if (hasOwn(obj, key)) {\n    return obj[key];\n  } else {\n    return undefined;\n  }\n}\n/**\n * Deep merges source into target.\n *\n * @param {!Object} target\n * @param {!Object} source\n * @param {number} depth The maximum merge depth. If exceeded, Object.assign\n *                       will be used instead.\n * @return {!Object}\n * @throws {Error} If source contains a circular reference.\n * Note: Only nested objects are deep-merged, primitives and arrays are not.\n */\n\n\nfunction deepMerge(target, source, depth) {\n  if (depth === void 0) {\n    depth = 10;\n  }\n\n  // Keep track of seen objects to detect recursive references.\n  var seen = [];\n  /** @type {!Array<{t: !Object, s: !Object, d: number}>} */\n\n  var queue = [];\n  queue.push({\n    t: target,\n    s: source,\n    d: 0\n  }); // BFS to ensure objects don't have recursive references at shallower depths.\n\n  var _loop = function _loop() {\n    var _queue$shift = queue.shift(),\n        t = _queue$shift.t,\n        s = _queue$shift.s,\n        d = _queue$shift.d;\n\n    if (seen.includes(s)) {\n      throw new Error('Source object has a circular reference.');\n    }\n\n    seen.push(s);\n\n    if (t === s) {\n      return \"continue\";\n    }\n\n    if (d > depth) {\n      Object.assign(t, s);\n      return \"continue\";\n    }\n\n    Object.keys(s).forEach(function (key) {\n      var newValue = s[key]; // Perform a deep merge IFF both target and source have the same key\n      // whose corresponding values are objects.\n\n      if (hasOwn(t, key)) {\n        var oldValue = t[key];\n\n        if ((0, _types.isObject)(newValue) && (0, _types.isObject)(oldValue)) {\n          queue.push({\n            t: oldValue,\n            s: newValue,\n            d: d + 1\n          });\n          return;\n        }\n      }\n\n      t[key] = newValue;\n    });\n  };\n\n  while (queue.length > 0) {\n    var _ret = _loop();\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return target;\n}\n/**\n * @param {!Object} o An object to remove properties from\n * @param {!Array<string>} props A list of properties to remove from the Object\n * @return {!Object} An object with the given properties removed\n */\n\n\nfunction omit(o, props) {\n  return Object.keys(o).reduce(function (acc, key) {\n    if (!props.includes(key)) {\n      acc[key] = o[key];\n    }\n\n    return acc;\n  }, {});\n}\n\n},{\"../types\":15}],23:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.tryResolve = tryResolve;\nexports.some = some;\nexports.LastAddedResolver = exports.Deferred = void 0;\n\n/**\n * Copyright 2016 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Returns a Deferred struct, which holds a pending promise and its associated\n * resolve and reject functions.\n *\n * This is preferred instead of creating a Promise instance to extract the\n * resolve/reject functions yourself:\n *\n * ```\n * // Avoid doing\n * let resolve;\n * const promise = new Promise(res => {\n *   resolve = res;\n * });\n *\n * // Good\n * const deferred = new Deferred();\n * const { promise, resolve } = deferred;\n * ```\n *\n * @template T\n */\nvar Deferred =\n/**\n * Creates an instance of Deferred.\n */\nfunction Deferred() {\n  var resolve, reject;\n  /**\n   * @const {!Promise<T>}\n   */\n\n  this.promise = new\n  /*OK*/\n  Promise(function (res, rej) {\n    resolve = res;\n    reject = rej;\n  });\n  /**\n   * @const {function(T=)}\n   */\n\n  this.resolve = resolve;\n  /**\n   * @const {function(*=)}\n   */\n\n  this.reject = reject;\n};\n/**\n * Creates a promise resolved to the return value of fn.\n * If fn sync throws, it will cause the promise to reject.\n *\n * @param {function():T} fn\n * @return {!Promise<T>}\n * @template T\n */\n\n\nexports.Deferred = Deferred;\n\nfunction tryResolve(fn) {\n  return new Promise(function (resolve) {\n    resolve(fn());\n  });\n}\n/**\n * Returns a promise which resolves if a threshold amount of the given promises\n * resolve, and rejects otherwise.\n * @param {!Array<!Promise>} promises The array of promises to test.\n * @param {number} count The number of promises that must resolve for the\n *     returned promise to resolve.\n * @return {!Promise} A promise that resolves if any of the given promises\n *     resolve, and which rejects otherwise.\n */\n\n\nfunction some(promises, count) {\n  if (count === void 0) {\n    count = 1;\n  }\n\n  return new Promise(function (resolve, reject) {\n    count = Math.max(count, 0);\n    var extra = promises.length - count;\n\n    if (extra < 0) {\n      reject(new Error('not enough promises to resolve'));\n    }\n\n    if (promises.length == 0) {\n      resolve([]);\n    }\n\n    var values = [];\n    var reasons = [];\n\n    var onFulfilled = function onFulfilled(value) {\n      if (values.length < count) {\n        values.push(value);\n      }\n\n      if (values.length == count) {\n        resolve(values);\n      }\n    };\n\n    var onRejected = function onRejected(reason) {\n      if (reasons.length <= extra) {\n        reasons.push(reason);\n      }\n\n      if (reasons.length > extra) {\n        reject(reasons);\n      }\n    };\n\n    for (var i = 0; i < promises.length; i++) {\n      Promise.resolve(promises[i]).then(onFulfilled, onRejected);\n    }\n  });\n}\n/**\n * Resolves with the result of the last promise added.\n * @implements {IThenable}\n */\n\n\nvar LastAddedResolver =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {!Array<!Promise>=} opt_promises\n   */\n  function LastAddedResolver(opt_promises) {\n    var resolve_, reject_;\n    /** @private @const {!Promise} */\n\n    this.promise_ = new Promise(function (resolve, reject) {\n      resolve_ = resolve;\n      reject_ = reject;\n    });\n    /** @private */\n\n    this.resolve_ = resolve_;\n    /** @private */\n\n    this.reject_ = reject_;\n    /** @private */\n\n    this.count_ = 0;\n\n    if (opt_promises) {\n      for (var i = 0; i < opt_promises.length; i++) {\n        this.add(opt_promises[i]);\n      }\n    }\n  }\n  /**\n   * Add a promise to possibly be resolved.\n   * @param {!Promise} promise\n   * @return {!Promise}\n   */\n\n\n  var _proto = LastAddedResolver.prototype;\n\n  _proto.add = function add(promise) {\n    var _this = this;\n\n    var countAtAdd = ++this.count_;\n    Promise.resolve(promise).then(function (result) {\n      if (_this.count_ === countAtAdd) {\n        _this.resolve_(result);\n      }\n    }, function (error) {\n      // Don't follow behavior of Promise.all and Promise.race error so that\n      // this will only reject when most recently added promise fails.\n      if (_this.count_ === countAtAdd) {\n        _this.reject_(error);\n      }\n    });\n    return this.promise_;\n  }\n  /** @override */\n  ;\n\n  _proto.then = function then(opt_resolve, opt_reject) {\n    return this.promise_.then(opt_resolve, opt_reject);\n  };\n\n  return LastAddedResolver;\n}();\n\nexports.LastAddedResolver = LastAddedResolver;\n\n},{}],24:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.cssEscape = cssEscape;\n\n/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */\n\n/**\n * This regex consists of 4 matching capture groups and one (non-matching) fallback:\n *\n * - (\\0), catch the null terminator character so it may be replaced by UTF\n *   Replacement Char\n * - ^(-)$, catch a solitary dash char, so that it may be backslash escaped.\n *   This is a separate capture group so that the legal-chars (group 4) doesn't\n *   capture it first, since that group doesn't need to escape its dash.\n * - ([\\x01-\\x1f\\x7f]|^-?[0-9]), catch a UTF control char, or any leading\n *   number (with an optional leading dash). The control or the number (but not\n *   the leading dash) must be hex-escaped,.\n * - ([\\x80-\\uffff0-9a-zA-Z_-]+), catch legal-chars, with the exception of a\n *   solitary dash, which will already have matched in group 1.\n * - [^], finally, a catch-all that allows us to backslash escape the char.\n *\n * Together, this matches everything necessary for CSS.escape.\n */\nvar regex = /(\\0)|^(-)$|([\\x01-\\x1f\\x7f]|^-?[0-9])|([\\x80-\\uffff0-9a-zA-Z_-]+)|[^]/g;\n\nfunction escaper(match, nil, dash, hexEscape, chars) {\n  // Chars is the legal-chars (group 4) capture\n  if (chars) {\n    return chars;\n  } // Nil is the null terminator (group 1) capture\n\n\n  if (nil) {\n    return \"\\uFFFD\";\n  } // Both UTF control chars, and leading numbers (with optional leading dash)\n  // (group 3) must be backslash escaped with a trailing space.  Funnily, the\n  // leading dash must not be escaped, but the number. :shrug:\n\n\n  if (hexEscape) {\n    return match.slice(0, -1) + '\\\\' + match.slice(-1).charCodeAt(0).toString(16) + ' ';\n  } // Finally, the solitary dash and the catch-all chars require backslash\n  // escaping.\n\n\n  return '\\\\' + match;\n}\n/**\n * https://drafts.csswg.org/cssom/#serialize-an-identifier\n * @param {string} value\n * @return {string}\n */\n\n\nfunction cssEscape(value) {\n  return String(value).replace(regex, escaper);\n}\n\n},{}],25:[function(require,module,exports){\n\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\n/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false Mustache: true*/\nfunction mustacheFactory(mustache) {\n  var objectToString = Object.prototype.toString;\n\n  var isArray = Array.isArray || function isArrayPolyfill(object) {\n    return objectToString.call(object) === '[object Array]';\n  };\n\n  function isFunction(object) {\n    return typeof object === 'function';\n  }\n  /**\n   * More correct typeof string handling array\n   * which normally returns typeof 'object'\n   */\n\n\n  function typeStr(obj) {\n    return isArray(obj) ? 'array' : typeof obj;\n  }\n\n  function escapeRegExp(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n  }\n  /**\n   * Null safe way of checking whether or not an object,\n   * including its prototype, has a given property\n   */\n\n\n  function hasProperty(obj, propName) {\n    return obj != null && typeof obj === 'object' && Object.prototype.hasOwnProperty.call(obj, propName);\n  } // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n\n\n  var regExpTest = RegExp.prototype.test;\n\n  function testRegExp(re, string) {\n    return regExpTest.call(re, string);\n  }\n\n  var nonSpaceRe = /\\S/;\n\n  function isWhitespace(string) {\n    return !testRegExp(nonSpaceRe, string);\n  }\n\n  var entityMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap(s) {\n      return entityMap[s];\n    });\n  }\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var equalsRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n  /**\n   * Breaks up the given `template` string into a tree of tokens. If the `tags`\n   * argument is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n   * course, the default is to use mustaches (i.e. mustache.tags).\n   *\n   * A token is an array with at least 4 elements. The first element is the\n   * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n   * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n   * all text that appears outside a symbol this element is \"text\".\n   *\n   * The second element of a token is its \"value\". For mustache tags this is\n   * whatever else was inside the tag besides the opening symbol. For text tokens\n   * this is the text itself.\n   *\n   * The third and fourth elements of the token are the start and end indices,\n   * respectively, of the token in the original template.\n   *\n   * Tokens that are the root node of a subtree contain two more elements: 1) an\n   * array of tokens in the subtree and 2) the index in the original template at\n   * which the closing tag for that section begins.\n   */\n\n  function parseTemplate(template, tags) {\n    if (!template) return [];\n    var sections = []; // Stack to hold section tokens\n\n    var tokens = []; // Buffer to hold the tokens\n\n    var spaces = []; // Indices of whitespace tokens on the current line\n\n    var hasTag = false; // Is there a {{tag}} on the current line?\n\n    var nonSpace = false; // Is there a non-space char on the current line?\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          delete tokens[spaces.pop()];\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var openingTagRe, closingTagRe, closingCurlyRe;\n\n    function compileTags(tagsToCompile) {\n      if (typeof tagsToCompile === 'string') tagsToCompile = tagsToCompile.split(spaceRe, 2);\n      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2) throw new Error('Invalid tags: ' + tagsToCompile);\n      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n      closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n      closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n    }\n\n    compileTags(tags || mustache.tags);\n    var scanner = new Scanner(template);\n    var start, type, value, chr, token, openSection;\n\n    while (!scanner.eos()) {\n      start = scanner.pos; // Match any text between tags.\n\n      value = scanner.scanUntil(openingTagRe);\n\n      if (value) {\n        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push(['text', chr, start, start + 1]);\n          start += 1; // Check for whitespace on the current line.\n\n          if (chr === '\\n') stripSpace();\n        }\n      } // Match the opening tag.\n\n\n      if (!scanner.scan(openingTagRe)) break;\n      hasTag = true; // Get the tag type.\n\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe); // Get the tag value.\n\n      if (type === '=') {\n        value = scanner.scanUntil(equalsRe);\n        scanner.scan(equalsRe);\n        scanner.scanUntil(closingTagRe);\n      } else if (type === '{') {\n        value = scanner.scanUntil(closingCurlyRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(closingTagRe);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(closingTagRe);\n      } // Match the closing tag.\n\n\n      if (!scanner.scan(closingTagRe)) throw new Error('Unclosed tag at ' + scanner.pos);\n      token = [type, value, start, scanner.pos];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        openSection = sections.pop();\n        if (!openSection) throw new Error('Unopened section \"' + value + '\" at ' + start);\n        if (openSection[1] !== value) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } // ORIGINAL CODE:\n      // else if (type === '=') {\n      //   // Set the tags for the next time around.\n      //   compileTags(value);\n      // }\n      // Fail quitely but do not allow delimiter substitutions. This is\n      // important from the security point of view so that our validators\n      // do not have to parse and interprete all of the mustache's syntax.\n\n    } // Make sure there are no open sections when we're done.\n\n\n    openSection = sections.pop();\n    if (openSection) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n    return nestTokens(squashTokens(tokens));\n  }\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n\n\n  function squashTokens(tokens) {\n    var squashedTokens = [];\n    var token, lastToken;\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          squashedTokens.push(token);\n          lastToken = token;\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n\n\n  function nestTokens(tokens) {\n    var nestedTokens = [];\n    var collector = nestedTokens;\n    var sections = [];\n    var token, section;\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n        case '#':\n        case '^':\n          collector.push(token);\n          sections.push(token);\n          collector = token[4] = [];\n          break;\n\n        case '/':\n          section = sections.pop();\n          section[5] = token[2];\n          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n          break;\n\n        default:\n          collector.push(token);\n      }\n    }\n\n    return nestedTokens;\n  }\n  /**\n   * A simple string scanner that is used by the template parser to find\n   * tokens in template strings.\n   */\n\n\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n\n\n  Scanner.prototype.eos = function eos() {\n    return this.tail === '';\n  };\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n\n\n  Scanner.prototype.scan = function scan(re) {\n    var match = this.tail.match(re);\n    if (!match || match.index !== 0) return '';\n    var string = match[0];\n    this.tail = this.tail.substring(string.length);\n    this.pos += string.length;\n    return string;\n  };\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n\n\n  Scanner.prototype.scanUntil = function scanUntil(re) {\n    var index = this.tail.search(re),\n        match;\n\n    switch (index) {\n      case -1:\n        match = this.tail;\n        this.tail = '';\n        break;\n\n      case 0:\n        match = '';\n        break;\n\n      default:\n        match = this.tail.substring(0, index);\n        this.tail = this.tail.substring(index);\n    }\n\n    this.pos += match.length;\n    return match;\n  };\n  /**\n   * Represents a rendering context by wrapping a view object and\n   * maintaining a reference to the parent context.\n   */\n\n\n  function Context(view, parentContext) {\n    this.view = view;\n    this.cache = {\n      '.': this.view\n    };\n    this.parent = parentContext;\n  }\n  /**\n   * Creates a new context using the given view with this context\n   * as the parent.\n   */\n\n\n  Context.prototype.push = function push(view) {\n    return new Context(view, this);\n  };\n  /**\n   * Returns the value of the given name in this context, traversing\n   * up the context hierarchy if the value is absent in this context's view.\n   */\n\n\n  Context.prototype.lookup = function lookup(name) {\n    var cache = this.cache;\n    var value;\n\n    if (cache.hasOwnProperty(name)) {\n      value = cache[name];\n    } else {\n      var context = this,\n          names,\n          index,\n          lookupHit = false;\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          value = context.view;\n          names = name.split('.');\n          index = 0;\n          /**\n           * Using the dot notion path in `name`, we descend through the\n           * nested objects.\n           *\n           * To be certain that the lookup has been successful, we have to\n           * check if the last object in the path actually has the property\n           * we are looking for. We store the result in `lookupHit`.\n           *\n           * This is specially necessary for when the value has been set to\n           * `undefined` and we want to avoid looking up parent contexts.\n           **/\n\n          while (value != null && index < names.length) {\n            if (!hasProperty(value, names[index])) {\n              value = null;\n              break;\n            }\n\n            if (index === names.length - 1) lookupHit = true;\n            value = value[names[index++]];\n          }\n        } else {\n          if (!hasProperty(context.view, name)) {\n            value = null;\n          } else {\n            value = context.view[name];\n            lookupHit = true;\n          }\n        }\n\n        if (lookupHit) break;\n        context = context.parent;\n      }\n\n      cache[name] = value;\n    }\n\n    if (isFunction(value)) value = value.call(this.view);\n    return value;\n  };\n  /**\n   * A Writer knows how to take a stream of tokens and render them to a\n   * string, given a context. It also maintains a cache of templates to\n   * avoid the need to parse the same template twice.\n   */\n\n\n  function Writer() {\n    this.cache = {};\n  }\n  /**\n   * Clears all cached templates in this writer.\n   */\n\n\n  Writer.prototype.clearCache = function clearCache() {\n    this.cache = {};\n  };\n  /**\n   * Parses and caches the given `template` and returns the array of tokens\n   * that is generated from the parse.\n   */\n\n\n  Writer.prototype.parse = function parse(template, tags) {\n    var cache = this.cache;\n    var tokens = cache[template];\n    if (tokens == null) tokens = cache[template] = parseTemplate(template, tags);\n    return tokens;\n  };\n  /**\n   * High-level method that is used to render the given `template` with\n   * the given `view`.\n   *\n   * The optional `partials` argument may be an object that contains the\n   * names and templates of partials that are used in the template. It may\n   * also be a function that is used to load partial templates on the fly\n   * that takes a single argument: the name of the partial.\n   */\n\n\n  Writer.prototype.render = function render(template, view, partials) {\n    var tokens = this.parse(template);\n    var context = view instanceof Context ? view : new Context(view);\n    return this.renderTokens(tokens, context, partials, template);\n  };\n  /**\n   * Low-level method that renders the given array of `tokens` using\n   * the given `context` and `partials`.\n   *\n   * Note: The `originalTemplate` is only ever used to extract the portion\n   * of the original template that was contained in a higher-order section.\n   * If the template doesn't use higher-order sections, this argument may\n   * be omitted.\n   */\n\n\n  Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate) {\n    var buffer = '';\n    var token, symbol, value;\n\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      value = undefined;\n      token = tokens[i];\n      symbol = token[0];\n      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);else if (symbol === '&') value = this.unescapedValue(token, context);else if (symbol === 'name') value = this.escapedValue(token, context);else if (symbol === 'text') value = this.rawValue(token);\n      if (value !== undefined) buffer += value;\n    }\n\n    return buffer;\n  };\n\n  Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate) {\n    var self = this;\n    var buffer = '';\n    var value = context.lookup(token[1]); // This function is used to render an arbitrary template\n    // in the current context by higher-order sections.\n\n    function subRender(template) {\n      return self.render(template, context, partials);\n    }\n\n    if (!value) return;\n\n    if (isArray(value)) {\n      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n      }\n    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n    } else if (isFunction(value)) {\n      if (typeof originalTemplate !== 'string') throw new Error('Cannot use higher-order sections without the original template'); // Extract the portion of the original template that the section contains.\n\n      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n      if (value != null) buffer += value;\n    } else {\n      buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n    }\n\n    return buffer;\n  };\n\n  Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate) {\n    var value = context.lookup(token[1]); // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n\n    if (!value || isArray(value) && value.length === 0) return this.renderTokens(token[4], context, partials, originalTemplate);\n  };\n\n  Writer.prototype.renderPartial = function renderPartial(token, context, partials) {\n    if (!partials) return;\n    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n    if (value != null) return this.renderTokens(this.parse(value), context, partials, value);\n  };\n\n  Writer.prototype.unescapedValue = function unescapedValue(token, context) {\n    var value = context.lookup(token[1]);\n\n    if (value != null) {\n      if (mustache.sanitizeUnescaped) {\n        return mustache.sanitizeUnescaped(value);\n      }\n\n      return value;\n    }\n  };\n\n  Writer.prototype.escapedValue = function escapedValue(token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null) return mustache.escape(value);\n  };\n\n  Writer.prototype.rawValue = function rawValue(token) {\n    return token[1];\n  };\n\n  mustache.name = 'mustache.js';\n  mustache.version = '2.2.0';\n  mustache.tags = ['{{', '}}']; // All high-level mustache.* functions use this writer.\n\n  var defaultWriter = new Writer();\n  /**\n   * Clears all cached templates in the default writer.\n   */\n\n  mustache.clearCache = function clearCache() {\n    return defaultWriter.clearCache();\n  };\n  /**\n   * Parses and caches the given template in the default writer and returns the\n   * array of tokens it contains. Doing this ahead of time avoids the need to\n   * parse templates on the fly as they are rendered.\n   */\n\n\n  mustache.parse = function parse(template, tags) {\n    return defaultWriter.parse(template, tags);\n  };\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n\n\n  mustache.render = function render(template, view, partials) {\n    if (typeof template !== 'string') {\n      throw new TypeError('Invalid template! Template should be a \"string\" ' + 'but \"' + typeStr(template) + '\" was given as the first ' + 'argument for mustache#render(template, view, partials)');\n    }\n\n    return defaultWriter.render(template, view, partials);\n  }; // This is here for backwards compatibility with 0.4.x.,\n\n  /*eslint-disable */\n  // eslint wants camel cased function name\n\n\n  mustache.to_html = function to_html(template, view, partials, send) {\n    /*eslint-enable*/\n    var result = mustache.render(template, view, partials);\n\n    if (isFunction(send)) {\n      send(result);\n    } else {\n      return result;\n    }\n  }; // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n\n\n  mustache.escape = escapeHtml; // Export the sanitizing function for unescaped values.\n\n  mustache.sanitizeUnescaped = null;\n\n  mustache.setUnescapedSanitizer = function setUnescapedSanitizer(sanitizeUnescaped) {\n    mustache.sanitizeUnescaped = sanitizeUnescaped;\n  }; // Export these mainly for testing, but also for advanced usage.\n\n\n  mustache.Scanner = Scanner;\n  mustache.Context = Context;\n  mustache.Writer = Writer;\n}\n\n;\nvar Mustache = {};\nmustacheFactory(Mustache);\nvar _default = Mustache;\nexports.default = _default;\n\n},{}]},{},[1])\n\n","/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {dict} from '../../../src/utils/object';\nimport {iterateCursor, templateContentClone} from '../../../src/dom';\nimport {purifyHtml, purifyTagsForTripleMustache} from '../../../src/purifier';\nimport mustache from '../../../third_party/mustache/mustache';\n\nconst TAG = 'amp-mustache';\n\nconst BaseTemplate =\n  /** @type {function(new:../../../src/service/template-impl.BaseTemplate)} */ (AMP.BaseTemplate);\n\n/**\n * Implements an AMP template for Mustache.js.\n * See {@link https://github.com/janl/mustache.js/}.\n *\n * @visibleForTesting\n */\nexport class AmpMustache extends BaseTemplate {\n  /**\n   * @param {!Element} element\n   * @param {!Window} win\n   */\n  constructor(element, win) {\n    super(element, win);\n\n    // Unescaped templating (triple mustache) has a special, strict sanitizer.\n    mustache.setUnescapedSanitizer(value =>\n      purifyTagsForTripleMustache(value, this.win.document)\n    );\n  }\n\n  /** @override */\n  compileCallback() {\n    // If viewer is renderTemplate capable, skip the handling of the mustache\n    // templates as its rendering is managed by the viewer. This template will\n    // only be responsible for sanitizing and inserting it into the DOM.\n    if (this.viewerCanRenderTemplates()) {\n      return;\n    }\n    /** @private @const {!JsonObject} */\n    this.nestedTemplates_ = dict();\n\n    /** @private @const {string} */\n    this.template_ = this.initTemplateString_();\n\n    mustache.parse(this.template_, /* tags */ undefined);\n  }\n\n  /**\n   * @private\n   * @return {string}\n   */\n  initTemplateString_() {\n    if (this.element.tagName == 'TEMPLATE') {\n      const content = templateContentClone(this.element);\n      this.processNestedTemplates_(content);\n      const container = this.element.ownerDocument.createElement('div');\n      container.appendChild(content);\n      return container./*OK*/ innerHTML;\n    } else if (this.element.tagName == 'SCRIPT') {\n      return this.element.textContent;\n    }\n\n    return '';\n  }\n\n  /**\n   * Stores and replaces nested templates with custom triple-mustache pointers.\n   *\n   * This prevents the outer-most template from replacing variables in nested\n   * templates. Note that this constrains nested template markup to the more\n   * restrictive sanitization rules of triple-mustache.\n   *\n   * @param {!DocumentFragment} content\n   */\n  processNestedTemplates_(content) {\n    const templates = content.querySelectorAll('template');\n    iterateCursor(templates, (template, index) => {\n      const key = `__AMP_NESTED_TEMPLATE_${index}`;\n\n      // Store the nested template markup, keyed by index.\n      this.nestedTemplates_[key] = template./*OK*/ outerHTML;\n\n      // Replace the markup with a pointer.\n      const pointer = this.element.ownerDocument.createTextNode(`{{{${key}}}}`);\n      template.parentNode.replaceChild(pointer, template);\n    });\n  }\n\n  /** @override */\n  setHtml(html) {\n    return this.purifyAndSetHtml_(html);\n  }\n\n  /** @override */\n  render(data) {\n    let mustacheData = data;\n    // Also render any nested templates.\n    if (typeof data === 'object') {\n      mustacheData = Object.assign({}, data, this.nestedTemplates_);\n    }\n    const html = mustache.render(\n      this.template_,\n      mustacheData,\n      /* partials */ undefined\n    );\n    return this.purifyAndSetHtml_(html);\n  }\n\n  /**\n   *\n   * @param {string} html\n   * @return {!Element}\n   * @private\n   */\n  purifyAndSetHtml_(html) {\n    const body = purifyHtml(html, this.win.document);\n    // TODO(choumx): Remove innerHTML usage once DOMPurify bug is fixed.\n    // https://github.com/cure53/DOMPurify/pull/295\n    const root = this.win.document.createElement('div');\n    root./*OK*/ innerHTML = body./*OK*/ innerHTML;\n    return this.unwrap(root);\n  }\n}\n\nAMP.extension(TAG, '0.2', function(AMP) {\n  AMP.registerTemplate(TAG, AmpMustache);\n});\n","var freeze$1 = Object.freeze || function (x) {\n  return x;\n};\n\nvar html = freeze$1(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n// SVG\nvar svg = freeze$1(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'audio', 'canvas', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'video', 'view', 'vkern']);\n\nvar svgFilters = freeze$1(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\nvar mathMl = freeze$1(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\nvar text = freeze$1(['#text']);\n\nvar freeze$2 = Object.freeze || function (x) {\n  return x;\n};\n\nvar html$1 = freeze$2(['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'coords', 'crossorigin', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'integrity', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);\n\nvar svg$1 = freeze$2(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\nvar mathMl$1 = freeze$2(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\nvar xml = freeze$2(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\nvar hasOwnProperty = Object.hasOwnProperty;\nvar setPrototypeOf = Object.setPrototypeOf;\n\nvar _ref$1 = typeof Reflect !== 'undefined' && Reflect;\nvar apply$1 = _ref$1.apply;\n\nif (!apply$1) {\n  apply$1 = function apply(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n\n/* Add properties to a lookup table */\nfunction addToSet(set, array) {\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  var l = array.length;\n  while (l--) {\n    var element = array[l];\n    if (typeof element === 'string') {\n      var lcElement = element.toLowerCase();\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!Object.isFrozen(array)) {\n          array[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n\n/* Shallow clone an object */\nfunction clone(object) {\n  var newObject = {};\n\n  var property = void 0;\n  for (property in object) {\n    if (apply$1(hasOwnProperty, object, [property])) {\n      newObject[property] = object[property];\n    }\n  }\n\n  return newObject;\n}\n\nvar seal = Object.seal || function (x) {\n  return x;\n};\n\nvar MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nvar ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\nvar DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\nvar ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nvar IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nvar IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nvar ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205f\\u3000]/g // eslint-disable-line no-control-regex\n);\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar _ref = typeof Reflect !== 'undefined' && Reflect;\nvar apply = _ref.apply;\n\nvar arraySlice = Array.prototype.slice;\nvar freeze = Object.freeze;\n\nvar getGlobal = function getGlobal() {\n  return typeof window === 'undefined' ? null : window;\n};\n\nif (!apply) {\n  apply = function apply(fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n * @param {Document} document The document object (to determine policy name suffix)\n * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n * are not supported).\n */\nvar _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n  if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  var suffix = null;\n  var ATTR_NAME = 'data-tt-policy-suffix';\n  if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n    suffix = document.currentScript.getAttribute(ATTR_NAME);\n  }\n\n  var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML: function createHTML(html$$1) {\n        return html$$1;\n      }\n    });\n  } catch (error) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n    return null;\n  }\n};\n\nfunction createDOMPurify() {\n  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n  var DOMPurify = function DOMPurify(root) {\n    return createDOMPurify(root);\n  };\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  DOMPurify.version = '2.0.2';\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  DOMPurify.removed = [];\n\n  if (!window || !window.document || window.document.nodeType !== 9) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n\n    return DOMPurify;\n  }\n\n  var originalDocument = window.document;\n  var useDOMParser = false;\n  var removeSVGAttr = false;\n  var removeTitle = false;\n\n  var document = window.document;\n  var DocumentFragment = window.DocumentFragment,\n      HTMLTemplateElement = window.HTMLTemplateElement,\n      Node = window.Node,\n      NodeFilter = window.NodeFilter,\n      _window$NamedNodeMap = window.NamedNodeMap,\n      NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n      Text = window.Text,\n      Comment = window.Comment,\n      DOMParser = window.DOMParser,\n      TrustedTypes = window.TrustedTypes;\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n\n  if (typeof HTMLTemplateElement === 'function') {\n    var template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  var trustedTypesPolicy = _createTrustedTypesPolicy(TrustedTypes, originalDocument);\n  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';\n\n  var _document = document,\n      implementation = _document.implementation,\n      createNodeIterator = _document.createNodeIterator,\n      getElementsByTagName = _document.getElementsByTagName,\n      createDocumentFragment = _document.createDocumentFragment;\n  var importNode = originalDocument.importNode;\n\n\n  var hooks = {};\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && document.documentMode !== 9;\n\n  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n      ERB_EXPR$$1 = ERB_EXPR,\n      DATA_ATTR$$1 = DATA_ATTR,\n      ARIA_ATTR$$1 = ARIA_ATTR,\n      IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n\n  var ALLOWED_TAGS = null;\n  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(svgFilters), _toConsumableArray(mathMl), _toConsumableArray(text)));\n\n  /* Allowed attribute names */\n  var ALLOWED_ATTR = null;\n  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(mathMl$1), _toConsumableArray(xml)));\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  var FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  var FORBID_ATTR = null;\n\n  /* Decide if ARIA attributes are okay */\n  var ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  var ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Output should be safe for jQuery's $() factory? */\n  var SAFE_FOR_JQUERY = false;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  var SAFE_FOR_TEMPLATES = false;\n\n  /* Decide if document with <html>... should be returned */\n  var WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  var SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  var FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  var RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  var RETURN_DOM_FRAGMENT = false;\n\n  /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n   * `Node` is imported into the current `Document`. If this flag is not enabled the\n   * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n   * DOMPurify. */\n  var RETURN_DOM_IMPORT = false;\n\n  /* Try to return a Trusted Type object instead of a string, retrun a string in\n   * case Trusted Types are not supported  */\n  var RETURN_TRUSTED_TYPE = false;\n\n  /* Output should be free from DOM clobbering attacks? */\n  var SANITIZE_DOM = true;\n\n  /* Keep element content when removing element? */\n  var KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  var IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  var USE_PROFILES = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  var FORBID_CONTENTS = addToSet({}, ['audio', 'colgroup', 'head', 'math', 'script', 'style', 'template', 'thead', 'svg', 'video']);\n\n  /* Tags that are safe for data: URIs */\n  var DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image']);\n\n  /* Attributes safe for values like \"javascript:\" */\n  var URI_SAFE_ATTRIBUTES = null;\n  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n  /* Keep a reference to config to pass to hooks */\n  var CONFIG = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  var formElement = document.createElement('form');\n\n  /**\n   * _parseConfig\n   *\n   * @param  {Object} cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  var _parseConfig = function _parseConfig(cfg) {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n      cfg = {};\n    }\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n    URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet({}, cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n    FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n    FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n    USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    SAFE_FOR_JQUERY = cfg.SAFE_FOR_JQUERY || false; // Default false\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT || false; // Default false\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n\n    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(text)));\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, html);\n        addToSet(ALLOWED_ATTR, html$1);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, svg);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, svgFilters);\n        addToSet(ALLOWED_ATTR, svg$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, mathMl);\n        addToSet(ALLOWED_ATTR, mathMl$1);\n        addToSet(ALLOWED_ATTR, xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param  {Node} node a DOM node\n   */\n  var _forceRemove = function _forceRemove(node) {\n    DOMPurify.removed.push({ element: node });\n    try {\n      node.parentNode.removeChild(node);\n    } catch (error) {\n      node.outerHTML = emptyHTML;\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param  {String} name an Attribute name\n   * @param  {Node} node a DOM node\n   */\n  var _removeAttribute = function _removeAttribute(name, node) {\n    try {\n      DOMPurify.removed.push({\n        attribute: node.getAttributeNode(name),\n        from: node\n      });\n    } catch (error) {\n      DOMPurify.removed.push({\n        attribute: null,\n        from: node\n      });\n    }\n\n    node.removeAttribute(name);\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param  {String} dirty a string of dirty markup\n   * @return {Document} a DOM, filled with the dirty markup\n   */\n  var _initDocument = function _initDocument(dirty) {\n    /* Create a HTML document */\n    var doc = void 0;\n    var leadingWhitespace = void 0;\n\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      var matches = dirty.match(/^[\\s]+/);\n      leadingWhitespace = matches && matches[0];\n      if (leadingWhitespace) {\n        dirty = dirty.slice(leadingWhitespace.length);\n      }\n    }\n\n    /* Use DOMParser to workaround Firefox bug (see comment below) */\n    if (useDOMParser) {\n      try {\n        doc = new DOMParser().parseFromString(dirty, 'text/html');\n      } catch (error) {}\n    }\n\n    /* Remove title to fix a mXSS bug in older MS Edge */\n    if (removeTitle) {\n      addToSet(FORBID_TAGS, ['title']);\n    }\n\n    /* Otherwise use createHTMLDocument, because DOMParser is unsafe in\n    Safari (see comment below) */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createHTMLDocument('');\n      var _doc = doc,\n          body = _doc.body;\n\n      body.parentNode.removeChild(body.parentNode.firstElementChild);\n      body.outerHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n    }\n\n    if (leadingWhitespace) {\n      doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);\n    }\n\n    /* Work on whole document or just its body */\n    return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n  };\n\n  // Firefox uses a different parser for innerHTML rather than\n  // DOMParser (see https://bugzilla.mozilla.org/show_bug.cgi?id=1205631)\n  // which means that you *must* use DOMParser, otherwise the output may\n  // not be safe if used in a document.write context later.\n  //\n  // So we feature detect the Firefox bug and use the DOMParser if necessary.\n  //\n  // Chrome 77 and other versions ship an mXSS bug that caused a bypass to\n  // happen. We now check for the mXSS trigger and react accordingly.\n  if (DOMPurify.isSupported) {\n    (function () {\n      try {\n        var doc = _initDocument('<svg><p><textarea><img src=\"</textarea><img src=x abc=1//\">');\n        if (doc.querySelector('svg img')) {\n          useDOMParser = true;\n        }\n      } catch (error) {}\n    })();\n\n    (function () {\n      try {\n        var doc = _initDocument('<x/><title>&lt;/title&gt;&lt;img&gt;');\n        if (doc.querySelector('title').innerHTML.match(/<\\/title/)) {\n          removeTitle = true;\n        }\n      } catch (error) {}\n    })();\n\n    (function () {\n      try {\n        var doc = _initDocument('<svg></p></svg>');\n        if (doc.querySelector('svg p')) {\n          removeSVGAttr = true;\n        }\n      } catch (error) {}\n    })();\n  }\n\n  /**\n   * _createIterator\n   *\n   * @param  {Document} root document/fragment to create iterator for\n   * @return {Iterator} iterator instance\n   */\n  var _createIterator = function _createIterator(root) {\n    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {\n      return NodeFilter.FILTER_ACCEPT;\n    }, false);\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param  {Node} elm element to check for clobbering attacks\n   * @return {Boolean} true if clobbered, false if safe\n   */\n  var _isClobbered = function _isClobbered(elm) {\n    if (elm instanceof Text || elm instanceof Comment) {\n      return false;\n    }\n\n    if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function') {\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * _isNode\n   *\n   * @param  {Node} obj object to check whether it's a DOM node\n   * @return {Boolean} true is object is a DOM node\n   */\n  var _isNode = function _isNode(obj) {\n    return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? obj instanceof Node : obj && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';\n  };\n\n  /**\n   * _executeHook\n   * Execute user configurable hooks\n   *\n   * @param  {String} entryPoint  Name of the hook's entry point\n   * @param  {Node} currentNode node to work on with the hook\n   * @param  {Object} data additional hook parameters\n   */\n  var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n    if (!hooks[entryPoint]) {\n      return;\n    }\n\n    hooks[entryPoint].forEach(function (hook) {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  };\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   *\n   * @param   {Node} currentNode to check for permission to exist\n   * @return  {Boolean} true if node was killed, false if left alive\n   */\n  // eslint-disable-next-line complexity\n  var _sanitizeElements = function _sanitizeElements(currentNode) {\n    var content = void 0;\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeElements', currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let's check the element's type and name */\n    var tagName = currentNode.nodeName.toLowerCase();\n\n    /* Execute a hook if present */\n    _executeHook('uponSanitizeElement', currentNode, {\n      tagName: tagName,\n      allowedTags: ALLOWED_TAGS\n    });\n\n    /* Remove element if anything forbids its presence */\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      /* Keep content except for black-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName] && typeof currentNode.insertAdjacentHTML === 'function') {\n        try {\n          var htmlToInsert = currentNode.innerHTML;\n          currentNode.insertAdjacentHTML('AfterEnd', trustedTypesPolicy ? trustedTypesPolicy.createHTML(htmlToInsert) : htmlToInsert);\n        } catch (error) {}\n      }\n\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove in case a noscript/noembed XSS is suspected */\n    if (tagName === 'noscript' && currentNode.innerHTML.match(/<\\/noscript/i)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    if (tagName === 'noembed' && currentNode.innerHTML.match(/<\\/noembed/i)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove in case an mXSS is suspected */\n    if (currentNode.namespaceURI && currentNode.namespaceURI.match(/svg|math/i) && currentNode.textContent && currentNode.textContent.match(new RegExp('</' + tagName, 'i'))) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Convert markup to cover jQuery behavior */\n    if (SAFE_FOR_JQUERY && !currentNode.firstElementChild && (!currentNode.content || !currentNode.content.firstElementChild) && /</g.test(currentNode.textContent)) {\n      DOMPurify.removed.push({ element: currentNode.cloneNode() });\n      if (currentNode.innerHTML) {\n        currentNode.innerHTML = currentNode.innerHTML.replace(/</g, '&lt;');\n      } else {\n        currentNode.innerHTML = currentNode.textContent.replace(/</g, '&lt;');\n      }\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n      content = content.replace(MUSTACHE_EXPR$$1, ' ');\n      content = content.replace(ERB_EXPR$$1, ' ');\n      if (currentNode.textContent !== content) {\n        DOMPurify.removed.push({ element: currentNode.cloneNode() });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeElements', currentNode, null);\n\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param  {string} lcTag Lowercase tag name of containing element.\n   * @param  {string} lcName Lowercase attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n    /* Make sure attribute cannot clobber */\n    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (ALLOW_DATA_ATTR && DATA_ATTR$$1.test(lcName)) {\n      // This attribute is safe\n    } else if (ALLOW_ARIA_ATTR && ARIA_ATTR$$1.test(lcName)) {\n      // This attribute is safe\n      /* Otherwise, check the name is permitted */\n    } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      return false;\n\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) {\n      // This attribute is safe\n      /* Check no script, data or unknown possibly unsafe URI\n        unless we know URI values are safe for that attribute */\n    } else if (IS_ALLOWED_URI$$1.test(value.replace(ATTR_WHITESPACE$$1, ''))) {\n      // This attribute is safe\n      /* Keep image data URIs alive if src/xlink:href is allowed */\n      /* Further prevent gadget XSS for dynamically built script tags */\n    } else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && value.indexOf('data:') === 0 && DATA_URI_TAGS[lcTag]) {\n      // This attribute is safe\n      /* Allow unknown protocols: This provides support for links that\n        are handled by protocol handlers which may be unknown ahead of\n        time, e.g. fb:, spotify: */\n    } else if (ALLOW_UNKNOWN_PROTOCOLS && !IS_SCRIPT_OR_DATA$$1.test(value.replace(ATTR_WHITESPACE$$1, ''))) {\n      // This attribute is safe\n      /* Check for binary attributes */\n      // eslint-disable-next-line no-negated-condition\n    } else if (!value) {\n      // Binary attributes are safe at this point\n      /* Anything else, presume unsafe, do not add it back */\n    } else {\n      return false;\n    }\n\n    return true;\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param  {Node} currentNode to sanitize\n   */\n  // eslint-disable-next-line complexity\n  var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n    var attr = void 0;\n    var value = void 0;\n    var lcName = void 0;\n    var idAttr = void 0;\n    var l = void 0;\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n    var attributes = currentNode.attributes;\n\n    /* Check if we have attributes; if not we might have a text node */\n\n    if (!attributes) {\n      return;\n    }\n\n    var hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR\n    };\n    l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      attr = attributes[l];\n      var _attr = attr,\n          name = _attr.name,\n          namespaceURI = _attr.namespaceURI;\n\n      value = attr.value.trim();\n      lcName = name.toLowerCase();\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n      value = hookEvent.attrValue;\n\n      /* Check for possible Chrome mXSS */\n      if (removeSVGAttr && value.match(/<\\//)) {\n        _forceRemove(currentNode);\n      }\n\n      /* Remove attribute */\n      // Safari (iOS + Mac), last tested v8.0.5, crashes if you try to\n      // remove a \"name\" attribute from an <img> tag that has an \"id\"\n      // attribute at the time.\n      if (lcName === 'name' && currentNode.nodeName === 'IMG' && attributes.id) {\n        idAttr = attributes.id;\n        attributes = apply(arraySlice, attributes, []);\n        _removeAttribute('id', currentNode);\n        _removeAttribute(name, currentNode);\n        if (attributes.indexOf(idAttr) > l) {\n          currentNode.setAttribute('id', idAttr.value);\n        }\n      } else if (\n      // This works around a bug in Safari, where input[type=file]\n      // cannot be dynamically set after type has been removed\n      currentNode.nodeName === 'INPUT' && lcName === 'type' && value === 'file' && hookEvent.keepAttr && (ALLOWED_ATTR[lcName] || !FORBID_ATTR[lcName])) {\n        continue;\n      } else {\n        // This avoids a crash in Safari v9.0 with double-ids.\n        // The trick is to first set the id to be empty and then to\n        // remove the attribute\n        if (name === 'id') {\n          currentNode.setAttribute(name, '');\n        }\n\n        _removeAttribute(name, currentNode);\n      }\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        value = value.replace(MUSTACHE_EXPR$$1, ' ');\n        value = value.replace(ERB_EXPR$$1, ' ');\n      }\n\n      /* Is `value` valid for this attribute? */\n      var lcTag = currentNode.nodeName.toLowerCase();\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        continue;\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      try {\n        if (namespaceURI) {\n          currentNode.setAttributeNS(namespaceURI, name, value);\n        } else {\n          /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n          currentNode.setAttribute(name, value);\n        }\n\n        DOMPurify.removed.pop();\n      } catch (error) {}\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeAttributes', currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param  {DocumentFragment} fragment to iterate over recursively\n   */\n  var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n    var shadowNode = void 0;\n    var shadowIterator = _createIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n    while (shadowNode = shadowIterator.nextNode()) {\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(shadowNode)) {\n        continue;\n      }\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(shadowNode);\n    }\n\n    /* Execute a hook if present */\n    _executeHook('afterSanitizeShadowDOM', fragment, null);\n  };\n\n  /**\n   * Sanitize\n   * Public method providing core sanitation functionality\n   *\n   * @param {String|Node} dirty string or DOM node\n   * @param {Object} configuration object\n   */\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty, cfg) {\n    var body = void 0;\n    var importedNode = void 0;\n    var currentNode = void 0;\n    var oldNode = void 0;\n    var returnNode = void 0;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    if (!dirty) {\n      dirty = '<!-->';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      // eslint-disable-next-line no-negated-condition\n      if (typeof dirty.toString !== 'function') {\n        throw new TypeError('toString is not a function');\n      } else {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw new TypeError('dirty is not a string, aborting');\n        }\n      }\n    }\n\n    /* Check we can run. Otherwise fall back or ignore */\n    if (!DOMPurify.isSupported) {\n      if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n        if (typeof dirty === 'string') {\n          return window.toStaticHTML(dirty);\n        }\n\n        if (_isNode(dirty)) {\n          return window.toStaticHTML(dirty.outerHTML);\n        }\n      }\n\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    if (IN_PLACE) {\n      /* No special handling necessary for in-place sanitization */\n    } else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!-->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && RETURN_TRUSTED_TYPE && dirty.indexOf('<') === -1) {\n        return trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : emptyHTML;\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while (currentNode = nodeIterator.nextNode()) {\n      /* Fix IE's strange behavior with manipulated textNodes #89 */\n      if (currentNode.nodeType === 3 && currentNode === oldNode) {\n        continue;\n      }\n\n      /* Sanitize tags and elements */\n      if (_sanitizeElements(currentNode)) {\n        continue;\n      }\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n\n      /* Check attributes, sanitize if necessary */\n      _sanitizeAttributes(currentNode);\n\n      oldNode = currentNode;\n    }\n\n    oldNode = null;\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (RETURN_DOM_IMPORT) {\n        /* AdoptNode() is not used because internal state is not reset\n               (e.g. the past names map of a HTMLFormElement), this is safe\n               in theory but we would rather not risk another attack vector.\n               The state that is cloned by importNode() is explicitly defined\n               by the specs. */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      serializedHTML = serializedHTML.replace(MUSTACHE_EXPR$$1, ' ');\n      serializedHTML = serializedHTML.replace(ERB_EXPR$$1, ' ');\n    }\n\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n  };\n\n  /**\n   * Public method to set the configuration once\n   * setConfig\n   *\n   * @param {Object} cfg configuration object\n   */\n  DOMPurify.setConfig = function (cfg) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  /**\n   * Public method to remove the configuration\n   * clearConfig\n   *\n   */\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  /**\n   * Public method to check if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   * isValidAttribute\n   *\n   * @param  {string} tag Tag name of containing element.\n   * @param  {string} attr Attribute name.\n   * @param  {string} value Attribute value.\n   * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n   */\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    var lcTag = tag.toLowerCase();\n    var lcName = attr.toLowerCase();\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  /**\n   * AddHook\n   * Public method to add DOMPurify hooks\n   *\n   * @param {String} entryPoint entry point for the hook to add\n   * @param {Function} hookFunction function to execute\n   */\n  DOMPurify.addHook = function (entryPoint, hookFunction) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n\n    hooks[entryPoint] = hooks[entryPoint] || [];\n    hooks[entryPoint].push(hookFunction);\n  };\n\n  /**\n   * RemoveHook\n   * Public method to remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if more are present)\n   *\n   * @param {String} entryPoint entry point for the hook to remove\n   */\n  DOMPurify.removeHook = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint].pop();\n    }\n  };\n\n  /**\n   * RemoveHooks\n   * Public method to remove all DOMPurify hooks at a given entryPoint\n   *\n   * @param  {String} entryPoint entry point for the hooks to remove\n   */\n  DOMPurify.removeHooks = function (entryPoint) {\n    if (hooks[entryPoint]) {\n      hooks[entryPoint] = [];\n    }\n  };\n\n  /**\n   * RemoveAllHooks\n   * Public method to remove all DOMPurify hooks\n   *\n   */\n  DOMPurify.removeAllHooks = function () {\n    hooks = {};\n  };\n\n  return DOMPurify;\n}\n\nvar purify = createDOMPurify();\n\nexport default purify;\n//# sourceMappingURL=purify.es.js.map\n","/**\n * Copyright 2016 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Allows for runtime configuration. Internally, the runtime should\n * use the src/config.js module for various constants. We can use the\n * AMP_CONFIG global to translate user-defined configurations to this\n * module.\n * @type {!Object<string, string>}\n */\nconst env = self.AMP_CONFIG || {};\n\nconst thirdPartyFrameRegex =\n  typeof env['thirdPartyFrameRegex'] == 'string'\n    ? new RegExp(env['thirdPartyFrameRegex'])\n    : env['thirdPartyFrameRegex'];\n\nconst cdnProxyRegex =\n  typeof env['cdnProxyRegex'] == 'string'\n    ? new RegExp(env['cdnProxyRegex'])\n    : env['cdnProxyRegex'];\n\n/** @type {!Object<string, string|boolean|RegExp|Array<RegExp>>} */\nexport const urls = {\n  thirdParty: env['thirdPartyUrl'] || 'https://3p.ampproject.net',\n  thirdPartyFrameHost: env['thirdPartyFrameHost'] || 'ampproject.net',\n  thirdPartyFrameRegex: thirdPartyFrameRegex || /^d-\\d+\\.ampproject\\.net$/,\n  cdn: env['cdnUrl'] || 'https://cdn.ampproject.org',\n  /* Note that cdnProxyRegex is only ever checked against origins\n   * (proto://host[:port]) so does not need to consider path\n   */\n  cdnProxyRegex:\n    cdnProxyRegex || /^https:\\/\\/([a-zA-Z0-9_-]+\\.)?cdn\\.ampproject\\.org$/,\n  localhostRegex: /^https?:\\/\\/localhost(:\\d+)?$/,\n  errorReporting:\n    env['errorReportingUrl'] || 'https://amp-error-reporting.appspot.com/r',\n  localDev: env['localDev'] || false,\n  /**\n   * These domains are trusted with more sensitive viewer operations such as\n   * propagating the referrer. If you believe your domain should be here,\n   * file the issue on GitHub to discuss. The process will be similar\n   * (but somewhat more stringent) to the one described in the [3p/README.md](\n   * https://github.com/ampproject/amphtml/blob/master/3p/README.md)\n   *\n   * {!Array<!RegExp>}\n   */\n  trustedViewerHosts: [\n    /(^|\\.)google\\.(com?|[a-z]{2}|com?\\.[a-z]{2}|cat)$/,\n    /(^|\\.)gmail\\.dev$/,\n  ],\n};\n\nexport const config = {\n  urls,\n};\n","/**\n * Copyright 2019 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {cssEscape} from '../third_party/css-escape/css-escape';\nimport {devAssert} from './log';\n\n/**\n * Asserts that name is just an alphanumeric word, and does not contain\n * advanced CSS selector features like attributes, psuedo-classes, class names,\n * nor ids.\n * @param {string} name\n */\nexport function assertIsName(name) {\n  devAssert(/^[\\w-]+$/.test(name));\n}\n\n/**\n * @type {boolean|undefined}\n */\nlet scopeSelectorSupported;\n\n/**\n * @param {boolean|undefined} val\n * @visibleForTesting\n */\nexport function setScopeSelectorSupportedForTesting(val) {\n  scopeSelectorSupported = val;\n}\n\n/**\n * Test that the :scope selector is supported and behaves correctly.\n * @param {!Element} el\n * @return {boolean}\n */\nexport function isScopeSelectorSupported(el) {\n  if (scopeSelectorSupported !== undefined) {\n    return scopeSelectorSupported;\n  }\n\n  return (scopeSelectorSupported = testScopeSelector(el));\n}\n\n/**\n * Test that the :scope selector is supported and behaves correctly.\n * @param {!Element} el\n * @return {boolean}\n */\nfunction testScopeSelector(el) {\n  try {\n    const doc = el.ownerDocument;\n    const testElement = doc.createElement('div');\n    const testChild = doc.createElement('div');\n    testElement.appendChild(testChild);\n    // NOTE(cvializ, #12383): Firefox's implementation is incomplete,\n    // therefore we test actual functionality of`:scope` as well.\n    return testElement./*OK*/ querySelector(':scope div') === testChild;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Prefixes a selector for ancestor selection. Splits in subselectors and\n * applies prefix to each.\n *\n * e.g.\n * ```\n *   prependSelectorsWith('div', '.i-amphtml-scoped');\n *   // => '.i-amphtml-scoped div'\n *   prependSelectorsWith('div, ul', ':scope');\n *   // => ':scope div, :scope ul'\n *   prependSelectorsWith('div, ul', 'article >');\n *   // => 'article > div, article > ul'\n * ```\n *\n * @param {string} selector\n * @param {string} distribute\n * @return {string}\n */\nexport function prependSelectorsWith(selector, distribute) {\n  return selector.replace(/^|,/g, `$&${distribute} `);\n}\n\n/**\n * Escapes an ident (ID or a class name) to be used as a CSS selector.\n *\n * See https://drafts.csswg.org/cssom/#serialize-an-identifier.\n *\n * @param {string} ident\n * @return {string}\n */\nexport function escapeCssSelectorIdent(ident) {\n  return cssEscape(ident);\n}\n\n/**\n * Escapes an ident in a way that can be used by :nth-child() psuedo-class.\n *\n * See https://github.com/w3c/csswg-drafts/issues/2306.\n *\n * @param {string|number} ident\n * @return {string}\n */\nexport function escapeCssSelectorNth(ident) {\n  const escaped = String(ident);\n  // Ensure it doesn't close the nth-child psuedo class.\n  devAssert(escaped.indexOf(')') === -1);\n  return escaped;\n}\n","/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Deferred} from './utils/promise';\nimport {\n  assertIsName,\n  isScopeSelectorSupported,\n  prependSelectorsWith,\n} from './css';\nimport {dev, devAssert} from './log';\nimport {dict} from './utils/object';\nimport {includes, startsWith} from './string';\nimport {toWin} from './types';\n\nconst HTML_ESCAPE_CHARS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '`': '&#x60;',\n};\nconst HTML_ESCAPE_REGEX = /(&|<|>|\"|'|`)/g;\n\n/** @const {string} */\nexport const UPGRADE_TO_CUSTOMELEMENT_PROMISE = '__AMP_UPG_PRM';\n\n/** @const {string} */\nexport const UPGRADE_TO_CUSTOMELEMENT_RESOLVER = '__AMP_UPG_RES';\n\n/**\n * Waits until the child element is constructed. Once the child is found, the\n * callback is executed.\n * @param {!Element} parent\n * @param {function(!Element):boolean} checkFunc\n * @param {function()} callback\n */\nexport function waitForChild(parent, checkFunc, callback) {\n  if (checkFunc(parent)) {\n    callback();\n    return;\n  }\n  /** @const {!Window} */\n  const win = toWin(parent.ownerDocument.defaultView);\n  if (win.MutationObserver) {\n    /** @const {MutationObserver} */\n    const observer = new win.MutationObserver(() => {\n      if (checkFunc(parent)) {\n        observer.disconnect();\n        callback();\n      }\n    });\n    observer.observe(parent, {childList: true});\n  } else {\n    /** @const {number} */\n    const interval = win.setInterval(() => {\n      if (checkFunc(parent)) {\n        win.clearInterval(interval);\n        callback();\n      }\n    }, /* milliseconds */ 5);\n  }\n}\n\n/**\n * Waits until the child element is constructed. Once the child is found, the\n * promise is resolved.\n * @param {!Element} parent\n * @param {function(!Element):boolean} checkFunc\n * @return {!Promise}\n */\nexport function waitForChildPromise(parent, checkFunc) {\n  return new Promise(resolve => {\n    waitForChild(parent, checkFunc, resolve);\n  });\n}\n\n/**\n * Waits for document's body to be available and ready.\n * @param {!Document} doc\n * @param {function()} callback\n */\nexport function waitForBodyOpen(doc, callback) {\n  waitForChild(doc.documentElement, () => !!doc.body, callback);\n}\n\n/**\n * Waits for document's body to be available.\n * @param {!Document} doc\n * @return {!Promise}\n */\nexport function waitForBodyOpenPromise(doc) {\n  return new Promise(resolve => waitForBodyOpen(doc, resolve));\n}\n\n/**\n * Removes the element.\n * @param {!Element} element\n */\nexport function removeElement(element) {\n  if (element.parentElement) {\n    element.parentElement.removeChild(element);\n  }\n}\n\n/**\n * Removes all child nodes of the specified element.\n * @param {!Element} parent\n */\nexport function removeChildren(parent) {\n  while (parent.firstChild) {\n    parent.removeChild(parent.firstChild);\n  }\n}\n\n/**\n * Copies all children nodes of element \"from\" to element \"to\". Child nodes\n * are deeply cloned. Notice, that this method should be used with care and\n * preferably on smaller subtrees.\n * @param {!Element} from\n * @param {!Element|!DocumentFragment} to\n */\nexport function copyChildren(from, to) {\n  const frag = to.ownerDocument.createDocumentFragment();\n  for (let n = from.firstChild; n; n = n.nextSibling) {\n    frag.appendChild(n.cloneNode(true));\n  }\n  to.appendChild(frag);\n}\n\n/**\n * Insert the element in the root after the element named after or\n * if that is null at the beginning.\n * @param {!Element|!ShadowRoot} root\n * @param {!Element} element\n * @param {?Node} after\n */\nexport function insertAfterOrAtStart(root, element, after) {\n  const before = after ? after.nextSibling : root.firstChild;\n  root.insertBefore(element, before);\n}\n\n/**\n * Add attributes to an element.\n * @param {!Element} element\n * @param {!JsonObject<string, string>} attributes\n * @return {!Element} created element\n */\nexport function addAttributesToElement(element, attributes) {\n  for (const attr in attributes) {\n    element.setAttribute(attr, attributes[attr]);\n  }\n  return element;\n}\n\n/**\n * Create a new element on document with specified tagName and attributes.\n * @param {!Document} doc\n * @param {string} tagName\n * @param {!JsonObject<string, string>} attributes\n * @return {!Element} created element\n */\nexport function createElementWithAttributes(doc, tagName, attributes) {\n  const element = doc.createElement(tagName);\n  return addAttributesToElement(element, attributes);\n}\n\n/**\n * Returns true if node is connected (attached).\n * @param {!Node} node\n * @return {boolean}\n * @see https://dom.spec.whatwg.org/#connected\n */\nexport function isConnectedNode(node) {\n  const connected = node.isConnected;\n  if (connected !== undefined) {\n    return connected;\n  }\n\n  // \"An element is connected if its shadow-including root is a document.\"\n  let n = node;\n  do {\n    n = rootNodeFor(n);\n    if (n.host) {\n      n = n.host;\n    } else {\n      break;\n    }\n  } while (true);\n  return n.nodeType === Node.DOCUMENT_NODE;\n}\n\n/**\n * Returns the root for a given node. Does not cross shadow DOM boundary.\n * @param {!Node} node\n * @return {!Node}\n */\nexport function rootNodeFor(node) {\n  if (Node.prototype.getRootNode) {\n    // Type checker says `getRootNode` may return null.\n    return node.getRootNode() || node;\n  }\n  let n;\n  // Check isShadowRoot() is only needed for the polyfill case.\n  for (n = node; !!n.parentNode && !isShadowRoot(n); n = n.parentNode) {}\n  return n;\n}\n\n/**\n * Determines if value is actually a `ShadowRoot` node.\n * @param {*} value\n * @return {boolean}\n */\nexport function isShadowRoot(value) {\n  // TODO(#22733): remove in preference to dom's `rootNodeFor`.\n  if (!value) {\n    return false;\n  }\n  // Node.nodeType == DOCUMENT_FRAGMENT to speed up the tests. Unfortunately,\n  // nodeType of DOCUMENT_FRAGMENT is used currently for ShadowRoot nodes.\n  if (value.tagName == 'I-AMPHTML-SHADOW-ROOT') {\n    return true;\n  }\n  return (\n    value.nodeType == /* DOCUMENT_FRAGMENT */ 11 &&\n    Object.prototype.toString.call(value) === '[object ShadowRoot]'\n  );\n}\n\n/**\n * Finds the closest element that satisfies the callback from this element\n * up the DOM subtree.\n * @param {!Element} element\n * @param {function(!Element):boolean} callback\n * @param {Element=} opt_stopAt optional elemnt to stop the search at.\n * @return {?Element}\n */\nexport function closest(element, callback, opt_stopAt) {\n  for (let el = element; el && el !== opt_stopAt; el = el.parentElement) {\n    if (callback(el)) {\n      return el;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds the closest node that satisfies the callback from this node\n * up the DOM subtree.\n * @param {!Node} node\n * @param {function(!Node):boolean} callback\n * @return {?Node}\n */\nexport function closestNode(node, callback) {\n  for (let n = node; n; n = n.parentNode) {\n    if (callback(n)) {\n      return n;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds the closest ancestor element with the specified selector from this\n * element.\n * @param {!Element} element\n * @param {string} selector\n * @return {?Element} closest ancestor if found.\n */\nexport function closestAncestorElementBySelector(element, selector) {\n  if (element.closest) {\n    return element.closest(selector);\n  }\n\n  return closest(element, el => {\n    return matches(el, selector);\n  });\n}\n\n/**\n * Finds all ancestor elements that satisfy predicate.\n * @param {!Element} child\n * @param {function(!Element):boolean} predicate\n * @return {!Array<!Element>}\n */\nexport function ancestorElements(child, predicate) {\n  const ancestors = [];\n  for (\n    let ancestor = child.parentElement;\n    ancestor;\n    ancestor = ancestor.parentElement\n  ) {\n    if (predicate(ancestor)) {\n      ancestors.push(ancestor);\n    }\n  }\n  return ancestors;\n}\n\n/**\n * Finds all ancestor elements that has the specified tag name.\n * @param {!Element} child\n * @param {string} tagName\n * @return {!Array<!Element>}\n */\nexport function ancestorElementsByTag(child, tagName) {\n  assertIsName(tagName);\n  tagName = tagName.toUpperCase();\n  return ancestorElements(child, el => {\n    return el.tagName == tagName;\n  });\n}\n\n/**\n * Finds the first child element that satisfies the callback.\n * @param {!Element} parent\n * @param {function(!Element):boolean} callback\n * @return {?Element}\n */\nexport function childElement(parent, callback) {\n  for (\n    let child = parent.firstElementChild;\n    child;\n    child = child.nextElementSibling\n  ) {\n    if (callback(child)) {\n      return child;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds all child elements that satisfy the callback.\n * @param {!Element} parent\n * @param {function(!Element):boolean} callback\n * @return {!Array<!Element>}\n */\nexport function childElements(parent, callback) {\n  const children = [];\n  for (\n    let child = parent.firstElementChild;\n    child;\n    child = child.nextElementSibling\n  ) {\n    if (callback(child)) {\n      children.push(child);\n    }\n  }\n  return children;\n}\n\n/**\n * Finds the last child element that satisfies the callback.\n * @param {!Element} parent\n * @param {function(!Element):boolean} callback\n * @return {?Element}\n */\nexport function lastChildElement(parent, callback) {\n  for (\n    let child = parent.lastElementChild;\n    child;\n    child = child.previousElementSibling\n  ) {\n    if (callback(child)) {\n      return child;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds all child nodes that satisfy the callback.\n * These nodes can include Text, Comment and other child nodes.\n * @param {!Node} parent\n * @param {function(!Node):boolean} callback\n * @return {!Array<!Node>}\n */\nexport function childNodes(parent, callback) {\n  const nodes = [];\n  for (let child = parent.firstChild; child; child = child.nextSibling) {\n    if (callback(child)) {\n      nodes.push(child);\n    }\n  }\n  return nodes;\n}\n\n/**\n * Finds the first child element that has the specified attribute.\n * @param {!Element} parent\n * @param {string} attr\n * @return {?Element}\n */\nexport function childElementByAttr(parent, attr) {\n  assertIsName(attr);\n  return /*OK*/ scopedQuerySelector(parent, `> [${attr}]`);\n}\n\n/**\n * Finds the last child element that has the specified attribute.\n * @param {!Element} parent\n * @param {string} attr\n * @return {?Element}\n */\nexport function lastChildElementByAttr(parent, attr) {\n  assertIsName(attr);\n  return lastChildElement(parent, el => {\n    return el.hasAttribute(attr);\n  });\n}\n\n/**\n * Finds all child elements that has the specified attribute.\n * @param {!Element} parent\n * @param {string} attr\n * @return {!NodeList<!Element>}\n */\nexport function childElementsByAttr(parent, attr) {\n  assertIsName(attr);\n  return /*OK*/ scopedQuerySelectorAll(parent, `> [${attr}]`);\n}\n\n/**\n * Finds the first child element that has the specified tag name.\n * @param {!Element} parent\n * @param {string} tagName\n * @return {?Element}\n */\nexport function childElementByTag(parent, tagName) {\n  assertIsName(tagName);\n  return /*OK*/ scopedQuerySelector(parent, `> ${tagName}`);\n}\n\n/**\n * Finds all child elements with the specified tag name.\n * @param {!Element} parent\n * @param {string} tagName\n * @return {!NodeList<!Element>}\n */\nexport function childElementsByTag(parent, tagName) {\n  assertIsName(tagName);\n  return /*OK*/ scopedQuerySelectorAll(parent, `> ${tagName}`);\n}\n\n/**\n * Checks if the given element matches the selector\n * @param  {!Element} el The element to verify\n * @param  {string} selector The selector to check against\n * @return {boolean} True if the element matched the selector. False otherwise.\n */\nexport function matches(el, selector) {\n  const matcher =\n    el.matches ||\n    el.webkitMatchesSelector ||\n    el.mozMatchesSelector ||\n    el.msMatchesSelector ||\n    el.oMatchesSelector;\n  if (matcher) {\n    return matcher.call(el, selector);\n  }\n  return false; // IE8 always returns false.\n}\n\n/**\n * Finds the first descendant element with the specified name.\n * @param {!Element|!Document|!ShadowRoot} element\n * @param {string} tagName\n * @return {?Element}\n */\nexport function elementByTag(element, tagName) {\n  assertIsName(tagName);\n  return element./*OK*/ querySelector(tagName);\n}\n\n/**\n * Finds all elements that matche `selector`, scoped inside `root`\n * for user-agents that do not support native scoping.\n *\n * This method isn't required for modern builds, can be removed.\n *\n * @param {!Element} root\n * @param {string} selector\n * @return {!NodeList<!Element>}\n */\nfunction scopedQuerySelectionFallback(root, selector) {\n  const unique = 'i-amphtml-scoped';\n  root.classList.add(unique);\n  const scopedSelector = prependSelectorsWith(selector, `.${unique}`);\n  const elements = root./*OK*/ querySelectorAll(scopedSelector);\n  root.classList.remove(unique);\n  return elements;\n}\n\n/**\n * Finds the first element that matches `selector`, scoped inside `root`.\n * Note: in IE, this causes a quick mutation of the element's class list.\n * @param {!Element} root\n * @param {string} selector\n * @return {?Element}\n */\nexport function scopedQuerySelector(root, selector) {\n  if (isScopeSelectorSupported(root)) {\n    return root./*OK*/ querySelector(prependSelectorsWith(selector, ':scope'));\n  }\n\n  // Only IE.\n  const fallbackResult = scopedQuerySelectionFallback(root, selector);\n  return fallbackResult[0] === undefined ? null : fallbackResult[0];\n}\n\n/**\n * Finds every element that matches `selector`, scoped inside `root`.\n * Note: in IE, this causes a quick mutation of the element's class list.\n * @param {!Element} root\n * @param {string} selector\n * @return {!NodeList<!Element>}\n */\nexport function scopedQuerySelectorAll(root, selector) {\n  if (isScopeSelectorSupported(root)) {\n    return root./*OK*/ querySelectorAll(\n      prependSelectorsWith(selector, ':scope')\n    );\n  }\n\n  // Only IE.\n  return scopedQuerySelectionFallback(root, selector);\n}\n\n/**\n * Returns element data-param- attributes as url parameters key-value pairs.\n * e.g. data-param-some-attr=value -> {someAttr: value}.\n * @param {!Element} element\n * @param {function(string):string=} opt_computeParamNameFunc to compute the\n *    parameter name, get passed the camel-case parameter name.\n * @param {!RegExp=} opt_paramPattern Regex pattern to match data attributes.\n * @return {!JsonObject}\n */\nexport function getDataParamsFromAttributes(\n  element,\n  opt_computeParamNameFunc,\n  opt_paramPattern\n) {\n  const computeParamNameFunc = opt_computeParamNameFunc || (key => key);\n  const {dataset} = element;\n  const params = dict();\n  const paramPattern = opt_paramPattern ? opt_paramPattern : /^param(.+)/;\n  for (const key in dataset) {\n    const matches = key.match(paramPattern);\n    if (matches) {\n      const param = matches[1][0].toLowerCase() + matches[1].substr(1);\n      params[computeParamNameFunc(param)] = dataset[key];\n    }\n  }\n  return params;\n}\n\n/**\n * Whether the element have a next node in the document order.\n * This means either:\n *  a. The element itself has a nextSibling.\n *  b. Any of the element ancestors has a nextSibling.\n * @param {!Element} element\n * @param {?Node} opt_stopNode\n * @return {boolean}\n */\nexport function hasNextNodeInDocumentOrder(element, opt_stopNode) {\n  let currentElement = element;\n  do {\n    if (currentElement.nextSibling) {\n      return true;\n    }\n  } while (\n    (currentElement = currentElement.parentNode) &&\n    currentElement != opt_stopNode\n  );\n  return false;\n}\n\n/**\n * Returns a clone of the content of a template element.\n *\n * Polyfill to replace .content access for browsers that do not support\n * HTMLTemplateElements natively.\n *\n * @param {!HTMLTemplateElement|!Element} template\n * @return {!DocumentFragment}\n */\nexport function templateContentClone(template) {\n  if ('content' in template) {\n    return template.content.cloneNode(true);\n  } else {\n    const content = template.ownerDocument.createDocumentFragment();\n    copyChildren(template, content);\n    return content;\n  }\n}\n\n/**\n * Iterate over an array-like.\n * Test cases: https://jsbench.github.io/#f638cacc866a1b2d6e517e6cfa900d6b\n * @param {!IArrayLike<T>} iterable\n * @param {function(T, number)} cb\n * @template T\n */\nexport function iterateCursor(iterable, cb) {\n  const {length} = iterable;\n  for (let i = 0; i < length; i++) {\n    cb(iterable[i], i);\n  }\n}\n\n/**\n * This method wraps around window's open method. It first tries to execute\n * `open` call with the provided target and if it fails, it retries the call\n * with the `_top` target. This is necessary given that in some embedding\n * scenarios, such as iOS' WKWebView, navigation to `_blank` and other targets\n * is blocked by default.\n *\n * @param {!Window} win\n * @param {string} url\n * @param {string} target\n * @param {string=} opt_features\n * @return {?Window}\n */\nexport function openWindowDialog(win, url, target, opt_features) {\n  // Try first with the specified target. If we're inside the WKWebView or\n  // a similar environments, this method is expected to fail by default for\n  // all targets except `_top`.\n  let res;\n  try {\n    res = win.open(url, target, opt_features);\n  } catch (e) {\n    dev().error('DOM', 'Failed to open url on target: ', target, e);\n  }\n\n  // Then try with `_top` target.\n  if (!res && target != '_top' && !includes(opt_features || '', 'noopener')) {\n    res = win.open(url, '_top');\n  }\n  return res;\n}\n\n/**\n * Whether the element is a script tag with application/json type.\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isJsonScriptTag(element) {\n  return (\n    element.tagName == 'SCRIPT' &&\n    element.hasAttribute('type') &&\n    element.getAttribute('type').toUpperCase() == 'APPLICATION/JSON'\n  );\n}\n\n/**\n * Whether the element is a script tag with application/json type.\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isJsonLdScriptTag(element) {\n  return (\n    element.tagName == 'SCRIPT' &&\n    element.getAttribute('type').toUpperCase() == 'APPLICATION/LD+JSON'\n  );\n}\n\n/**\n * Whether the page's direction is right to left or not.\n * @param {!Document} doc\n * @return {boolean}\n */\nexport function isRTL(doc) {\n  const dir =\n    doc.body.getAttribute('dir') ||\n    doc.documentElement.getAttribute('dir') ||\n    'ltr';\n  return dir == 'rtl';\n}\n\n/**\n * Escapes `<`, `>` and other HTML charcaters with their escaped forms.\n * @param {string} text\n * @return {string}\n */\nexport function escapeHtml(text) {\n  if (!text) {\n    return text;\n  }\n  return text.replace(HTML_ESCAPE_REGEX, escapeHtmlChar);\n}\n\n/**\n * @param {string} c\n * @return {string}\n */\nfunction escapeHtmlChar(c) {\n  return HTML_ESCAPE_CHARS[c];\n}\n\n/**\n * Tries to focus on the given element; fails silently if browser throws an\n * exception.\n * @param {!Element} element\n */\nexport function tryFocus(element) {\n  try {\n    element./*OK*/ focus();\n  } catch (e) {\n    // IE <= 7 may throw exceptions when focusing on hidden items.\n  }\n}\n\n/**\n * Whether the given window is in an iframe or not.\n * @param {!Window} win\n * @return {boolean}\n */\nexport function isIframed(win) {\n  return win.parent && win.parent != win;\n}\n\n/**\n * Determines if this element is an AMP element\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isAmpElement(element) {\n  const tag = element.tagName;\n  // Use prefix to recognize AMP element. This is necessary because stub\n  // may not be attached yet.\n  return (\n    startsWith(tag, 'AMP-') &&\n    // Some \"amp-*\" elements are not really AMP elements. :smh:\n    !(tag == 'AMP-STICKY-AD-TOP-PADDING' || tag == 'AMP-BODY')\n  );\n}\n\n/**\n * Return a promise that resolve when an AMP element upgrade from HTMLElement\n * to CustomElement\n * @param {!Element} element\n * @return {!Promise<!Element>}\n */\nexport function whenUpgradedToCustomElement(element) {\n  devAssert(isAmpElement(element), 'element is not AmpElement');\n  if (element.createdCallback) {\n    // Element already is CustomElement;\n    return Promise.resolve(element);\n  }\n  // If Element is still HTMLElement, wait for it to upgrade to customElement\n  // Note: use pure string to avoid obfuscation between versions.\n  if (!element[UPGRADE_TO_CUSTOMELEMENT_PROMISE]) {\n    const deferred = new Deferred();\n    element[UPGRADE_TO_CUSTOMELEMENT_PROMISE] = deferred.promise;\n    element[UPGRADE_TO_CUSTOMELEMENT_RESOLVER] = deferred.resolve;\n  }\n\n  return element[UPGRADE_TO_CUSTOMELEMENT_PROMISE];\n}\n\n/**\n * Replacement for `Element.requestFullscreen()` method.\n * https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullscreen\n * @param {!Element} element\n */\nexport function fullscreenEnter(element) {\n  const requestFs =\n    element.requestFullscreen ||\n    element.requestFullScreen ||\n    element.webkitRequestFullscreen ||\n    element.webkitEnterFullscreen ||\n    element.msRequestFullscreen ||\n    element.mozRequestFullScreen;\n  if (requestFs) {\n    requestFs.call(element);\n  }\n}\n\n/**\n * Replacement for `Document.exitFullscreen()` method.\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/exitFullscreen\n * @param {!Element} element\n */\nexport function fullscreenExit(element) {\n  const elementBoundExit =\n    element.cancelFullScreen ||\n    element.exitFullscreen ||\n    element.webkitExitFullscreen ||\n    element.webkitCancelFullScreen ||\n    element.mozCancelFullScreen ||\n    element.msExitFullscreen;\n  if (elementBoundExit) {\n    elementBoundExit.call(element);\n    return;\n  }\n  const {ownerDocument} = element;\n  if (!ownerDocument) {\n    return;\n  }\n  const docBoundExit =\n    ownerDocument.cancelFullScreen ||\n    ownerDocument.exitFullscreencancelFullScreen ||\n    ownerDocument.webkitExitFullscreencancelFullScreen ||\n    ownerDocument.webkitCancelFullScreencancelFullScreen ||\n    ownerDocument.mozCancelFullScreencancelFullScreen ||\n    ownerDocument.msExitFullscreen;\n  if (docBoundExit) {\n    docBoundExit.call(ownerDocument);\n  }\n}\n\n/**\n * Replacement for `Document.fullscreenElement`.\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/fullscreenElement\n * @param {!Element} element\n * @return {boolean}\n */\nexport function isFullscreenElement(element) {\n  const {webkitDisplayingFullscreen} = element;\n  if (webkitDisplayingFullscreen !== undefined) {\n    return webkitDisplayingFullscreen;\n  }\n  const {ownerDocument} = element;\n  if (!ownerDocument) {\n    return false;\n  }\n  const fullscreenElement =\n    ownerDocument.fullscreenElement ||\n    ownerDocument.webkitFullscreenElement ||\n    ownerDocument.mozFullScreenElement ||\n    ownerDocument.webkitCurrentFullScreenElement;\n  return fullscreenElement == element;\n}\n\n/**\n * Returns true if node is not disabled.\n *\n * IE8 can return false positives, see {@link matches}.\n * @param {!Element} element\n * @return {boolean}\n * @see https://www.w3.org/TR/html5/forms.html#concept-fe-disabled\n */\nexport function isEnabled(element) {\n  return !(element.disabled || matches(element, ':disabled'));\n}\n\n/**\n * A sorting comparator that sorts elements in DOM tree order.\n * A first sibling is sorted to be before its nextSibling.\n * A parent node is sorted to be before a child.\n * See https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n *\n * @param {!Element} element1\n * @param {!Element} element2\n * @return {number}\n */\nexport function domOrderComparator(element1, element2) {\n  if (element1 === element2) {\n    return 0;\n  }\n\n  const pos = element1.compareDocumentPosition(element2);\n  const precedingOrContains =\n    Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINS;\n\n  // if fe2 is preceding or contains fe1 then, fe1 is after fe2\n  if (pos & precedingOrContains) {\n    return 1;\n  }\n\n  // if fe2 is following or contained by fe1, then fe1 is before fe2\n  return -1;\n}\n\n/**\n * Like `Element.prototype.toggleAttribute`. This either toggles an attribute\n * on by adding an attribute with an empty value, or toggles it off by removing\n * the attribute. This does not mutate the element if the new state matches\n * the existing state.\n * @param {!Element} element An element to toggle the attribute for.\n * @param {string} name The name of the attribute.\n * @param {boolean=} forced Whether the attribute should be forced on/off. If\n *    not specified, it will be toggled from the current state.\n * @return {boolean} Whether or not the element now has the attribute.\n */\nexport function toggleAttribute(element, name, forced) {\n  const hasAttribute = element.hasAttribute(name);\n  const enabled = forced !== undefined ? forced : !hasAttribute;\n\n  if (enabled !== hasAttribute) {\n    if (enabled) {\n      element.setAttribute(name, '');\n    } else {\n      element.removeAttribute(name);\n    }\n  }\n\n  return enabled;\n}\n\n/**\n * @param {!Window} win\n * @return {number} The width of the vertical scrollbar, in pixels.\n */\nexport function getVerticalScrollbarWidth(win) {\n  const {documentElement} = win.document;\n  const windowWidth = win./*OK*/ innerWidth;\n  const documentWidth = documentElement./*OK*/ clientWidth;\n  return windowWidth - documentWidth;\n}\n","/**\n * Copyright 2019 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Checks that the document is of an AMP format type.\n * @param {!Array<string>} formats\n * @param {!Document} doc\n * @return {boolean}\n */\nfunction isAmpFormatType(formats, doc) {\n  const html = doc.documentElement;\n  const isFormatType = formats.some(format => html.hasAttribute(format));\n  return isFormatType;\n}\n\n/**\n * @param {!Document} doc\n * @return {boolean}\n */\nexport function isAmp4Email(doc) {\n  return isAmpFormatType(['⚡4email', 'amp4email'], doc);\n}\n\n/**\n * @param {!Document} doc\n * @return {boolean}\n */\nexport function isAmphtml(doc) {\n  return isAmpFormatType(['⚡', 'amp'], doc);\n}\n","/**\n * Copyright 2019 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Returns the internal AMP runtime version. Note that this is not the RTV,\n * which is a prefix and the runtime version.\n *\n * The call sites for this function are replaced with a compile time constant\n * string.\n *\n * @return {string}\n */\nexport function internalRuntimeVersion() {\n  return '$internalRuntimeVersion$';\n}\n","/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getMode} from './mode';\nimport {getModeObject} from './mode-object';\nimport {internalRuntimeVersion} from './internal-version';\nimport {isArray, isEnumValue} from './types';\nimport {once} from './utils/function';\nimport {urls} from './config';\n\nconst noop = () => {};\n\n/**\n * Triple zero width space.\n *\n * This is added to user error messages, so that we can later identify\n * them, when the only thing that we have is the message. This is the\n * case in many browsers when the global exception handler is invoked.\n *\n * @const {string}\n */\nexport const USER_ERROR_SENTINEL = '\\u200B\\u200B\\u200B';\n\n/**\n * Four zero width space.\n *\n * @const {string}\n */\nexport const USER_ERROR_EMBED_SENTINEL = '\\u200B\\u200B\\u200B\\u200B';\n\n/**\n * @param {string} message\n * @return {boolean} Whether this message was a user error.\n */\nexport function isUserErrorMessage(message) {\n  return message.indexOf(USER_ERROR_SENTINEL) >= 0;\n}\n\n/**\n * @param {string} message\n * @return {boolean} Whether this message was a a user error from an iframe embed.\n */\nexport function isUserErrorEmbed(message) {\n  return message.indexOf(USER_ERROR_EMBED_SENTINEL) >= 0;\n}\n\n/**\n * @enum {number}\n * @private Visible for testing only.\n */\nexport const LogLevel = {\n  OFF: 0,\n  ERROR: 1,\n  WARN: 2,\n  INFO: 3,\n  FINE: 4,\n};\n\n/**\n * Sets reportError function. Called from error.js to break cyclic\n * dependency.\n * @param {function(*, !Element=)|undefined} fn\n */\nexport function setReportError(fn) {\n  self.__AMP_REPORT_ERROR = fn;\n}\n\n/**\n * @type {!LogLevel|undefined}\n * @private\n */\nlet levelOverride_ = undefined;\n\n/**\n * @param {!LogLevel} level\n */\nexport function overrideLogLevel(level) {\n  levelOverride_ = level;\n}\n\n/**\n * Prefixes `internalRuntimeVersion` with the `01` channel signifier (for prod.) for\n * extracted message URLs.\n * (Specific channel is irrelevant: message tables are invariant on internal version.)\n * @return {string}\n */\nconst messageUrlRtv = () => `01${internalRuntimeVersion()}`;\n\n/**\n * Gets a URL to display a message on amp.dev.\n * @param {string} id\n * @param {!Array} interpolatedParts\n * @return {string}\n */\nconst externalMessageUrl = (id, interpolatedParts) =>\n  interpolatedParts.reduce(\n    (prefix, arg) => `${prefix}&s[]=${messageArgToEncodedComponent(arg)}`,\n    `https://log.amp.dev/?v=${messageUrlRtv()}&id=${encodeURIComponent(id)}`\n  );\n\n/**\n * URL to simple log messages table JSON file, which contains an Object<string, string>\n * which maps message id to full message template.\n * @return {string}\n */\nconst externalMessagesSimpleTableUrl = () =>\n  `${urls.cdn}/rtv/${messageUrlRtv()}/log-messages.simple.json`;\n\n/**\n * @param {*} arg\n * @return {string}\n */\nconst messageArgToEncodedComponent = arg =>\n  encodeURIComponent(String(elementStringOrPassthru(arg)));\n\n/**\n * Logging class. Use of sentinel string instead of a boolean to check user/dev\n * errors because errors could be rethrown by some native code as a new error,\n * and only a message would survive. Also, some browser don’t support a 5th\n * error object argument in window.onerror. List of supporting browser can be\n * found here:\n * https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html\n * @final\n * @private Visible for testing only.\n */\nexport class Log {\n  /**\n   * opt_suffix will be appended to error message to identify the type of the\n   * error message. We can't rely on the error object to pass along the type\n   * because some browsers do not have this param in its window.onerror API.\n   * See:\n   * https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror.html\n   *\n   * @param {!Window} win\n   * @param {function(!./mode.ModeDef):!LogLevel} levelFunc\n   * @param {string=} opt_suffix\n   */\n  constructor(win, levelFunc, opt_suffix = '') {\n    /**\n     * In tests we use the main test window instead of the iframe where\n     * the tests runs because only the former is relayed to the console.\n     * @const {!Window}\n     */\n    this.win = getMode().test && win.__AMP_TEST_IFRAME ? win.parent : win;\n\n    /** @private @const {function(!./mode.ModeDef):!LogLevel} */\n    this.levelFunc_ = levelFunc;\n\n    /** @private @const {!LogLevel} */\n    this.level_ = this.defaultLevel_();\n\n    /** @private @const {string} */\n    this.suffix_ = opt_suffix;\n\n    /** @private {?JsonObject} */\n    this.messages_ = null;\n\n    this.fetchExternalMessagesOnce_ = once(() => {\n      win\n        .fetch(externalMessagesSimpleTableUrl())\n        .then(response => response.json(), noop)\n        .then(opt_messages => {\n          if (opt_messages) {\n            this.messages_ = /** @type {!JsonObject} */ (opt_messages);\n          }\n        });\n    });\n  }\n\n  /**\n   * @return {!LogLevel}\n   * @private\n   */\n  getLevel_() {\n    return levelOverride_ !== undefined ? levelOverride_ : this.level_;\n  }\n\n  /**\n   * @return {!LogLevel}\n   * @private\n   */\n  defaultLevel_() {\n    // No console - can't enable logging.\n    if (!this.win.console || !this.win.console.log) {\n      return LogLevel.OFF;\n    }\n\n    // Logging has been explicitly disabled.\n    if (getMode().log == '0') {\n      return LogLevel.OFF;\n    }\n\n    // Logging is enabled for tests directly.\n    if (getMode().test && this.win.ENABLE_LOG) {\n      return LogLevel.FINE;\n    }\n\n    // LocalDev by default allows INFO level, unless overriden by `#log`.\n    if (getMode().localDev && !getMode().log) {\n      return LogLevel.INFO;\n    }\n\n    // Delegate to the specific resolver.\n    return this.levelFunc_(getModeObject());\n  }\n\n  /**\n   * @param {string} tag\n   * @param {string} level\n   * @param {!Array} messages\n   */\n  msg_(tag, level, messages) {\n    if (this.getLevel_() != LogLevel.OFF) {\n      let fn = this.win.console.log;\n      if (level == 'ERROR') {\n        fn = this.win.console.error || fn;\n      } else if (level == 'INFO') {\n        fn = this.win.console.info || fn;\n      } else if (level == 'WARN') {\n        fn = this.win.console.warn || fn;\n      }\n      const args = this.maybeExpandMessageArgs_(messages);\n      // Prefix console message with \"[tag]\".\n      const prefix = `[${tag}]`;\n      if (typeof args[0] === 'string') {\n        // Prepend string to avoid breaking string substitutions e.g. %s.\n        args[0] = prefix + ' ' + args[0];\n      } else {\n        args.unshift(prefix);\n      }\n      fn.apply(this.win.console, args);\n    }\n  }\n\n  /**\n   * Whether the logging is enabled.\n   * @return {boolean}\n   */\n  isEnabled() {\n    return this.getLevel_() != LogLevel.OFF;\n  }\n\n  /**\n   * Reports a fine-grained message.\n   * @param {string} tag\n   * @param {...*} var_args\n   */\n  fine(tag, var_args) {\n    if (this.getLevel_() >= LogLevel.FINE) {\n      this.msg_(tag, 'FINE', Array.prototype.slice.call(arguments, 1));\n    }\n  }\n\n  /**\n   * Reports a informational message.\n   * @param {string} tag\n   * @param {...*} var_args\n   */\n  info(tag, var_args) {\n    if (this.getLevel_() >= LogLevel.INFO) {\n      this.msg_(tag, 'INFO', Array.prototype.slice.call(arguments, 1));\n    }\n  }\n\n  /**\n   * Reports a warning message.\n   * @param {string} tag\n   * @param {...*} var_args\n   */\n  warn(tag, var_args) {\n    if (this.getLevel_() >= LogLevel.WARN) {\n      this.msg_(tag, 'WARN', Array.prototype.slice.call(arguments, 1));\n    }\n  }\n\n  /**\n   * Reports an error message. If the logging is disabled, the error is rethrown\n   * asynchronously.\n   * @param {string} tag\n   * @param {...*} var_args\n   * @return {!Error|undefined}\n   * @private\n   */\n  error_(tag, var_args) {\n    if (this.getLevel_() >= LogLevel.ERROR) {\n      this.msg_(tag, 'ERROR', Array.prototype.slice.call(arguments, 1));\n    } else {\n      const error = createErrorVargs.apply(\n        null,\n        Array.prototype.slice.call(arguments, 1)\n      );\n      this.prepareError_(error);\n      return error;\n    }\n  }\n\n  /**\n   * Reports an error message.\n   * @param {string} tag\n   * @param {...*} var_args\n   */\n  error(tag, var_args) {\n    const error = this.error_.apply(this, arguments);\n    if (error) {\n      error.name = tag || error.name;\n      // __AMP_REPORT_ERROR is installed globally per window in the entry point.\n      self.__AMP_REPORT_ERROR(error);\n    }\n  }\n\n  /**\n   * Reports an error message and marks with an expected property. If the\n   * logging is disabled, the error is rethrown asynchronously.\n   * @param {string} unusedTag\n   * @param {...*} var_args\n   */\n  expectedError(unusedTag, var_args) {\n    const error = this.error_.apply(this, arguments);\n    if (error) {\n      error.expected = true;\n      // __AMP_REPORT_ERROR is installed globally per window in the entry point.\n      self.__AMP_REPORT_ERROR(error);\n    }\n  }\n\n  /**\n   * Creates an error object.\n   * @param {...*} var_args\n   * @return {!Error}\n   */\n  createError(var_args) {\n    const error = createErrorVargs.apply(null, arguments);\n    this.prepareError_(error);\n    return error;\n  }\n\n  /**\n   * Creates an error object with its expected property set to true.\n   * @param {...*} var_args\n   * @return {!Error}\n   */\n  createExpectedError(var_args) {\n    const error = createErrorVargs.apply(null, arguments);\n    this.prepareError_(error);\n    error.expected = true;\n    return error;\n  }\n\n  /**\n   * Throws an error if the first argument isn't trueish.\n   *\n   * Supports argument substitution into the message via %s placeholders.\n   *\n   * Throws an error object that has two extra properties:\n   * - associatedElement: This is the first element provided in the var args.\n   *   It can be used for improved display of error messages.\n   * - messageArray: The elements of the substituted message as non-stringified\n   *   elements in an array. When e.g. passed to console.error this yields\n   *   native displays of things like HTML elements.\n   *\n   * NOTE: for an explanation of the tempate R implementation see\n   * https://github.com/google/closure-library/blob/08858804/closure/goog/asserts/asserts.js#L192-L213\n   *\n   * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n   *     not evaluate to true.\n   * @param {!Array|string=} opt_message The assertion message\n   * @param {...*} var_args Arguments substituted into %s in the message.\n   * @return {R} The value of shouldBeTrueish.\n   * @throws {!Error} When `value` is `null` or `undefined`.\n   * @template T\n   * @template R :=\n   *     mapunion(T, (V) =>\n   *         cond(eq(V, 'null'),\n   *             none(),\n   *             cond(eq(V, 'undefined'),\n   *                 none(),\n   *                 V)))\n   *  =:\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assert(shouldBeTrueish, opt_message, var_args) {\n    let firstElement;\n    if (isArray(opt_message)) {\n      return this.assert.apply(\n        this,\n        [shouldBeTrueish].concat(\n          this.expandMessageArgs_(/** @type {!Array} */ (opt_message))\n        )\n      );\n    }\n    if (!shouldBeTrueish) {\n      const message = opt_message || 'Assertion failed';\n      const splitMessage = message.split('%s');\n      const first = splitMessage.shift();\n      let formatted = first;\n      const messageArray = [];\n      let i = 2;\n      pushIfNonEmpty(messageArray, first);\n      while (splitMessage.length > 0) {\n        const nextConstant = splitMessage.shift();\n        const val = arguments[i++];\n        if (val && val.tagName) {\n          firstElement = val;\n        }\n        messageArray.push(val);\n        pushIfNonEmpty(messageArray, nextConstant.trim());\n        formatted += stringOrElementString(val) + nextConstant;\n      }\n      const e = new Error(formatted);\n      e.fromAssert = true;\n      e.associatedElement = firstElement;\n      e.messageArray = messageArray;\n      this.prepareError_(e);\n      // __AMP_REPORT_ERROR is installed globally per window in the entry point.\n      self.__AMP_REPORT_ERROR(e);\n      throw e;\n    }\n    return shouldBeTrueish;\n  }\n\n  /**\n   * Throws an error if the first argument isn't an Element\n   *\n   * Otherwise see `assert` for usage\n   *\n   * @param {*} shouldBeElement\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {!Element} The value of shouldBeTrueish.\n   * @template T\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertElement(shouldBeElement, opt_message) {\n    const shouldBeTrueish = shouldBeElement && shouldBeElement.nodeType == 1;\n    this.assertType_(\n      shouldBeElement,\n      shouldBeTrueish,\n      'Element expected',\n      opt_message\n    );\n    return /** @type {!Element} */ (shouldBeElement);\n  }\n\n  /**\n   * Throws an error if the first argument isn't a string. The string can\n   * be empty.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeString\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {string} The string value. Can be an empty string.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertString(shouldBeString, opt_message) {\n    this.assertType_(\n      shouldBeString,\n      typeof shouldBeString == 'string',\n      'String expected',\n      opt_message\n    );\n    return /** @type {string} */ (shouldBeString);\n  }\n\n  /**\n   * Throws an error if the first argument isn't a number. The allowed values\n   * include `0` and `NaN`.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeNumber\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {number} The number value. The allowed values include `0`\n   *   and `NaN`.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertNumber(shouldBeNumber, opt_message) {\n    this.assertType_(\n      shouldBeNumber,\n      typeof shouldBeNumber == 'number',\n      'Number expected',\n      opt_message\n    );\n    return /** @type {number} */ (shouldBeNumber);\n  }\n\n  /**\n   * Throws an error if the first argument is not an array.\n   * The array can be empty.\n   *\n   * @param {*} shouldBeArray\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {!Array} The array value\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertArray(shouldBeArray, opt_message) {\n    this.assertType_(\n      shouldBeArray,\n      isArray(shouldBeArray),\n      'Array expected',\n      opt_message\n    );\n    return /** @type {!Array} */ (shouldBeArray);\n  }\n\n  /**\n   * Throws an error if the first argument isn't a boolean.\n   *\n   * For more details see `assert`.\n   *\n   * @param {*} shouldBeBoolean\n   * @param {!Array|string=} opt_message The assertion message\n   * @return {boolean} The boolean value.\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertBoolean(shouldBeBoolean, opt_message) {\n    this.assertType_(\n      shouldBeBoolean,\n      !!shouldBeBoolean === shouldBeBoolean,\n      'Boolean expected',\n      opt_message\n    );\n    return /** @type {boolean} */ (shouldBeBoolean);\n  }\n\n  /**\n   * Asserts and returns the enum value. If the enum doesn't contain such a\n   * value, the error is thrown.\n   *\n   * @param {!Object<T>} enumObj\n   * @param {string} s\n   * @param {string=} opt_enumName\n   * @return {T}\n   * @template T\n   * @closurePrimitive {asserts.matchesReturn}\n   */\n  assertEnumValue(enumObj, s, opt_enumName) {\n    if (isEnumValue(enumObj, s)) {\n      return s;\n    }\n    this.assert(false, 'Unknown %s value: \"%s\"', opt_enumName || 'enum', s);\n  }\n\n  /**\n   * @param {!Error} error\n   * @private\n   */\n  prepareError_(error) {\n    error = duplicateErrorIfNecessary(error);\n    if (this.suffix_) {\n      if (!error.message) {\n        error.message = this.suffix_;\n      } else if (error.message.indexOf(this.suffix_) == -1) {\n        error.message += this.suffix_;\n      }\n    } else if (isUserErrorMessage(error.message)) {\n      error.message = error.message.replace(USER_ERROR_SENTINEL, '');\n    }\n  }\n\n  /**\n   * @param {!Array} args\n   * @return {!Array}\n   * @private\n   */\n  maybeExpandMessageArgs_(args) {\n    if (isArray(args[0])) {\n      return this.expandMessageArgs_(/** @type {!Array} */ (args[0]));\n    }\n    return args;\n  }\n\n  /**\n   * Either redirects a pair of (errorId, ...args) to a URL where the full\n   * message is displayed, or displays it from a fetched table.\n   *\n   * This method is used by the output of the `transform-log-methods` babel\n   * plugin. It should not be used directly. Use the (*error|assert*|info|warn)\n   * methods instead.\n   *\n   * @param {!Array} parts\n   * @return {!Array}\n   * @private\n   */\n  expandMessageArgs_(parts) {\n    // First value should exist.\n    const id = parts.shift();\n    // Best effort fetch of message template table.\n    // Since this is async, the first few logs might be indirected to a URL even\n    // if in development mode. Message table is ~small so this should be a short\n    // gap.\n    if (getMode(this.win).development) {\n      this.fetchExternalMessagesOnce_();\n    }\n    if (this.messages_ && id in this.messages_) {\n      return [this.messages_[id]].concat(parts);\n    }\n    return [`More info at ${externalMessageUrl(id, parts)}`];\n  }\n\n  /**\n   * Asserts types, backbone of `assertNumber`, `assertString`, etc.\n   *\n   * It understands array-based \"id\"-contracted messages.\n   *\n   * Otherwise creates a sprintf syntax string containing the optional message or the\n   * default. An interpolation token is added at the end to include the `subject`.\n   * @param {*} subject\n   * @param {*} assertion\n   * @param {string} defaultMessage\n   * @param {!Array|string=} opt_message\n   * @private\n   */\n  assertType_(subject, assertion, defaultMessage, opt_message) {\n    if (isArray(opt_message)) {\n      this.assert(assertion, opt_message.concat(subject));\n    } else {\n      this.assert(assertion, `${opt_message || defaultMessage}: %s`, subject);\n    }\n  }\n}\n\n/**\n * @param {string|!Element} val\n * @return {string}\n */\nconst stringOrElementString = val =>\n  /** @type {string} */ (elementStringOrPassthru(val));\n\n/**\n * @param {*} val\n * @return {*}\n */\nfunction elementStringOrPassthru(val) {\n  // Do check equivalent to `val instanceof Element` without cross-window bug\n  if (val && val.nodeType == 1) {\n    return val.tagName.toLowerCase() + (val.id ? '#' + val.id : '');\n  }\n  return val;\n}\n\n/**\n * @param {!Array} array\n * @param {*} val\n */\nfunction pushIfNonEmpty(array, val) {\n  if (val != '') {\n    array.push(val);\n  }\n}\n\n/**\n * Some exceptions (DOMException, namely) have read-only message.\n * @param {!Error} error\n * @return {!Error};\n */\nexport function duplicateErrorIfNecessary(error) {\n  const messageProperty = Object.getOwnPropertyDescriptor(error, 'message');\n  if (messageProperty && messageProperty.writable) {\n    return error;\n  }\n\n  const {message, stack} = error;\n  const e = new Error(message);\n  // Copy all the extraneous things we attach.\n  for (const prop in error) {\n    e[prop] = error[prop];\n  }\n  // Ensure these are copied.\n  e.stack = stack;\n  return e;\n}\n\n/**\n * @param {...*} var_args\n * @return {!Error}\n * @visibleForTesting\n */\nexport function createErrorVargs(var_args) {\n  let error = null;\n  let message = '';\n  for (let i = 0; i < arguments.length; i++) {\n    const arg = arguments[i];\n    if (arg instanceof Error && !error) {\n      error = duplicateErrorIfNecessary(arg);\n    } else {\n      if (message) {\n        message += ' ';\n      }\n      message += arg;\n    }\n  }\n\n  if (!error) {\n    error = new Error(message);\n  } else if (message) {\n    error.message = message + ': ' + error.message;\n  }\n  return error;\n}\n\n/**\n * Rethrows the error without terminating the current context. This preserves\n * whether the original error designation is a user error or a dev error.\n * @param {...*} var_args\n */\nexport function rethrowAsync(var_args) {\n  const error = createErrorVargs.apply(null, arguments);\n  setTimeout(() => {\n    // reportError is installed globally per window in the entry point.\n    self.__AMP_REPORT_ERROR(error);\n    throw error;\n  });\n}\n\n/**\n * Cache for logs. We do not use a Service since the service module depends\n * on Log and closure literally can't even.\n * @type {{user: ?Log, dev: ?Log, userForEmbed: ?Log}}\n */\nself.__AMP_LOG = self.__AMP_LOG || {\n  user: null,\n  dev: null,\n  userForEmbed: null,\n};\n\nconst logs = self.__AMP_LOG;\n\n/**\n * Eventually holds a constructor for Log objects. Lazily initialized, so we\n * can avoid ever referencing the real constructor except in JS binaries\n * that actually want to include the implementation.\n * @type {?Function}\n */\nlet logConstructor = null;\n\n/**\n * Initializes log contructor.\n */\nexport function initLogConstructor() {\n  logConstructor = Log;\n  // Initialize instances for use. If a binary (an extension for example) that\n  // does not call `initLogConstructor` invokes `dev()` or `user()` earlier than\n  // the binary that does call `initLogConstructor` (amp.js), the extension will\n  // throw an error as that extension will never be able to initialize the log\n  // instances and we also don't want it to call `initLogConstructor` either\n  // (since that will cause the Log implementation to be bundled into that\n  // binary). So we must initialize the instances eagerly so that they are ready\n  // for use (stored globally) after the main binary calls `initLogConstructor`.\n  dev();\n  user();\n}\n\n/**\n * Resets log contructor for testing.\n */\nexport function resetLogConstructorForTesting() {\n  logConstructor = null;\n}\n\n/**\n * Publisher level log.\n *\n * Enabled in the following conditions:\n *  1. Not disabled using `#log=0`.\n *  2. Development mode is enabled via `#development=1` or logging is explicitly\n *     enabled via `#log=D` where D >= 1.\n *  3. AMP.setLogLevel(D) is called, where D >= 1.\n *\n * @param {!Element=} opt_element\n * @return {!Log}\n */\nexport function user(opt_element) {\n  if (!logs.user) {\n    logs.user = getUserLogger(USER_ERROR_SENTINEL);\n  }\n  if (!isFromEmbed(logs.user.win, opt_element)) {\n    return logs.user;\n  } else {\n    if (logs.userForEmbed) {\n      return logs.userForEmbed;\n    }\n    return (logs.userForEmbed = getUserLogger(USER_ERROR_EMBED_SENTINEL));\n  }\n}\n\n/**\n * Getter for user logger\n * @param {string=} suffix\n * @return {!Log}\n */\nfunction getUserLogger(suffix) {\n  if (!logConstructor) {\n    throw new Error('failed to call initLogConstructor');\n  }\n  return new logConstructor(\n    self,\n    mode => {\n      const logNum = parseInt(mode.log, 10);\n      if (mode.development || logNum >= 1) {\n        return LogLevel.FINE;\n      }\n      return LogLevel.WARN;\n    },\n    suffix\n  );\n}\n\n/**\n * AMP development log. Calls to `devLog().assert` and `dev.fine` are stripped\n * in the PROD binary. However, `devLog().assert` result is preserved in either\n * case.\n *\n * Enabled in the following conditions:\n *  1. Not disabled using `#log=0`.\n *  2. Logging is explicitly enabled via `#log=D`, where D >= 2.\n *  3. AMP.setLogLevel(D) is called, where D >= 2.\n *\n * @return {!Log}\n */\nexport function dev() {\n  if (logs.dev) {\n    return logs.dev;\n  }\n  if (!logConstructor) {\n    throw new Error('failed to call initLogConstructor');\n  }\n  return (logs.dev = new logConstructor(self, mode => {\n    const logNum = parseInt(mode.log, 10);\n    if (logNum >= 3) {\n      return LogLevel.FINE;\n    }\n    if (logNum >= 2) {\n      return LogLevel.INFO;\n    }\n    return LogLevel.OFF;\n  }));\n}\n\n/**\n * @param {!Window} win\n * @param {!Element=} opt_element\n * @return {boolean} isEmbed\n */\nexport function isFromEmbed(win, opt_element) {\n  if (!opt_element) {\n    return false;\n  }\n  return opt_element.ownerDocument.defaultView != win;\n}\n\n/**\n * Throws an error if the first argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - associatedElement: This is the first element provided in the var args.\n *   It can be used for improved display of error messages.\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n *\n * NOTE: for an explanation of the tempate R implementation see\n * https://github.com/google/closure-library/blob/08858804/closure/goog/asserts/asserts.js#L192-L213\n *\n * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n *     not evaluate to true.\n * @param {!Array|string=} opt_message The assertion message\n * @param {*=} opt_1 Optional argument (Var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {R} The value of shouldBeTrueish.\n * @template T\n * @template R :=\n *     mapunion(T, (V) =>\n *         cond(eq(V, 'null'),\n *             none(),\n *             cond(eq(V, 'undefined'),\n *                 none(),\n *                 V)))\n *  =:\n * @throws {!Error} When `value` is `null` or `undefined`.\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function devAssert(\n  shouldBeTrueish,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  if (getMode().minified) {\n    return shouldBeTrueish;\n  }\n  return dev()./*Orig call*/ assert(\n    shouldBeTrueish,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n\n/**\n * Throws an error if the first argument isn't trueish.\n *\n * Supports argument substitution into the message via %s placeholders.\n *\n * Throws an error object that has two extra properties:\n * - associatedElement: This is the first element provided in the var args.\n *   It can be used for improved display of error messages.\n * - messageArray: The elements of the substituted message as non-stringified\n *   elements in an array. When e.g. passed to console.error this yields\n *   native displays of things like HTML elements.\n *\n * NOTE: for an explanation of the tempate R implementation see\n * https://github.com/google/closure-library/blob/08858804/closure/goog/asserts/asserts.js#L192-L213\n *\n * @param {T} shouldBeTrueish The value to assert. The assert fails if it does\n *     not evaluate to true.\n * @param {!Array|string=} opt_message The assertion message\n * @param {*=} opt_1 Optional argument (Var arg as individual params for better\n * @param {*=} opt_2 Optional argument inlining)\n * @param {*=} opt_3 Optional argument\n * @param {*=} opt_4 Optional argument\n * @param {*=} opt_5 Optional argument\n * @param {*=} opt_6 Optional argument\n * @param {*=} opt_7 Optional argument\n * @param {*=} opt_8 Optional argument\n * @param {*=} opt_9 Optional argument\n * @return {R} The value of shouldBeTrueish.\n * @template T\n * @template R :=\n *     mapunion(T, (V) =>\n *         cond(eq(V, 'null'),\n *             none(),\n *             cond(eq(V, 'undefined'),\n *                 none(),\n *                 V)))\n *  =:\n * @throws {!Error} When `value` is `null` or `undefined`.\n * @closurePrimitive {asserts.matchesReturn}\n */\nexport function userAssert(\n  shouldBeTrueish,\n  opt_message,\n  opt_1,\n  opt_2,\n  opt_3,\n  opt_4,\n  opt_5,\n  opt_6,\n  opt_7,\n  opt_8,\n  opt_9\n) {\n  return user()./*Orig call*/ assert(\n    shouldBeTrueish,\n    opt_message,\n    opt_1,\n    opt_2,\n    opt_3,\n    opt_4,\n    opt_5,\n    opt_6,\n    opt_7,\n    opt_8,\n    opt_9\n  );\n}\n","/**\n * Copyright 2016 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getMode} from './mode';\n\n/**\n * Provides info about the current app. This return value may be cached and\n * passed around as it will always be DCE'd.\n * @param {?Window=} opt_win\n * @return {!./mode.ModeDef}\n */\nexport function getModeObject(opt_win) {\n  return {\n    localDev: getMode(opt_win).localDev,\n    development: getMode(opt_win).development,\n    filter: getMode(opt_win).filter,\n    minified: getMode(opt_win).minified,\n    lite: getMode(opt_win).lite,\n    test: getMode(opt_win).test,\n    log: getMode(opt_win).log,\n    version: getMode(opt_win).version,\n    rtvVersion: getMode(opt_win).rtvVersion,\n    singlePassType: getMode(opt_win).singlePassType,\n  };\n}\n","/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {internalRuntimeVersion} from './internal-version';\nimport {parseQueryString_} from './url-parse-query-string';\n\n/**\n * @typedef {{\n *   localDev: boolean,\n *   development: boolean,\n *   filter: (string|undefined),\n *   minified: boolean,\n *   lite: boolean,\n *   test: boolean,\n *   log: (string|undefined),\n *   version: string,\n *   rtvVersion: string,\n *   runtime: (null|string|undefined),\n *   a4aId: (null|string|undefined),\n *   singlePassType: (string|undefined)\n * }}\n */\nexport let ModeDef;\n\n/**\n * `rtvVersion` is the prefixed version we serve off of the cdn.\n * The prefix denotes canary(00) or prod(01) or an experiment version ( > 01).\n * @type {string}\n */\nlet rtvVersion = '';\n\n/**\n * Provides info about the current app.\n * @param {?Window=} opt_win\n * @return {!ModeDef}\n */\nexport function getMode(opt_win) {\n  const win = opt_win || self;\n  if (win.__AMP_MODE) {\n    return win.__AMP_MODE;\n  }\n  return (win.__AMP_MODE = getMode_(win));\n}\n\n/**\n * Provides info about the current app.\n * @param {!Window} win\n * @return {!ModeDef}\n */\nfunction getMode_(win) {\n  // TODO(erwinmombay): simplify the logic here\n  const AMP_CONFIG = self.AMP_CONFIG || {};\n\n  // Magic constants that are replaced by closure compiler.\n  // IS_MINIFIED is always replaced with true when closure compiler is used\n  // while IS_DEV is only replaced when `gulp dist` is called without the\n  // --fortesting flag.\n  const IS_DEV = true;\n  const IS_MINIFIED = false;\n\n  const localDevEnabled = !!AMP_CONFIG.localDev;\n  const runningTests =\n    !!AMP_CONFIG.test || (IS_DEV && !!(win.__AMP_TEST || win.__karma__));\n  const runningTestsOnIe = win.__karma__ && win.__karma__.config.amp.testOnIe;\n  const isLocalDev = IS_DEV && (localDevEnabled || runningTests);\n  const hashQuery = parseQueryString_(\n    // location.originalHash is set by the viewer when it removes the fragment\n    // from the URL.\n    win.location.originalHash || win.location.hash\n  );\n  const singlePassType = AMP_CONFIG.spt;\n\n  const searchQuery = parseQueryString_(win.location.search);\n\n  if (!rtvVersion) {\n    rtvVersion = getRtvVersion(win, isLocalDev);\n  }\n\n  // The `minified`, `test` and `localDev` properties are replaced\n  // as boolean literals when we run `gulp dist` without the `--fortesting`\n  // flags. This improved DCE on the production file we deploy as the code\n  // paths for localhost/testing/development are eliminated.\n  return {\n    localDev: isLocalDev,\n    // Triggers validation or enable pub level logging. Validation can be\n    // bypassed via #validate=0.\n    // Note that AMP_DEV_MODE flag is used for testing purposes.\n    // Use Array.indexOf instead of Array.includes because of #24219\n    development: !!(\n      ['1', 'actions', 'amp', 'amp4ads', 'amp4email'].indexOf(\n        hashQuery['development']\n      ) >= 0 || win.AMP_DEV_MODE\n    ),\n    examiner: hashQuery['development'] == '2',\n    // Allows filtering validation errors by error category. For the\n    // available categories, see ErrorCategory in validator/validator.proto.\n    filter: hashQuery['filter'],\n    // amp-geo override\n    geoOverride: hashQuery['amp-geo'],\n    // amp-user-location override\n    userLocationOverride: hashQuery['amp-user-location'],\n    minified: IS_MINIFIED,\n    // Whether document is in an amp-lite viewer. It signal that the user\n    // would prefer to use less bandwidth.\n    lite: searchQuery['amp_lite'] != undefined,\n    test: runningTests,\n    testIe: runningTestsOnIe,\n    log: hashQuery['log'],\n    version: internalRuntimeVersion(),\n    rtvVersion,\n    singlePassType,\n  };\n}\n\n/**\n * Retrieve the `rtvVersion` which will have a numeric prefix\n * denoting canary/prod/experiment (unless `isLocalDev` is true).\n *\n * @param {!Window} win\n * @param {boolean} isLocalDev\n * @return {string}\n */\nfunction getRtvVersion(win, isLocalDev) {\n  // If it's local dev then we won't actually have a full version so\n  // just use the version.\n  if (isLocalDev) {\n    return internalRuntimeVersion();\n  }\n\n  if (win.AMP_CONFIG && win.AMP_CONFIG.v) {\n    return win.AMP_CONFIG.v;\n  }\n\n  // Currently `internalRuntimeVersion` and thus `mode.version` contain only\n  // major version. The full version however must also carry the minor version.\n  // We will default to production default `01` minor version for now.\n  // TODO(erwinmombay): decide whether internalRuntimeVersion should contain\n  // minor version.\n  return `01${internalRuntimeVersion()}`;\n}\n\n/**\n * @param {!Window} win\n * @param {boolean} isLocalDev\n * @return {string}\n * @visibleForTesting\n */\nexport function getRtvVersionForTesting(win, isLocalDev) {\n  return getRtvVersion(win, isLocalDev);\n}\n\n/** @visibleForTesting */\nexport function resetRtvVersionForTesting() {\n  rtvVersion = '';\n}\n","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  BIND_PREFIX,\n  BLACKLISTED_TAGS,\n  EMAIL_WHITELISTED_AMP_TAGS,\n  TRIPLE_MUSTACHE_WHITELISTED_TAGS,\n  WHITELISTED_ATTRS,\n  WHITELISTED_ATTRS_BY_TAGS,\n  WHITELISTED_TARGETS,\n  isValidAttr,\n  markElementForDiffing,\n} from './sanitation';\nimport {dev, user} from './log';\nimport {isAmp4Email} from './format';\nimport {removeElement} from './dom';\nimport {rewriteAttributeValue} from './url-rewrite';\nimport {startsWith} from './string';\nimport purify from 'dompurify/dist/purify.es';\n\n/**\n * @typedef {{addHook: !Function, removeAllHooks: !Function, sanitize: !Function}}\n */\nexport let DomPurifyDef;\n\n// TODO(choumx): Convert this into a class to avoid import side effects.\n/** @private @const {!DomPurifyDef} */\nconst DomPurify = purify(self);\n\n/** @private @const {string} */\nconst TAG = 'purifier';\n\n/**\n * Tags that are only whitelisted for specific values of given attributes.\n * @private @const {!Object<string, {attribute: string, values: !Array<string>}>}\n */\nconst WHITELISTED_TAGS_BY_ATTRS = {\n  'script': {\n    'attribute': 'type',\n    'values': ['application/json', 'application/ld+json'],\n  },\n};\n\nconst PURIFY_PROFILES = /** @type {!DomPurifyConfig} */ ({\n  USE_PROFILES: {\n    html: true,\n    svg: true,\n    svgFilters: true,\n  },\n});\n\n/**\n * Monotonically increasing counter used for keying nodes.\n * @private {number}\n */\nlet KEY_COUNTER = 1;\n\n/**\n * Returns a <body> element containing the sanitized `dirty` markup.\n * Uses the standard DOMPurify config.\n * @param {string} dirty\n * @param {!Document} doc\n * @return {!Node}\n */\nexport function purifyHtml(dirty, doc) {\n  const config = standardPurifyConfig();\n  addPurifyHooks(DomPurify, doc);\n  const body = DomPurify.sanitize(dirty, config);\n  DomPurify.removeAllHooks();\n  return body;\n}\n\n/**\n * Creates a new DOMPurify instance with a custom DOMPurify configuration.\n * @param {!Document} doc\n * @param {!JsonObject=} opt_config\n * @return {!DomPurifyDef}\n */\nexport function createPurifier(doc, opt_config) {\n  const domPurify = purify(self);\n  const config = Object.assign(opt_config || {}, standardPurifyConfig());\n  domPurify.setConfig(config);\n  addPurifyHooks(domPurify, doc);\n  return domPurify;\n}\n\n/**\n * Returns standard DOMPurify config for escaped templates.\n * Do not use for unescaped templates.\n *\n * NOTE: See that we use DomPurifyConfig found in\n * build-system/dompurify.extern.js as the exact type. This is to prevent\n * closure compiler from optimizing these fields here in this file and in the\n * 3rd party library file. See #19624 for further information.\n *\n * @return {!DomPurifyConfig}\n */\nfunction standardPurifyConfig() {\n  const config = Object.assign(\n    {},\n    PURIFY_PROFILES,\n    /** @type {!DomPurifyConfig} */ ({\n      ADD_ATTR: WHITELISTED_ATTRS,\n      // <use> is an SVG element that is not allowed by default in DOMPurify.\n      // See afterSanitizeAttributes() for special handling.\n      ADD_TAGS: ['use'],\n      FORBID_TAGS: Object.keys(BLACKLISTED_TAGS),\n      // Avoid reparenting of some elements to document head e.g. <script>.\n      FORCE_BODY: true,\n      // Avoid need for serializing to/from string by returning Node directly.\n      RETURN_DOM: true,\n      // Allows native app deeplinks. DOMPurify's remaining checks are\n      // sufficient to prevent code execution.\n      ALLOW_UNKNOWN_PROTOCOLS: true,\n    })\n  );\n  return /** @type {!DomPurifyConfig} */ (config);\n}\n\n/**\n * Gets a copy of the map of allowed tag names (standard DOMPurify config).\n * @return {!Object<string, boolean>}\n */\nexport function getAllowedTags() {\n  const allowedTags = {};\n  // Use this hook to extract purifier's allowed tags.\n  DomPurify.addHook('uponSanitizeElement', function(node, data) {\n    Object.assign(allowedTags, data.allowedTags);\n  });\n  // Sanitize dummy markup so that the hook is invoked.\n  DomPurify.sanitize('<p></p>');\n  Object.keys(BLACKLISTED_TAGS).forEach(tag => {\n    allowedTags[tag] = false;\n  });\n  // Pops the last hook added.\n  DomPurify.removeHook('uponSanitizeElement');\n  return allowedTags;\n}\n\n/**\n * Adds AMP hooks to given DOMPurify object.\n * @param {!DomPurifyDef} purifier\n * @param {!Document} doc\n */\nfunction addPurifyHooks(purifier, doc) {\n  const isEmail = isAmp4Email(doc);\n\n  // Reference to DOMPurify's `allowedTags` whitelist.\n  let allowedTags;\n  const allowedTagsChanges = [];\n\n  // Reference to DOMPurify's `allowedAttributes` whitelist.\n  let allowedAttributes;\n  const allowedAttributesChanges = [];\n\n  /**\n   * @param {!Node} node\n   * @param {{tagName: string, allowedTags: !Object<string, boolean>}} data\n   */\n  const uponSanitizeElement = function(node, data) {\n    const {tagName} = data;\n    allowedTags = data.allowedTags;\n\n    // Allow all AMP elements.\n    if (startsWith(tagName, 'amp-')) {\n      // Enforce AMP4EMAIL tag whitelist at runtime.\n      allowedTags[tagName] = !isEmail || EMAIL_WHITELISTED_AMP_TAGS[tagName];\n    }\n    // Set `target` attribute for <a> tags if necessary.\n    if (tagName === 'a') {\n      const element = dev().assertElement(node);\n      if (element.hasAttribute('href') && !element.hasAttribute('target')) {\n        element.setAttribute('target', '_top');\n      }\n    }\n    // Allow certain tags if they have an attribute with a whitelisted value.\n    const whitelist = WHITELISTED_TAGS_BY_ATTRS[tagName];\n    if (whitelist) {\n      const {attribute, values} = whitelist;\n      const element = dev().assertElement(node);\n      if (\n        element.hasAttribute(attribute) &&\n        values.includes(element.getAttribute(attribute))\n      ) {\n        allowedTags[tagName] = true;\n        allowedTagsChanges.push(tagName);\n      }\n    }\n  };\n\n  /**\n   * @param {!Node} unusedNode\n   */\n  const afterSanitizeElements = function(unusedNode) {\n    // DOMPurify doesn't have a attribute-specific tag whitelist API and\n    // `allowedTags` has a per-invocation scope, so we need to undo\n    // changes after sanitizing elements.\n    allowedTagsChanges.forEach(tag => {\n      delete allowedTags[tag];\n    });\n    allowedTagsChanges.length = 0;\n  };\n\n  /**\n   * @param {!Element} element\n   * @param {{attrName: string, attrValue: string, allowedAttributes: !Object<string, boolean>}} data\n   */\n  const uponSanitizeAttribute = function(element, data) {\n    // Beware of DOM Clobbering when using properties or functions on `element`.\n    // DOMPurify checks a few of these for its internal usage (e.g. `nodeName`),\n    // but not others that may be used in custom hooks.\n    // See https://github.com/cure53/DOMPurify/wiki/Security-Goals-&-Threat-Model#security-goals\n    // and https://github.com/cure53/DOMPurify/blob/master/src/purify.js#L527.\n\n    const tagName = element.nodeName.toLowerCase();\n    const {attrName} = data;\n    let {attrValue} = data;\n    allowedAttributes = data.allowedAttributes;\n\n    const allowAttribute = () => {\n      // Only add new attributes to `allowedAttributesChanges` to avoid removing\n      // default-supported attributes later erroneously.\n      if (!allowedAttributes[attrName]) {\n        allowedAttributes[attrName] = true;\n        allowedAttributesChanges.push(attrName);\n      }\n    };\n\n    // Allow all attributes for AMP elements. This avoids the need to whitelist\n    // nonstandard attributes for every component e.g. amp-lightbox[scrollable].\n    const isAmpElement = startsWith(tagName, 'amp-');\n    if (isAmpElement) {\n      allowAttribute();\n    } else {\n      // `<A>` has special target rules:\n      // - Default target is \"_top\";\n      // - Allowed targets are \"_blank\", \"_top\";\n      // - All other targets are rewritted to \"_top\".\n      if (tagName == 'a' && attrName == 'target') {\n        const lowercaseValue = attrValue.toLowerCase();\n        if (!WHITELISTED_TARGETS.includes(lowercaseValue)) {\n          attrValue = '_top';\n        } else {\n          // Always use lowercase values for `target` attr.\n          attrValue = lowercaseValue;\n        }\n      }\n\n      // For non-AMP elements, allow attributes in tag-specific whitelist.\n      const attrsByTags = WHITELISTED_ATTRS_BY_TAGS[tagName];\n      if (attrsByTags && attrsByTags.includes(attrName)) {\n        allowAttribute();\n      }\n    }\n\n    const bindingType = bindingTypeForAttr(attrName);\n    // Rewrite classic bindings e.g. [foo]=\"bar\" -> data-amp-bind-foo=\"bar\".\n    // This is because DOMPurify eagerly removes attributes and re-adds them\n    // after sanitization, which fails because `[]` are not valid attr chars.\n    if (bindingType === BindingType.CLASSIC) {\n      const property = attrName.substring(1, attrName.length - 1);\n      element.setAttribute(`${BIND_PREFIX}${property}`, attrValue);\n    }\n    if (bindingType !== BindingType.NONE) {\n      // Set a custom attribute to mark this element as containing a binding.\n      // This is an optimization that obviates the need for DOM scan later.\n      element.setAttribute('i-amphtml-binding', '');\n    }\n\n    if (\n      isValidAttr(\n        tagName,\n        attrName,\n        attrValue,\n        /* doc */ doc,\n        /* opt_purify */ true\n      )\n    ) {\n      if (attrValue && !startsWith(attrName, 'data-amp-bind-')) {\n        attrValue = rewriteAttributeValue(tagName, attrName, attrValue);\n      }\n    } else {\n      data.keepAttr = false;\n      user().error(\n        TAG,\n        'Removed invalid attribute %s[%s=\"%s\"].',\n        tagName,\n        attrName,\n        attrValue\n      );\n    }\n\n    // Update attribute value.\n    data.attrValue = attrValue;\n  };\n\n  /**\n   * @param {!Element} element\n   * @this {{removed: !Array}} Contains list of removed elements/attrs so far.\n   */\n  const afterSanitizeAttributes = function(element) {\n    markElementForDiffing(element, () => String(KEY_COUNTER++));\n\n    // DOMPurify doesn't have a tag-specific attribute whitelist API and\n    // `allowedAttributes` has a per-invocation scope, so we need to undo\n    // changes after sanitizing attributes.\n    allowedAttributesChanges.forEach(attr => {\n      delete allowedAttributes[attr];\n    });\n    allowedAttributesChanges.length = 0;\n\n    // Only allow relative references in <use>.\n    const tagName = element.nodeName.toLowerCase();\n    if (tagName === 'use') {\n      ['href', 'xlink:href'].forEach(attr => {\n        if (\n          element.hasAttribute(attr) &&\n          !startsWith(element.getAttribute(attr), '#')\n        ) {\n          removeElement(element);\n          user().error(\n            TAG,\n            'Removed invalid <use>. use[href] must start with \"#\".'\n          );\n        }\n      });\n    }\n  };\n\n  purifier.addHook('uponSanitizeElement', uponSanitizeElement);\n  purifier.addHook('afterSanitizeElements', afterSanitizeElements);\n  purifier.addHook('uponSanitizeAttribute', uponSanitizeAttribute);\n  purifier.addHook('afterSanitizeAttributes', afterSanitizeAttributes);\n}\n\n/**\n * @enum {number}\n */\nconst BindingType = {\n  NONE: 0,\n  CLASSIC: 1,\n  ALTERNATIVE: 2,\n};\n\n/**\n * @param {string} attrName\n * @return {BindingType}\n */\nfunction bindingTypeForAttr(attrName) {\n  if (attrName[0] == '[' && attrName[attrName.length - 1] == ']') {\n    return BindingType.CLASSIC;\n  }\n  if (startsWith(attrName, BIND_PREFIX)) {\n    return BindingType.ALTERNATIVE;\n  }\n  return BindingType.NONE;\n}\n\n/**\n * Returns whether an attribute addition/modification/removal is valid.\n *\n * This function's behavior should match that of addPurifyHooks(), except\n * that it operates on attribute changes instead of rendering new HTML.\n *\n * @param {!DomPurifyDef} purifier\n * @param {!Node} node\n * @param {string} attr Lower-case attribute name.\n * @param {string|null} value\n * @return {boolean}\n */\nexport function validateAttributeChange(purifier, node, attr, value) {\n  const tag = node.nodeName.toLowerCase();\n  // Disallow change of attributes that are required for certain tags,\n  // e.g. script[type].\n  const whitelist = WHITELISTED_TAGS_BY_ATTRS[tag];\n  if (whitelist) {\n    const {attribute, values} = whitelist;\n    if (attribute === attr) {\n      if (value == null || !values.includes(value)) {\n        return false;\n      }\n    }\n  }\n  // a[target] is required and only certain values are allowed.\n  if (tag === 'a' && attr === 'target') {\n    if (value == null || !WHITELISTED_TARGETS.includes(value)) {\n      return false;\n    }\n  }\n  // By now, the attribute is safe to remove.  DOMPurify.isValidAttribute()\n  // expects non-null values.\n  if (value == null) {\n    return true;\n  }\n  // Don't allow binding attributes for now.\n  if (bindingTypeForAttr(attr) !== BindingType.NONE) {\n    return false;\n  }\n  const pure = purifier.isValidAttribute(tag, attr, value);\n  if (!pure) {\n    // DOMPurify.isValidAttribute() by default rejects certain attributes that\n    // we should allow: (1) AMP element attributes, (2) tag-specific attributes.\n    // Reject if _not_ one of the above.\n    //\n    // TODO(choumx): This opts out of DOMPurify's attribute _value_ sanitization\n    // for the above, which assumes that the attributes don't have security\n    // implications beyond URLs etc. that are covered by isValidAttr().\n    // This is OK but we ought to contribute new hooks and remove this.\n    const attrsByTags = WHITELISTED_ATTRS_BY_TAGS[tag];\n    const whitelistedForTag = attrsByTags && attrsByTags.includes(attr);\n    if (!whitelistedForTag && !startsWith(tag, 'amp-')) {\n      return false;\n    }\n  }\n  const doc = node.ownerDocument\n    ? node.ownerDocument\n    : /** @type {!Document} */ (node);\n  // Perform AMP-specific attribute validation e.g. __amp_source_origin.\n  if (value && !isValidAttr(tag, attr, value, doc, /* opt_purify */ true)) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Uses DOMPurify to sanitize HTML with stricter policy for unescaped templates\n * e.g. triple mustache.\n *\n * @param {string} html\n * @param {!Document=} doc\n * @return {string}\n */\nexport function purifyTagsForTripleMustache(html, doc = self.document) {\n  // Reference to DOMPurify's `allowedTags` whitelist.\n  let allowedTags;\n  DomPurify.addHook('uponSanitizeElement', (node, data) => {\n    const {tagName} = data;\n    allowedTags = data.allowedTags;\n    if (tagName === 'template') {\n      const type = node.getAttribute('type');\n      if (type && type.toLowerCase() === 'amp-mustache') {\n        allowedTags['template'] = true;\n      }\n    }\n  });\n  DomPurify.addHook('afterSanitizeElements', unusedNode => {\n    // DOMPurify doesn't have an required-attribute tag whitelist API and\n    // `allowedTags` has a per-invocation scope, so we need to remove\n    // required-attribute tags after sanitizing each element.\n    allowedTags['template'] = false;\n  });\n  // <template> elements are parsed by the browser as document fragments and\n  // reparented to the head. So to support nested templates, we need\n  // RETURN_DOM_FRAGMENT to keep the <template> and FORCE_BODY to prevent\n  // reparenting. See https://github.com/cure53/DOMPurify/issues/285#issuecomment-397810671\n  const fragment = DomPurify.sanitize(html, {\n    'ALLOWED_TAGS': TRIPLE_MUSTACHE_WHITELISTED_TAGS,\n    'FORCE_BODY': true,\n    'RETURN_DOM_FRAGMENT': true,\n  });\n  DomPurify.removeAllHooks();\n  // Serialize DocumentFragment to HTML. XMLSerializer would also work, but adds\n  // namespaces for all elements and attributes.\n  const div = doc.createElement('div');\n  div.appendChild(fragment);\n  return div./*OK*/ innerHTML;\n}\n","/**\n * Copyright 2019 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {dict, map} from './utils/object';\nimport {isAmp4Email} from './format';\nimport {isUrlAttribute} from './url-rewrite';\nimport {startsWith} from './string';\n\n/** @const {string} */\nexport const BIND_PREFIX = 'data-amp-bind-';\n\n/** @const {string} */\nexport const DIFF_KEY = 'i-amphtml-key';\n\n/** @const {string} */\nexport const DIFF_IGNORE = 'i-amphtml-ignore';\n\n/**\n * Map of AMP element tag name to attributes that, if changed, require\n * replacement of the original element.\n * @const {!Object<string, !Array<string>>}\n */\nexport const DIFFABLE_AMP_ELEMENTS = {\n  'AMP-IMG': ['src', 'srcset', 'layout', 'width', 'height'],\n};\n\n/**\n * Most AMP elements don't support ad hoc mutation and should be replaced\n * instead of DOM diff'ed. Some AMP elements can be manually diff'ed.\n *\n * Both of these cases require a special attribute to enable special handling in\n * the diffing algorithm. This function sets the appropriate attribute.\n *\n * @param {!Element} element\n * @param {function(): string} generateKey\n */\nexport function markElementForDiffing(element, generateKey) {\n  const isAmpElement = startsWith(element.tagName, 'AMP-');\n  // Don't DOM diff nodes with bindings because amp-bind scans newly rendered\n  // elements and discards _all_ old elements _before_ diffing, so preserving\n  // old elements would cause loss of functionality.\n  const hasBinding = element.hasAttribute('i-amphtml-binding');\n\n  if (!hasBinding && DIFFABLE_AMP_ELEMENTS[element.tagName]) {\n    // Nodes marked with \"ignore\" will not be touched (old element stays).\n    // We want this to allow manual diffing afterwards.\n    element.setAttribute(DIFF_IGNORE, '');\n  } else if (hasBinding || isAmpElement) {\n    // Diff'ed node pairs with unique \"key\" will always be replaced.\n    if (!element.hasAttribute(DIFF_KEY)) {\n      element.setAttribute(DIFF_KEY, generateKey());\n    }\n  }\n}\n\n/**\n * @const {!Object<string, boolean>}\n * @see https://github.com/ampproject/amphtml/blob/master/spec/amp-html-format.md\n */\nexport const BLACKLISTED_TAGS = {\n  'applet': true,\n  'audio': true,\n  'base': true,\n  'embed': true,\n  'frame': true,\n  'frameset': true,\n  'iframe': true,\n  'img': true,\n  'link': true,\n  'meta': true,\n  'object': true,\n  'style': true,\n  'video': true,\n};\n\n/**\n * AMP elements allowed in AMP4EMAIL, modulo:\n * - amp-list, which cannot be nested.\n * - amp-lightbox and amp-image-lightbox, which are deprecated.\n * @const {!Object<string, boolean>}\n * @see https://github.com/ampproject/amphtml/blob/master/spec/email/amp-email-components.md\n */\nexport const EMAIL_WHITELISTED_AMP_TAGS = {\n  'amp-accordion': true,\n  'amp-anim': true,\n  'amp-bind-macro': true,\n  'amp-carousel': true,\n  'amp-fit-text': true,\n  'amp-img': true,\n  'amp-layout': true,\n  'amp-selector': true,\n  'amp-sidebar': true,\n  'amp-state': true,\n  'amp-timeago': true,\n};\n\n/**\n * Whitelist of tags allowed in triple mustache e.g. {{{name}}}.\n * Very restrictive by design since the triple mustache renders unescaped HTML\n * which, unlike double mustache, won't be processed by the AMP Validator.\n * @const {!Array<string>}\n */\nexport const TRIPLE_MUSTACHE_WHITELISTED_TAGS = [\n  'a',\n  'b',\n  'br',\n  'caption',\n  'colgroup',\n  'code',\n  'del',\n  'div',\n  'em',\n  'hr',\n  'i',\n  'ins',\n  'li',\n  'mark',\n  'ol',\n  'p',\n  'q',\n  's',\n  'small',\n  'span',\n  'strong',\n  'sub',\n  'sup',\n  'table',\n  'tbody',\n  'time',\n  'td',\n  'th',\n  'thead',\n  'tfoot',\n  'tr',\n  'u',\n  'ul',\n];\n\n/**\n * Tag-agnostic attribute whitelisted used by both Caja and DOMPurify.\n * @const {!Array<string>}\n */\nexport const WHITELISTED_ATTRS = [\n  // AMP-only attributes that don't exist in HTML.\n  'amp-fx',\n  'fallback',\n  'heights',\n  'layout',\n  'min-font-size',\n  'max-font-size',\n  'on',\n  'option',\n  'placeholder',\n  // Attributes related to amp-form.\n  'submitting',\n  'submit-success',\n  'submit-error',\n  'validation-for',\n  'verify-error',\n  'visible-when-invalid',\n  // HTML attributes that are scrubbed by Caja but we handle specially.\n  'href',\n  'style',\n  // Attributes for amp-bind that exist in \"[foo]\" form.\n  'text',\n  // Attributes for amp-subscriptions.\n  'subscriptions-action',\n  'subscriptions-actions',\n  'subscriptions-decorate',\n  'subscriptions-dialog',\n  'subscriptions-display',\n  'subscriptions-section',\n  'subscriptions-service',\n  // Attributes for amp-drilldown.\n  'amp-drilldown-submenu',\n  'amp-drilldown-submenu-open',\n  'amp-drilldown-submenu-close',\n  // A global attribute used for structured data.\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/itemprop\n  'itemprop',\n];\n\n/**\n * Attributes that are only whitelisted for specific, non-AMP elements.\n * @const {!Object<string, !Array<string>>}\n */\nexport const WHITELISTED_ATTRS_BY_TAGS = {\n  'a': ['rel', 'target'],\n  'div': ['template'],\n  'form': ['action-xhr', 'verify-xhr', 'custom-validation-reporting', 'target'],\n  'input': ['mask-output'],\n  'template': ['type'],\n  'textarea': ['autoexpand'],\n};\n\n/** @const {!Array<string>} */\nexport const WHITELISTED_TARGETS = ['_top', '_blank'];\n\n/** @const {!Array<string>} */\nconst BLACKLISTED_ATTR_VALUES = Object.freeze([\n  /*eslint no-script-url: 0*/ 'javascript:',\n  /*eslint no-script-url: 0*/ 'vbscript:',\n  /*eslint no-script-url: 0*/ 'data:',\n  /*eslint no-script-url: 0*/ '<script',\n  /*eslint no-script-url: 0*/ '</script',\n]);\n\n/** @const {!Object<string, !Object<string, !RegExp>>} */\nconst BLACKLISTED_TAG_SPECIFIC_ATTR_VALUES = Object.freeze(\n  dict({\n    'input': {\n      'type': /(?:image|button)/i,\n    },\n  })\n);\n\n/**\n * Rules in addition to BLACKLISTED_TAG_SPECIFIC_ATTR_VALUES for AMP4EMAIL.\n * @const {!Object<string, !Object<string, !RegExp>>}\n */\nconst EMAIL_BLACKLISTED_TAG_SPECIFIC_ATTR_VALUES = Object.freeze(\n  dict({\n    'input': {\n      'type': /(?:button|file|image|password)/i,\n    },\n  })\n);\n\n/** @const {!Array<string>} */\nconst BLACKLISTED_FIELDS_ATTR = Object.freeze([\n  'form',\n  'formaction',\n  'formmethod',\n  'formtarget',\n  'formnovalidate',\n  'formenctype',\n]);\n\n/** @const {!Object<string, !Array<string>>} */\nconst BLACKLISTED_TAG_SPECIFIC_ATTRS = Object.freeze(\n  dict({\n    'input': BLACKLISTED_FIELDS_ATTR,\n    'textarea': BLACKLISTED_FIELDS_ATTR,\n    'select': BLACKLISTED_FIELDS_ATTR,\n  })\n);\n\n/**\n * Rules in addition to BLACKLISTED_TAG_SPECIFIC_ATTRS for AMP4EMAIL.\n * @const {!Object<string, !Array<string>>}\n */\nconst EMAIL_BLACKLISTED_TAG_SPECIFIC_ATTRS = Object.freeze(\n  dict({\n    'amp-anim': ['controls'],\n    'form': ['name'],\n  })\n);\n\n/**\n * Test for invalid `style` attribute values.\n *\n * !important avoids overriding AMP styles, while `position:fixed|sticky` is a\n * FixedLayer limitation (it only scans the style[amp-custom] stylesheet\n * for potential fixed/sticky elements). Note that the latter can be\n * circumvented with CSS comments -- not a big deal.\n *\n * @const {!RegExp}\n */\nconst INVALID_INLINE_STYLE_REGEX = /!important|position\\s*:\\s*fixed|position\\s*:\\s*sticky/i;\n\n/**\n * Whether the attribute/value is valid.\n * @param {string} tagName Lowercase tag name.\n * @param {string} attrName Lowercase attribute name.\n * @param {string} attrValue attribute value\n * @param {!Document} doc\n * @param {boolean} opt_purify Is true, skips some attribute sanitizations\n *     that are already covered by DOMPurify.\n * @return {boolean}\n */\nexport function isValidAttr(\n  tagName,\n  attrName,\n  attrValue,\n  doc,\n  opt_purify = false\n) {\n  if (!opt_purify) {\n    // \"on*\" attributes are not allowed.\n    if (startsWith(attrName, 'on') && attrName != 'on') {\n      return false;\n    }\n\n    // No attributes with \"javascript\" or other blacklisted substrings in them.\n    if (attrValue) {\n      const normalized = attrValue.toLowerCase().replace(/[\\s,\\u0000]+/g, '');\n      for (let i = 0; i < BLACKLISTED_ATTR_VALUES.length; i++) {\n        if (normalized.indexOf(BLACKLISTED_ATTR_VALUES[i]) >= 0) {\n          return false;\n        }\n      }\n    }\n  }\n\n  // Don't allow certain inline style values.\n  if (attrName == 'style') {\n    return !INVALID_INLINE_STYLE_REGEX.test(attrValue);\n  }\n\n  // Don't allow CSS class names with internal AMP prefix.\n  if (attrName == 'class' && attrValue && /(^|\\W)i-amphtml-/i.test(attrValue)) {\n    return false;\n  }\n\n  // Don't allow '__amp_source_origin' in URLs.\n  if (isUrlAttribute(attrName) && /__amp_source_origin/.test(attrValue)) {\n    return false;\n  }\n\n  const isEmail = isAmp4Email(doc);\n\n  // Remove blacklisted attributes from specific tags e.g. input[formaction].\n  const attrBlacklist = Object.assign(\n    map(),\n    BLACKLISTED_TAG_SPECIFIC_ATTRS,\n    isEmail ? EMAIL_BLACKLISTED_TAG_SPECIFIC_ATTRS : {}\n  )[tagName];\n  if (attrBlacklist && attrBlacklist.indexOf(attrName) != -1) {\n    return false;\n  }\n\n  // Remove blacklisted values for specific attributes for specific tags\n  // e.g. input[type=image].\n  const attrValueBlacklist = Object.assign(\n    map(),\n    BLACKLISTED_TAG_SPECIFIC_ATTR_VALUES,\n    isEmail ? EMAIL_BLACKLISTED_TAG_SPECIFIC_ATTR_VALUES : {}\n  )[tagName];\n  if (attrValueBlacklist) {\n    const blacklistedValuesRegex = attrValueBlacklist[attrName];\n    if (\n      blacklistedValuesRegex &&\n      attrValue.search(blacklistedValuesRegex) != -1\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {devAssert, userAssert} from './log';\n\n/**\n * A single source within a srcset. Only one: width or DPR can be specified at\n * a time.\n * @typedef {{\n *   url: string,\n *   width: (number|undefined),\n *   dpr: (number|undefined)\n * }}\n */\nlet SrcsetSourceDef;\n\n/**\n * General grammar: (URL [NUM[w|x]],)*\n * Example 1: \"image1.png 100w, image2.png 50w\"\n * Example 2: \"image1.png 2x, image2.png\"\n * Example 3: \"image1,100w.png 100w, image2.png 50w\"\n */\nconst srcsetRegex = /(\\S+)(?:\\s+(?:(-?\\d+(?:\\.\\d+)?)([a-zA-Z]*)))?\\s*(?:,|$)/g;\n\n/**\n * Extracts `srcset` and fallbacks to `src` if not available.\n * @param {!Element} element\n * @return {!Srcset}\n */\nexport function srcsetFromElement(element) {\n  const srcsetAttr = element.getAttribute('srcset');\n  if (srcsetAttr) {\n    return parseSrcset(srcsetAttr);\n  }\n  // We can't push `src` via `parseSrcset` because URLs in `src` are not always\n  // RFC compliant and can't be easily parsed as an `srcset`. For instance,\n  // they sometimes contain space characters.\n  const srcAttr = userAssert(\n    element.getAttribute('src'),\n    'Either non-empty \"srcset\" or \"src\" attribute must be specified: %s',\n    element\n  );\n  return srcsetFromSrc(srcAttr);\n}\n\n/**\n * Creates a Srcset from a `src` attribute value.\n * @param {string} src\n * @return {!Srcset}\n */\nexport function srcsetFromSrc(src) {\n  return new Srcset([{url: src, width: undefined, dpr: 1}]);\n}\n\n/**\n * Parses the text representation of srcset into Srcset object.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#Attributes.\n * See http://www.w3.org/html/wg/drafts/html/master/semantics.html#attr-img-srcset.\n * @param {string} s\n * @return {!Srcset}\n */\nexport function parseSrcset(s) {\n  const sources = [];\n  let match;\n  while ((match = srcsetRegex.exec(s))) {\n    const url = match[1];\n    let width, dpr;\n    if (match[2]) {\n      const type = match[3].toLowerCase();\n      if (type == 'w') {\n        width = parseInt(match[2], 10);\n      } else if (type == 'x') {\n        dpr = parseFloat(match[2]);\n      } else {\n        continue;\n      }\n    } else {\n      // If no \"w\" or \"x\" specified, we assume it's \"1x\".\n      dpr = 1;\n    }\n    sources.push({url, width, dpr});\n  }\n  return new Srcset(sources);\n}\n\n/**\n * A srcset object contains one or more sources.\n *\n * There are two types of sources: width-based and DPR-based. Only one type\n * of sources allowed to be specified within a single srcset. Depending on a\n * usecase, the components are free to choose any source that best corresponds\n * to the required rendering quality and network and CPU conditions. See\n * \"select\" method for details on how this selection is performed.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#Attributes\n */\nexport class Srcset {\n  /**\n   * @param {!Array<!SrcsetSourceDef>} sources\n   */\n  constructor(sources) {\n    userAssert(sources.length > 0, 'Srcset must have at least one source');\n    /** @private @const {!Array<!SrcsetSourceDef>} */\n    this.sources_ = sources;\n\n    // Only one type of source specified can be used - width or DPR.\n    let hasWidth = false;\n    let hasDpr = false;\n    for (let i = 0; i < sources.length; i++) {\n      const source = sources[i];\n      hasWidth = hasWidth || !!source.width;\n      hasDpr = hasDpr || !!source.dpr;\n    }\n    userAssert(\n      !!(hasWidth ^ hasDpr),\n      'Srcset must have width or dpr sources, but not both'\n    );\n\n    // Source and assert duplicates.\n    sources.sort(hasWidth ? sortByWidth : sortByDpr);\n\n    /** @private @const {boolean} */\n    this.widthBased_ = hasWidth;\n  }\n\n  /**\n   * Performs selection for specified width and DPR. Here, width is the width\n   * in screen pixels and DPR is the device-pixel-ratio or pixel density of\n   * the device. Depending on the circumstances, such as low network conditions,\n   * it's possible to manipulate the result of this method by passing a lower\n   * DPR value.\n   *\n   * The source selection depends on whether this is width-based or DPR-based\n   * srcset.\n   *\n   * In a width-based source, the source's width is the physical width of a\n   * resource (e.g. an image). Depending on the provided DPR, this width is\n   * converted to the screen pixels as following:\n   *   pixelWidth = sourceWidth / DPR\n   *\n   * Then, the source closest to the requested \"width\" is selected using\n   * the \"pixelWidth\". The slight preference is given to the bigger sources to\n   * ensure the most optimal quality.\n   *\n   * In a DPR-based source, the source's DPR is used to return the source that\n   * is closest to the requested DPR.\n   *\n   * Based on\n   * http://www.w3.org/html/wg/drafts/html/master/semantics.html#attr-img-srcset.\n   * @param {number} width\n   * @param {number} dpr\n   * @return {string}\n   */\n  select(width, dpr) {\n    devAssert(width, 'width=%s', width);\n    devAssert(dpr, 'dpr=%s', dpr);\n    let index = 0;\n    if (this.widthBased_) {\n      index = this.selectByWidth_(width * dpr);\n    } else {\n      index = this.selectByDpr_(dpr);\n    }\n    return this.sources_[index].url;\n  }\n\n  /**\n   * @param {number} width\n   * @return {number}\n   * @private\n   */\n  selectByWidth_(width) {\n    const sources = this.sources_;\n    let minIndex = 0;\n    let minScore = Infinity;\n    let minWidth = Infinity;\n\n    for (let i = 0; i < sources.length; i++) {\n      const sWidth = sources[i].width;\n      const score = Math.abs(sWidth - width);\n\n      // Select the one that is closer with a slight preference toward larger\n      // widths. If smaller size is closer, enforce minimum ratio to ensure\n      // image isn't too distorted.\n      if (score <= minScore * 1.1 || width / minWidth > 1.2) {\n        minIndex = i;\n        minScore = score;\n        minWidth = sWidth;\n      } else {\n        break;\n      }\n    }\n    return minIndex;\n  }\n\n  /**\n   * @param {number} dpr\n   * @return {number}\n   * @private\n   */\n  selectByDpr_(dpr) {\n    const sources = this.sources_;\n    let minIndex = 0;\n    let minScore = Infinity;\n\n    for (let i = 0; i < sources.length; i++) {\n      const score = Math.abs(sources[i].dpr - dpr);\n      if (score <= minScore) {\n        minIndex = i;\n        minScore = score;\n      } else {\n        break;\n      }\n    }\n    return minIndex;\n  }\n\n  /**\n   * Returns all URLs in the srcset.\n   * @return {!Array<string>}\n   */\n  getUrls() {\n    return this.sources_.map(s => s.url);\n  }\n\n  /**\n   * Reconstructs the string expression for this srcset.\n   * @param {function(string):string=} opt_mapper\n   * @return {string}\n   */\n  stringify(opt_mapper) {\n    const res = [];\n    const sources = this.sources_;\n    for (let i = 0; i < sources.length; i++) {\n      const source = sources[i];\n      let src = source.url;\n      if (opt_mapper) {\n        src = opt_mapper(src);\n      }\n      if (this.widthBased_) {\n        src += ` ${source.width}w`;\n      } else {\n        src += ` ${source.dpr}x`;\n      }\n      res.push(src);\n    }\n    return res.join(', ');\n  }\n}\n\n/**\n * Sorts by width\n *\n * @param {number} s1\n * @param {number} s2\n * @return {number}\n */\nfunction sortByWidth(s1, s2) {\n  userAssert(s1.width != s2.width, 'Duplicate width: %s', s1.width);\n  return s1.width - s2.width;\n}\n\n/**\n * Sorts by dpr\n *\n * @param {!Object} s1\n * @param {!Object} s2\n * @return {number}\n */\nfunction sortByDpr(s1, s2) {\n  userAssert(s1.dpr != s2.dpr, 'Duplicate dpr: %s', s1.dpr);\n  return s1.dpr - s2.dpr;\n}\n","/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @param {string} _match\n * @param {string} character\n * @return {string}\n */\nfunction toUpperCase(_match, character) {\n  return character.toUpperCase();\n}\n\n/**\n * @param {string} match\n * @return {string}\n */\nfunction prependDashAndToLowerCase(match) {\n  return '-' + match.toLowerCase();\n}\n\n/**\n * @param {string} name Attribute name containing dashes.\n * @return {string} Dashes removed and successive character sent to upper case.\n * visibleForTesting\n */\nexport function dashToCamelCase(name) {\n  return name.replace(/-([a-z])/g, toUpperCase);\n}\n\n/**\n * Converts a string that is in camelCase to one that is in dash-case.\n *\n * @param {string} string The string to convert.\n * @return {string} The string in dash-case.\n */\nexport function camelCaseToDash(string) {\n  return string.replace(/(?!^)[A-Z]/g, prependDashAndToLowerCase);\n}\n\n/**\n * @param {string} name Attribute name with dashes\n * @return {string} Dashes replaced by underlines.\n */\nexport function dashToUnderline(name) {\n  return name.replace('-', '_');\n}\n\n/**\n * Polyfill for String.prototype.endsWith.\n * @param {string} string\n * @param {string} suffix\n * @return {boolean}\n */\nexport function endsWith(string, suffix) {\n  const index = string.length - suffix.length;\n  return index >= 0 && string.indexOf(suffix, index) == index;\n}\n\n/**\n * Polyfill for String.prototype.startsWith.\n * @param {string} string\n * @param {string} prefix\n * @return {boolean}\n */\nexport function startsWith(string, prefix) {\n  if (prefix.length > string.length) {\n    return false;\n  }\n  return string.lastIndexOf(prefix, 0) == 0;\n}\n\n/**\n * Polyfill for String.prototype.includes.\n * @param {string} string\n * @param {string} substring\n * @param {number=} start\n * @return {boolean}\n */\nexport function includes(string, substring, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n  if (start + substring.length > string.length) {\n    return false;\n  }\n  return string.indexOf(substring, start) !== -1;\n}\n\n/**\n * Expands placeholders in a given template string with values.\n *\n * Placeholders use ${key-name} syntax and are replaced with the value\n * returned from the given getter function.\n *\n * @param {string} template The template string to expand.\n * @param {function(string):*} getter Function used to retrieve a value for a\n *   placeholder. Returns values will be coerced into strings.\n * @param {number=} opt_maxIterations Number of times to expand the template.\n *   Defaults to 1, but should be set to a larger value your placeholder tokens\n *   can be expanded to other placeholder tokens. Take caution with large values\n *   as recursively expanding a string can be exponentially expensive.\n * @return {string}\n */\nexport function expandTemplate(template, getter, opt_maxIterations) {\n  const maxIterations = opt_maxIterations || 1;\n  for (let i = 0; i < maxIterations; i++) {\n    let matches = 0;\n    template = template.replace(/\\${([^}]*)}/g, (_a, b) => {\n      matches++;\n      return getter(b);\n    });\n    if (!matches) {\n      break;\n    }\n  }\n  return template;\n}\n\n/**\n * Hash function djb2a\n * This is intended to be a simple, fast hashing function using minimal code.\n * It does *not* have good cryptographic properties.\n * @param {string} str\n * @return {string} 32-bit unsigned hash of the string\n */\nexport function stringHash32(str) {\n  const {length} = str;\n  let hash = 5381;\n  for (let i = 0; i < length; i++) {\n    hash = (hash * 33) ^ str.charCodeAt(i);\n  }\n  // Convert from 32-bit signed to unsigned.\n  return String(hash >>> 0);\n}\n\n/**\n * Trims a string on the end, removing whitespace characters.\n * @param {string} str  A string to trim.\n * @return {string} The string, with trailing whitespace removed.\n */\nexport function trimEnd(str) {\n  // TODO(sparhami) Does this get inlined for an ES2019 build?\n  if (str.trimEnd) {\n    return str.trimEnd();\n  }\n\n  return ('_' + str).trim().slice(1);\n}\n\n/**\n * Trims any leading whitespace from a string.\n * @param {string} str  A string to trim.\n * @return {string} The string, with leading whitespace removed.\n */\nexport function trimStart(str) {\n  if (str.trimStart) {\n    return str.trimStart();\n  }\n\n  return (str + '_').trim().slice(0, -1);\n}\n\n/**\n * Pads the beginning of a string with a substring to a target length.\n * @param {string} s\n * @param {number} targetLength\n * @param {string} padString\n * @return {*} TODO(#23582): Specify return type\n */\nexport function padStart(s, targetLength, padString) {\n  if (s.length >= targetLength) {\n    return s;\n  }\n  targetLength = targetLength - s.length;\n  let padding = padString;\n  while (targetLength > padding.length) {\n    padding += padString;\n  }\n  return padding.slice(0, targetLength) + s;\n}\n","/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* @const */\nconst toString_ = Object.prototype.toString;\n\n/**\n * Returns the ECMA [[Class]] of a value\n * @param {*} value\n * @return {string}\n */\nfunction toString(value) {\n  return toString_.call(value);\n}\n\n/**\n * Determines if value is actually an Array.\n * @param {*} value\n * @return {boolean}\n */\nexport function isArray(value) {\n  return Array.isArray(value);\n}\n\n/**\n * Converts an array-like object to an array.\n * @param {?IArrayLike<T>|string} arrayLike\n * @return {!Array<T>}\n * @template T\n */\nexport function toArray(arrayLike) {\n  return arrayLike ? Array.prototype.slice.call(arrayLike) : [];\n}\n\n/**\n * Determines if value is actually an Object.\n * @param {*} value\n * @return {boolean}\n */\nexport function isObject(value) {\n  return toString(value) === '[object Object]';\n}\n\n/**\n * Determines if value is of number type and finite.\n * NaN and Infinity are not considered a finite number.\n * String numbers are not considered numbers.\n * @param {*} value\n * @return {boolean}\n */\nexport function isFiniteNumber(value) {\n  return typeof value === 'number' && isFinite(value);\n}\n\n/**\n * Checks whether `s` is a valid value of `enumObj`.\n *\n * @param {!Object<T>} enumObj\n * @param {T} s\n * @return {boolean}\n * @template T\n */\nexport function isEnumValue(enumObj, s) {\n  for (const k in enumObj) {\n    if (enumObj[k] === s) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Externs declare that access `defaultView` from `document` or\n * `ownerDocument` is of type `(Window|null)` but most of our parameter types\n * assume that it is never null. This is OK in practice as we ever only get\n * null on disconnected documents or old IE.\n * This helper function casts it into just a simple Window return type.\n *\n * @param {!Window|null} winOrNull\n * @return {!Window}\n */\nexport function toWin(winOrNull) {\n  return /** @type {!Window} */ (winOrNull);\n}\n","/**\n * Copyright 2017 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {tryDecodeUriComponent_} from './url-try-decode-uri-component';\n\nconst regex = /(?:^[#?]?|&)([^=&]+)(?:=([^&]*))?/g;\n\n/**\n * Parses the query string of an URL. This method returns a simple key/value\n * map. If there are duplicate keys the latest value is returned.\n *\n * DO NOT import the function from this file. Instead, import parseQueryString\n * from `src/url.js`.\n *\n * @param {string} queryString\n * @return {!JsonObject}\n */\nexport function parseQueryString_(queryString) {\n  const params = /** @type {!JsonObject} */ (Object.create(null));\n  if (!queryString) {\n    return params;\n  }\n\n  let match;\n  while ((match = regex.exec(queryString))) {\n    const name = tryDecodeUriComponent_(match[1], match[1]);\n    const value = match[2] ? tryDecodeUriComponent_(match[2], match[2]) : '';\n    params[name] = value;\n  }\n  return params;\n}\n","/**\n * Copyright 2019 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  checkCorsUrl,\n  getSourceUrl,\n  isProxyOrigin,\n  parseUrlDeprecated,\n  resolveRelativeUrl,\n} from './url';\nimport {parseSrcset} from './srcset';\nimport {startsWith} from './string';\nimport {urls} from './config';\nimport {user} from './log';\n\nconst TAG = 'URL-REWRITE';\n\n/** @private @const {string} */\nconst ORIGINAL_TARGET_VALUE = '__AMP_ORIGINAL_TARGET_VALUE_';\n\n/**\n * The same as rewriteAttributeValue() but actually updates the element and\n * modifies other related attribute(s) for special cases, i.e. `target` for <a>.\n * @param {!Element} element\n * @param {string} attrName\n * @param {string} attrValue\n * @param {!Location=} opt_location\n * @param {boolean=} opt_updateProperty\n * @return {string}\n */\nexport function rewriteAttributesForElement(\n  element,\n  attrName,\n  attrValue,\n  opt_location,\n  opt_updateProperty\n) {\n  const tag = element.tagName.toLowerCase();\n  const attr = attrName.toLowerCase();\n  const rewrittenValue = rewriteAttributeValue(tag, attr, attrValue);\n  // When served from proxy (CDN), changing an <a> tag from a hash link to a\n  // non-hash link requires updating `target` attribute per cache modification\n  // rules. @see amp-cache-modifications.md#url-rewrites\n  const isProxy = isProxyOrigin(opt_location || self.location);\n  if (isProxy && tag === 'a' && attr === 'href') {\n    const oldValue = element.getAttribute(attr);\n    const newValueIsHash = rewrittenValue[0] === '#';\n    const oldValueIsHash = oldValue && oldValue[0] === '#';\n\n    if (newValueIsHash && !oldValueIsHash) {\n      // Save the original value of `target` so it can be restored (if needed).\n      if (!element[ORIGINAL_TARGET_VALUE]) {\n        element[ORIGINAL_TARGET_VALUE] = element.getAttribute('target');\n      }\n      element.removeAttribute('target');\n    } else if (oldValueIsHash && !newValueIsHash) {\n      // Restore the original value of `target` or default to `_top`.\n      element.setAttribute('target', element[ORIGINAL_TARGET_VALUE] || '_top');\n    }\n  }\n  if (opt_updateProperty) {\n    // Must be done first for <input> elements to correctly update the UI for\n    // the first change on Safari and Chrome.\n    element[attr] = rewrittenValue;\n  }\n  element.setAttribute(attr, rewrittenValue);\n  return rewrittenValue;\n}\n\n/**\n * If (tagName, attrName) is a CDN-rewritable URL attribute, returns the\n * rewritten URL value. Otherwise, returns the unchanged `attrValue`.\n * See resolveUrlAttr() for rewriting rules.\n * @param {string} tagName Lowercase tag name.\n * @param {string} attrName Lowercase attribute name.\n * @param {string} attrValue\n * @return {string}\n * @private\n * @visibleForTesting\n */\nexport function rewriteAttributeValue(tagName, attrName, attrValue) {\n  if (isUrlAttribute(attrName)) {\n    return resolveUrlAttr(tagName, attrName, attrValue, self.location);\n  }\n  return attrValue;\n}\n\n/**\n * @param {string} attrName Lowercase attribute name.\n * @return {boolean}\n */\nexport function isUrlAttribute(attrName) {\n  return attrName == 'src' || attrName == 'href' || attrName == 'srcset';\n}\n\n/**\n * Rewrites the URL attribute values. URLs are rewritten as following:\n * - If URL is absolute, it is not rewritten\n * - If URL is relative, it's rewritten as absolute against the source origin\n * - If resulting URL is a `http:` URL and it's for image, the URL is rewritten\n *   again to be served with AMP Cache (cdn.ampproject.org).\n *\n * @param {string} tagName Lowercase tag name.\n * @param {string} attrName Lowercase attribute name.\n * @param {string} attrValue\n * @param {!Location} windowLocation\n * @return {string}\n * @private\n * @visibleForTesting\n */\nexport function resolveUrlAttr(tagName, attrName, attrValue, windowLocation) {\n  checkCorsUrl(attrValue);\n  const isProxyHost = isProxyOrigin(windowLocation);\n  const baseUrl = parseUrlDeprecated(getSourceUrl(windowLocation));\n\n  if (attrName == 'href' && !startsWith(attrValue, '#')) {\n    return resolveRelativeUrl(attrValue, baseUrl);\n  }\n\n  if (attrName == 'src') {\n    if (tagName == 'amp-img') {\n      return resolveImageUrlAttr(attrValue, baseUrl, isProxyHost);\n    }\n    return resolveRelativeUrl(attrValue, baseUrl);\n  }\n\n  if (attrName == 'srcset') {\n    let srcset;\n    try {\n      srcset = parseSrcset(attrValue);\n    } catch (e) {\n      // Do not fail the whole template just because one srcset is broken.\n      // An AMP element will pick it up and report properly.\n      user().error(TAG, 'Failed to parse srcset: ', e);\n      return attrValue;\n    }\n    return srcset.stringify(url =>\n      resolveImageUrlAttr(url, baseUrl, isProxyHost)\n    );\n  }\n\n  return attrValue;\n}\n\n/**\n * Non-HTTPs image URLs are rewritten via proxy.\n * @param {string} attrValue\n * @param {!Location} baseUrl\n * @param {boolean} isProxyHost\n * @return {string}\n */\nfunction resolveImageUrlAttr(attrValue, baseUrl, isProxyHost) {\n  const src = parseUrlDeprecated(resolveRelativeUrl(attrValue, baseUrl));\n\n  // URLs such as `data:` or proxy URLs are returned as is. Unsafe protocols\n  // do not arrive here - already stripped by the sanitizer.\n  if (src.protocol == 'data:' || isProxyOrigin(src) || !isProxyHost) {\n    return src.href;\n  }\n\n  // Rewrite as a proxy URL.\n  return (\n    `${urls.cdn}/i/` +\n    (src.protocol == 'https:' ? 's/' : '') +\n    encodeURIComponent(src.host) +\n    src.pathname +\n    (src.search || '') +\n    (src.hash || '')\n  );\n}\n","/**\n * Copyright 2017 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Tries to decode a URI component, falling back to opt_fallback (or an empty\n * string)\n *\n * DO NOT import the function from this file. Instead, import\n * tryDecodeUriComponent from `src/url.js`.\n *\n * @param {string} component\n * @param {string=} fallback\n * @return {string}\n */\nexport function tryDecodeUriComponent_(component, fallback = '') {\n  try {\n    return decodeURIComponent(component);\n  } catch (e) {\n    return fallback;\n  }\n}\n","/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {LruCache} from './utils/lru-cache';\nimport {dict, hasOwn} from './utils/object';\nimport {endsWith, startsWith} from './string';\nimport {getMode} from './mode';\nimport {isArray} from './types';\nimport {parseQueryString_} from './url-parse-query-string';\nimport {tryDecodeUriComponent_} from './url-try-decode-uri-component';\nimport {urls} from './config';\nimport {userAssert} from './log';\n\n/**\n * @type {!JsonObject}\n */\nconst SERVING_TYPE_PREFIX = dict({\n  // No viewer\n  'c': true,\n  // In viewer\n  'v': true,\n  // Ad landing page\n  'a': true,\n  // Ad\n  'ad': true,\n  // Actions viewer\n  'action': true,\n});\n\n/**\n * Cached a-tag to avoid memory allocation during URL parsing.\n * @type {HTMLAnchorElement}\n */\nlet a;\n\n/**\n * We cached all parsed URLs. As of now there are no use cases\n * of AMP docs that would ever parse an actual large number of URLs,\n * but we often parse the same one over and over again.\n * @type {LruCache}\n */\nlet cache;\n\n/** @private @const Matches amp_js_* parameters in query string. */\nconst AMP_JS_PARAMS_REGEX = /[?&]amp_js[^&]*/;\n\n/** @private @const Matches amp_gsa parameters in query string. */\nconst AMP_GSA_PARAMS_REGEX = /[?&]amp_gsa[^&]*/;\n\n/** @private @const Matches amp_r parameters in query string. */\nconst AMP_R_PARAMS_REGEX = /[?&]amp_r[^&]*/;\n\n/** @private @const Matches amp_kit parameters in query string. */\nconst AMP_KIT_PARAMS_REGEX = /[?&]amp_kit[^&]*/;\n\n/** @private @const Matches usqp parameters from goog experiment in query string. */\nconst GOOGLE_EXPERIMENT_PARAMS_REGEX = /[?&]usqp[^&]*/;\n\nconst INVALID_PROTOCOLS = [\n  /*eslint no-script-url: 0*/ 'javascript:',\n  /*eslint no-script-url: 0*/ 'data:',\n  /*eslint no-script-url: 0*/ 'vbscript:',\n];\n\n/** @const {string} */\nexport const SOURCE_ORIGIN_PARAM = '__amp_source_origin';\n\n/**\n * Returns the correct origin for a given window.\n * @param {!Window} win\n * @return {string} origin\n */\nexport function getWinOrigin(win) {\n  return win.origin || parseUrlDeprecated(win.location.href).origin;\n}\n\n/**\n * Returns a Location-like object for the given URL. If it is relative,\n * the URL gets resolved.\n * Consider the returned object immutable. This is enforced during\n * testing by freezing the object.\n * @param {string} url\n * @param {boolean=} opt_nocache\n * @return {!Location}\n */\nexport function parseUrlDeprecated(url, opt_nocache) {\n  if (!a) {\n    a = /** @type {!HTMLAnchorElement} */ (self.document.createElement('a'));\n    cache = self.__AMP_URL_CACHE || (self.__AMP_URL_CACHE = new LruCache(100));\n  }\n\n  return parseUrlWithA(a, url, opt_nocache ? null : cache);\n}\n\n/**\n * Returns a Location-like object for the given URL. If it is relative,\n * the URL gets resolved.\n * Consider the returned object immutable. This is enforced during\n * testing by freezing the object.\n * @param {!HTMLAnchorElement} a\n * @param {string} url\n * @param {LruCache=} opt_cache\n * @return {!Location}\n * @restricted\n */\nexport function parseUrlWithA(a, url, opt_cache) {\n  if (opt_cache && opt_cache.has(url)) {\n    return opt_cache.get(url);\n  }\n\n  a.href = url;\n\n  // IE11 doesn't provide full URL components when parsing relative URLs.\n  // Assigning to itself again does the trick #3449.\n  if (!a.protocol) {\n    a.href = a.href;\n  }\n\n  const info = /** @type {!Location} */ ({\n    href: a.href,\n    protocol: a.protocol,\n    host: a.host,\n    hostname: a.hostname,\n    port: a.port == '0' ? '' : a.port,\n    pathname: a.pathname,\n    search: a.search,\n    hash: a.hash,\n    origin: null, // Set below.\n  });\n\n  // Some IE11 specific polyfills.\n  // 1) IE11 strips out the leading '/' in the pathname.\n  if (info.pathname[0] !== '/') {\n    info.pathname = '/' + info.pathname;\n  }\n\n  // 2) For URLs with implicit ports, IE11 parses to default ports while\n  // other browsers leave the port field empty.\n  if (\n    (info.protocol == 'http:' && info.port == 80) ||\n    (info.protocol == 'https:' && info.port == 443)\n  ) {\n    info.port = '';\n    info.host = info.hostname;\n  }\n\n  // For data URI a.origin is equal to the string 'null' which is not useful.\n  // We instead return the actual origin which is the full URL.\n  let origin;\n  if (a.origin && a.origin != 'null') {\n    origin = a.origin;\n  } else if (info.protocol == 'data:' || !info.host) {\n    origin = info.href;\n  } else {\n    origin = info.protocol + '//' + info.host;\n  }\n  info.origin = origin;\n\n  // Freeze during testing to avoid accidental mutation.\n  const frozen = getMode().test && Object.freeze ? Object.freeze(info) : info;\n\n  if (opt_cache) {\n    opt_cache.put(url, frozen);\n  }\n\n  return frozen;\n}\n\n/**\n * Appends the string just before the fragment part (or optionally\n * to the front of the query string) of the URL.\n * @param {string} url\n * @param {string} paramString\n * @param {boolean=} opt_addToFront\n * @return {string}\n */\nexport function appendEncodedParamStringToUrl(\n  url,\n  paramString,\n  opt_addToFront\n) {\n  if (!paramString) {\n    return url;\n  }\n  const mainAndFragment = url.split('#', 2);\n  const mainAndQuery = mainAndFragment[0].split('?', 2);\n\n  let newUrl =\n    mainAndQuery[0] +\n    (mainAndQuery[1]\n      ? opt_addToFront\n        ? `?${paramString}&${mainAndQuery[1]}`\n        : `?${mainAndQuery[1]}&${paramString}`\n      : `?${paramString}`);\n  newUrl += mainAndFragment[1] ? `#${mainAndFragment[1]}` : '';\n  return newUrl;\n}\n/**\n * Appends a query string field and value to a url. `key` and `value`\n * will be ran through `encodeURIComponent` before appending.\n * @param {string} url\n * @param {string} key\n * @param {string} value\n * @param {boolean=} opt_addToFront\n * @return {string}\n */\nexport function addParamToUrl(url, key, value, opt_addToFront) {\n  const field = `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n  return appendEncodedParamStringToUrl(url, field, opt_addToFront);\n}\n\n/**\n * Appends query string fields and values to a url. The `params` objects'\n * `key`s and `value`s will be transformed into query string keys/values.\n * @param {string} url\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\nexport function addParamsToUrl(url, params) {\n  return appendEncodedParamStringToUrl(url, serializeQueryString(params));\n}\n\n/**\n * Append query string fields and values to a url, only if the key does not\n * exist in current query string.\n * @param {string} url\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\nexport function addMissingParamsToUrl(url, params) {\n  const location = parseUrlDeprecated(url);\n  const existingParams = parseQueryString(location.search);\n  const paramsToAdd = dict({});\n  const keys = Object.keys(params);\n  for (let i = 0; i < keys.length; i++) {\n    if (!hasOwn(existingParams, keys[i])) {\n      paramsToAdd[keys[i]] = params[keys[i]];\n    }\n  }\n  return addParamsToUrl(url, paramsToAdd);\n}\n\n/**\n * Serializes the passed parameter map into a query string with both keys\n * and values encoded.\n * @param {!JsonObject<string, string|!Array<string>>} params\n * @return {string}\n */\nexport function serializeQueryString(params) {\n  const s = [];\n  for (const k in params) {\n    const v = params[k];\n    if (v == null) {\n      continue;\n    } else if (isArray(v)) {\n      for (let i = 0; i < v.length; i++) {\n        const sv = /** @type {string} */ (v[i]);\n        s.push(`${encodeURIComponent(k)}=${encodeURIComponent(sv)}`);\n      }\n    } else {\n      const sv = /** @type {string} */ (v);\n      s.push(`${encodeURIComponent(k)}=${encodeURIComponent(sv)}`);\n    }\n  }\n  return s.join('&');\n}\n\n/**\n * Returns `true` if the URL is secure: either HTTPS or localhost (for testing).\n * @param {string|!Location} url\n * @return {boolean}\n */\nexport function isSecureUrlDeprecated(url) {\n  if (typeof url == 'string') {\n    url = parseUrlDeprecated(url);\n  }\n  return (\n    url.protocol == 'https:' ||\n    url.hostname == 'localhost' ||\n    url.hostname == '127.0.0.1' ||\n    endsWith(url.hostname, '.localhost')\n  );\n}\n\n/**\n * Asserts that a given url is HTTPS or protocol relative. It's a user-level\n * assert.\n *\n * Provides an exception for localhost.\n *\n * @param {?string|undefined} urlString\n * @param {!Element|string} elementContext Element where the url was found.\n * @param {string=} sourceName Used for error messages.\n * @return {string}\n */\nexport function assertHttpsUrl(\n  urlString,\n  elementContext,\n  sourceName = 'source'\n) {\n  userAssert(\n    urlString != null,\n    '%s %s must be available',\n    elementContext,\n    sourceName\n  );\n  // (erwinm, #4560): type cast necessary until #4560 is fixed.\n  const theUrlString = /** @type {string} */ (urlString);\n  userAssert(\n    isSecureUrlDeprecated(theUrlString) || /^(\\/\\/)/.test(theUrlString),\n    '%s %s must start with ' +\n      '\"https://\" or \"//\" or be relative and served from ' +\n      'either https or from localhost. Invalid value: %s',\n    elementContext,\n    sourceName,\n    theUrlString\n  );\n  return theUrlString;\n}\n\n/**\n * Asserts that a given url is an absolute HTTP or HTTPS URL.\n * @param {string} urlString\n * @return {string}\n */\nexport function assertAbsoluteHttpOrHttpsUrl(urlString) {\n  userAssert(\n    /^https?\\:/i.test(urlString),\n    'URL must start with \"http://\" or \"https://\". Invalid value: %s',\n    urlString\n  );\n  return parseUrlDeprecated(urlString).href;\n}\n\n/**\n * Parses the query string of an URL. This method returns a simple key/value\n * map. If there are duplicate keys the latest value is returned.\n *\n * This function is implemented in a separate file to avoid a circular\n * dependency.\n *\n * @param {string} queryString\n * @return {!JsonObject}\n */\nexport function parseQueryString(queryString) {\n  return parseQueryString_(queryString);\n}\n\n/**\n * Returns the URL without fragment. If URL doesn't contain fragment, the same\n * string is returned.\n * @param {string} url\n * @return {string}\n */\nexport function removeFragment(url) {\n  const index = url.indexOf('#');\n  if (index == -1) {\n    return url;\n  }\n  return url.substring(0, index);\n}\n\n/**\n * Returns the fragment from the URL. If the URL doesn't contain fragment,\n * the empty string is returned.\n * @param {string} url\n * @return {string}\n */\nexport function getFragment(url) {\n  const index = url.indexOf('#');\n  if (index == -1) {\n    return '';\n  }\n  return url.substring(index);\n}\n\n/**\n * Returns whether the URL has the origin of a proxy.\n * @param {string|!Location} url URL of an AMP document.\n * @return {boolean}\n */\nexport function isProxyOrigin(url) {\n  if (typeof url == 'string') {\n    url = parseUrlDeprecated(url);\n  }\n  return urls.cdnProxyRegex.test(url.origin);\n}\n\n/**\n * For proxy-origin URLs, returns the serving type. Otherwise, returns null.\n * E.g., 'https://amp-com.cdn.ampproject.org/a/s/amp.com/amp_document.html'\n * returns 'a'.\n * @param {string|!Location} url URL of an AMP document.\n * @return {?string}\n */\nexport function getProxyServingType(url) {\n  if (typeof url == 'string') {\n    url = parseUrlDeprecated(url);\n  }\n  if (!isProxyOrigin(url)) {\n    return null;\n  }\n  const path = url.pathname.split('/', 2);\n  return path[1];\n}\n\n/**\n * Returns whether the URL origin is localhost.\n * @param {string|!Location} url URL of an AMP document.\n * @return {boolean}\n */\nexport function isLocalhostOrigin(url) {\n  if (typeof url == 'string') {\n    url = parseUrlDeprecated(url);\n  }\n  return urls.localhostRegex.test(url.origin);\n}\n\n/**\n * Returns whether the URL has valid protocol.\n * Deep link protocol is valid, but not javascript etc.\n * @param {string|!Location} url\n * @return {boolean}\n */\nexport function isProtocolValid(url) {\n  if (!url) {\n    return true;\n  }\n  if (typeof url == 'string') {\n    url = parseUrlDeprecated(url);\n  }\n  return !INVALID_PROTOCOLS.includes(url.protocol);\n}\n\n/**\n * Returns a URL without AMP JS parameters.\n * @param {string} url\n * @return {string}\n */\nexport function removeAmpJsParamsFromUrl(url) {\n  const parsed = parseUrlDeprecated(url);\n  const search = removeAmpJsParamsFromSearch(parsed.search);\n  return parsed.origin + parsed.pathname + search + parsed.hash;\n}\n\n/**\n * Returns a URL without a query string.\n * @param {string} url\n * @return {string}\n */\nexport function removeSearch(url) {\n  const index = url.indexOf('?');\n  if (index == -1) {\n    return url;\n  }\n  const fragment = getFragment(url);\n  return url.substring(0, index) + fragment;\n}\n\n/**\n * Removes parameters that start with amp js parameter pattern and returns the\n * new search string.\n * @param {string} urlSearch\n * @return {string}\n */\nfunction removeAmpJsParamsFromSearch(urlSearch) {\n  if (!urlSearch || urlSearch == '?') {\n    return '';\n  }\n  const search = urlSearch\n    .replace(AMP_JS_PARAMS_REGEX, '')\n    .replace(AMP_GSA_PARAMS_REGEX, '')\n    .replace(AMP_R_PARAMS_REGEX, '')\n    .replace(AMP_KIT_PARAMS_REGEX, '')\n    .replace(GOOGLE_EXPERIMENT_PARAMS_REGEX, '')\n    .replace(/^[?&]/, ''); // Removes first ? or &.\n  return search ? '?' + search : '';\n}\n\n/**\n * Removes parameters with param name and returns the new search string.\n * @param {string} urlSearch\n * @param {string} paramName\n * @return {string}\n */\nexport function removeParamsFromSearch(urlSearch, paramName) {\n  // TODO: reuse the function in removeAmpJsParamsFromSearch. Accept paramNames\n  // as an array.\n  if (!urlSearch || urlSearch == '?') {\n    return '';\n  }\n  const paramRegex = new RegExp(`[?&]${paramName}=[^&]*`, 'g');\n  const search = urlSearch.replace(paramRegex, '').replace(/^[?&]/, '');\n  return search ? '?' + search : '';\n}\n\n/**\n * Returns the source URL of an AMP document for documents served\n * on a proxy origin or directly.\n * @param {string|!Location} url URL of an AMP document.\n * @return {string}\n */\nexport function getSourceUrl(url) {\n  if (typeof url == 'string') {\n    url = parseUrlDeprecated(url);\n  }\n\n  // Not a proxy URL - return the URL itself.\n  if (!isProxyOrigin(url)) {\n    return url.href;\n  }\n\n  // A proxy URL.\n  // Example path that is being matched here.\n  // https://cdn.ampproject.org/c/s/www.origin.com/foo/\n  // The /s/ is optional and signals a secure origin.\n  const path = url.pathname.split('/');\n  const prefix = path[1];\n  userAssert(\n    SERVING_TYPE_PREFIX[prefix],\n    'Unknown path prefix in url %s',\n    url.href\n  );\n  const domainOrHttpsSignal = path[2];\n  const origin =\n    domainOrHttpsSignal == 's'\n      ? 'https://' + decodeURIComponent(path[3])\n      : 'http://' + decodeURIComponent(domainOrHttpsSignal);\n  // Sanity test that what we found looks like a domain.\n  userAssert(origin.indexOf('.') > 0, 'Expected a . in origin %s', origin);\n  path.splice(1, domainOrHttpsSignal == 's' ? 3 : 2);\n  return (\n    origin +\n    path.join('/') +\n    removeAmpJsParamsFromSearch(url.search) +\n    (url.hash || '')\n  );\n}\n\n/**\n * Returns the source origin of an AMP document for documents served\n * on a proxy origin or directly.\n * @param {string|!Location} url URL of an AMP document.\n * @return {string} The source origin of the URL.\n */\nexport function getSourceOrigin(url) {\n  return parseUrlDeprecated(getSourceUrl(url)).origin;\n}\n\n/**\n * Returns absolute URL resolved based on the relative URL and the base.\n * @param {string} relativeUrlString\n * @param {string|!Location} baseUrl\n * @return {string}\n */\nexport function resolveRelativeUrl(relativeUrlString, baseUrl) {\n  if (typeof baseUrl == 'string') {\n    baseUrl = parseUrlDeprecated(baseUrl);\n  }\n  if (typeof URL == 'function') {\n    return new URL(relativeUrlString, baseUrl.href).toString();\n  }\n  return resolveRelativeUrlFallback_(relativeUrlString, baseUrl);\n}\n\n/**\n * Fallback for URL resolver when URL class is not available.\n * @param {string} relativeUrlString\n * @param {string|!Location} baseUrl\n * @return {string}\n * @private Visible for testing.\n */\nexport function resolveRelativeUrlFallback_(relativeUrlString, baseUrl) {\n  if (typeof baseUrl == 'string') {\n    baseUrl = parseUrlDeprecated(baseUrl);\n  }\n  relativeUrlString = relativeUrlString.replace(/\\\\/g, '/');\n  const relativeUrl = parseUrlDeprecated(relativeUrlString);\n\n  // Absolute URL.\n  if (startsWith(relativeUrlString.toLowerCase(), relativeUrl.protocol)) {\n    return relativeUrl.href;\n  }\n\n  // Protocol-relative URL.\n  if (startsWith(relativeUrlString, '//')) {\n    return baseUrl.protocol + relativeUrlString;\n  }\n\n  // Absolute path.\n  if (startsWith(relativeUrlString, '/')) {\n    return baseUrl.origin + relativeUrlString;\n  }\n\n  // Relative path.\n  return (\n    baseUrl.origin +\n    baseUrl.pathname.replace(/\\/[^/]*$/, '/') +\n    relativeUrlString\n  );\n}\n\n/**\n * Add \"__amp_source_origin\" query parameter to the URL.\n * @param {!Window} win\n * @param {string} url\n * @return {string}\n */\nexport function getCorsUrl(win, url) {\n  checkCorsUrl(url);\n  const sourceOrigin = getSourceOrigin(win.location.href);\n  return addParamToUrl(url, SOURCE_ORIGIN_PARAM, sourceOrigin);\n}\n\n/**\n * Checks if the url has __amp_source_origin and throws if it does.\n * @param {string} url\n */\nexport function checkCorsUrl(url) {\n  const parsedUrl = parseUrlDeprecated(url);\n  const query = parseQueryString(parsedUrl.search);\n  userAssert(\n    !(SOURCE_ORIGIN_PARAM in query),\n    'Source origin is not allowed in %s',\n    url\n  );\n}\n\n/**\n * Tries to decode a URI component, falling back to opt_fallback (or an empty\n * string)\n *\n * @param {string} component\n * @param {string=} opt_fallback\n * @return {string}\n */\nexport function tryDecodeUriComponent(component, opt_fallback) {\n  return tryDecodeUriComponent_(component, opt_fallback);\n}\n","/**\n * Copyright 2017 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// TODO(rsimha, #15334): Enable this rule.\n/* eslint jsdoc/check-types: 0 */\n\n/**\n * Creates a function that is evaluated only once and returns the cached result\n * subsequently.\n *\n * Please note that `once` only takes the function definition into account,\n * so it will return the same cached value even when the arguments are\n * different.\n *\n * @param {function(...):T} fn\n * @return {function(...):T}\n * @template T\n */\nexport function once(fn) {\n  let evaluated = false;\n  let retValue = null;\n  let callback = fn;\n  return (...args) => {\n    if (!evaluated) {\n      retValue = callback.apply(self, args);\n      evaluated = true;\n      callback = null; // GC\n    }\n    return retValue;\n  };\n}\n","/**\n * Copyright 2018 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {dev} from '../log';\n\n/** @const {string} */\nconst TAG = 'lru-cache';\n\n/**\n * @template T\n */\nexport class LruCache {\n  /**\n   * @param {number} capacity\n   */\n  constructor(capacity) {\n    /** @private @const {number} */\n    this.capacity_ = capacity;\n\n    /** @private {number} */\n    this.size_ = 0;\n\n    /**\n     * An incrementing counter to define the last access.\n     * @private {number}\n     */\n    this.access_ = 0;\n\n    /** @private {!Object<(number|string), {payload: T, access: number}>} */\n    this.cache_ = Object.create(null);\n  }\n\n  /**\n   * Returns whether key is cached.\n   *\n   * @param {number|string} key\n   * @return {boolean}\n   */\n  has(key) {\n    return !!this.cache_[key];\n  }\n\n  /**\n   * @param {number|string} key\n   * @return {T} The cached payload.\n   */\n  get(key) {\n    const cacheable = this.cache_[key];\n    if (cacheable) {\n      cacheable.access = ++this.access_;\n      return cacheable.payload;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {number|string} key\n   * @param {T} payload The payload to cache.\n   */\n  put(key, payload) {\n    if (!this.has(key)) {\n      this.size_++;\n    }\n    this.cache_[key] = {payload, access: this.access_};\n    this.evict_();\n  }\n\n  /**\n   * Evicts the oldest cache entry, if we've exceeded capacity.\n   */\n  evict_() {\n    if (this.size_ <= this.capacity_) {\n      return;\n    }\n\n    dev().warn(TAG, 'Trimming LRU cache');\n    const cache = this.cache_;\n    let oldest = this.access_ + 1;\n    let oldestKey;\n    for (const key in cache) {\n      const {access} = cache[key];\n      if (access < oldest) {\n        oldest = access;\n        oldestKey = key;\n      }\n    }\n\n    if (oldestKey !== undefined) {\n      delete cache[oldestKey];\n      this.size_--;\n    }\n  }\n}\n","/**\n * Copyright 2015 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {isObject} from '../types';\n\n/* @const */\nconst hasOwn_ = Object.prototype.hasOwnProperty;\n\n/**\n * Returns a map-like object.\n * If opt_initial is provided, copies its own properties into the\n * newly created object.\n * @param {T=} opt_initial This should typically be an object literal.\n * @return {T}\n * @template T\n */\nexport function map(opt_initial) {\n  const obj = Object.create(null);\n  if (opt_initial) {\n    Object.assign(obj, opt_initial);\n  }\n  return obj;\n}\n\n/**\n * Return an empty JsonObject or makes the passed in object literal\n * an JsonObject.\n * The JsonObject type is just a simple object that is at-dict.\n * See\n * https://github.com/google/closure-compiler/wiki/@struct-and-@dict-Annotations\n * for what a dict is type-wise.\n * The linter enforces that the argument is, in fact, at-dict like.\n * @param {!Object=} opt_initial\n * @return {!JsonObject}\n */\nexport function dict(opt_initial) {\n  // We do not copy. The linter enforces that the passed in object is a literal\n  // and thus the caller cannot have a reference to it.\n  return /** @type {!JsonObject} */ (opt_initial || {});\n}\n\n/**\n * Checks if the given key is a property in the map.\n *\n * @param {T}  obj a map like property.\n * @param {string}  key\n * @return {boolean}\n * @template T\n */\nexport function hasOwn(obj, key) {\n  return hasOwn_.call(obj, key);\n}\n\n/**\n * Returns obj[key] iff key is obj's own property (is not inherited).\n * Otherwise, returns undefined.\n *\n * @param {Object} obj\n * @param {string} key\n * @return {*}\n */\nexport function ownProperty(obj, key) {\n  if (hasOwn(obj, key)) {\n    return obj[key];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Deep merges source into target.\n *\n * @param {!Object} target\n * @param {!Object} source\n * @param {number} depth The maximum merge depth. If exceeded, Object.assign\n *                       will be used instead.\n * @return {!Object}\n * @throws {Error} If source contains a circular reference.\n * Note: Only nested objects are deep-merged, primitives and arrays are not.\n */\nexport function deepMerge(target, source, depth = 10) {\n  // Keep track of seen objects to detect recursive references.\n  const seen = [];\n\n  /** @type {!Array<{t: !Object, s: !Object, d: number}>} */\n  const queue = [];\n  queue.push({t: target, s: source, d: 0});\n\n  // BFS to ensure objects don't have recursive references at shallower depths.\n  while (queue.length > 0) {\n    const {t, s, d} = queue.shift();\n    if (seen.includes(s)) {\n      throw new Error('Source object has a circular reference.');\n    }\n    seen.push(s);\n    if (t === s) {\n      continue;\n    }\n    if (d > depth) {\n      Object.assign(t, s);\n      continue;\n    }\n    Object.keys(s).forEach(key => {\n      const newValue = s[key];\n      // Perform a deep merge IFF both target and source have the same key\n      // whose corresponding values are objects.\n      if (hasOwn(t, key)) {\n        const oldValue = t[key];\n        if (isObject(newValue) && isObject(oldValue)) {\n          queue.push({t: oldValue, s: newValue, d: d + 1});\n          return;\n        }\n      }\n      t[key] = newValue;\n    });\n  }\n  return target;\n}\n\n/**\n * @param {!Object} o An object to remove properties from\n * @param {!Array<string>} props A list of properties to remove from the Object\n * @return {!Object} An object with the given properties removed\n */\nexport function omit(o, props) {\n  return Object.keys(o).reduce((acc, key) => {\n    if (!props.includes(key)) {\n      acc[key] = o[key];\n    }\n    return acc;\n  }, {});\n}\n","/**\n * Copyright 2016 The AMP HTML Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Returns a Deferred struct, which holds a pending promise and its associated\n * resolve and reject functions.\n *\n * This is preferred instead of creating a Promise instance to extract the\n * resolve/reject functions yourself:\n *\n * ```\n * // Avoid doing\n * let resolve;\n * const promise = new Promise(res => {\n *   resolve = res;\n * });\n *\n * // Good\n * const deferred = new Deferred();\n * const { promise, resolve } = deferred;\n * ```\n *\n * @template T\n */\nexport class Deferred {\n  /**\n   * Creates an instance of Deferred.\n   */\n  constructor() {\n    let resolve, reject;\n\n    /**\n     * @const {!Promise<T>}\n     */\n    this.promise = new /*OK*/ Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    /**\n     * @const {function(T=)}\n     */\n    this.resolve = resolve;\n\n    /**\n     * @const {function(*=)}\n     */\n    this.reject = reject;\n  }\n}\n\n/**\n * Creates a promise resolved to the return value of fn.\n * If fn sync throws, it will cause the promise to reject.\n *\n * @param {function():T} fn\n * @return {!Promise<T>}\n * @template T\n */\nexport function tryResolve(fn) {\n  return new Promise(resolve => {\n    resolve(fn());\n  });\n}\n\n/**\n * Returns a promise which resolves if a threshold amount of the given promises\n * resolve, and rejects otherwise.\n * @param {!Array<!Promise>} promises The array of promises to test.\n * @param {number} count The number of promises that must resolve for the\n *     returned promise to resolve.\n * @return {!Promise} A promise that resolves if any of the given promises\n *     resolve, and which rejects otherwise.\n */\nexport function some(promises, count = 1) {\n  return new Promise((resolve, reject) => {\n    count = Math.max(count, 0);\n    const extra = promises.length - count;\n    if (extra < 0) {\n      reject(new Error('not enough promises to resolve'));\n    }\n    if (promises.length == 0) {\n      resolve([]);\n    }\n    const values = [];\n    const reasons = [];\n\n    const onFulfilled = value => {\n      if (values.length < count) {\n        values.push(value);\n      }\n      if (values.length == count) {\n        resolve(values);\n      }\n    };\n    const onRejected = reason => {\n      if (reasons.length <= extra) {\n        reasons.push(reason);\n      }\n      if (reasons.length > extra) {\n        reject(reasons);\n      }\n    };\n    for (let i = 0; i < promises.length; i++) {\n      Promise.resolve(promises[i]).then(onFulfilled, onRejected);\n    }\n  });\n}\n\n/**\n * Resolves with the result of the last promise added.\n * @implements {IThenable}\n */\nexport class LastAddedResolver {\n  /**\n   * @param {!Array<!Promise>=} opt_promises\n   */\n  constructor(opt_promises) {\n    let resolve_, reject_;\n    /** @private @const {!Promise} */\n    this.promise_ = new Promise((resolve, reject) => {\n      resolve_ = resolve;\n      reject_ = reject;\n    });\n\n    /** @private */\n    this.resolve_ = resolve_;\n\n    /** @private */\n    this.reject_ = reject_;\n\n    /** @private */\n    this.count_ = 0;\n\n    if (opt_promises) {\n      for (let i = 0; i < opt_promises.length; i++) {\n        this.add(opt_promises[i]);\n      }\n    }\n  }\n\n  /**\n   * Add a promise to possibly be resolved.\n   * @param {!Promise} promise\n   * @return {!Promise}\n   */\n  add(promise) {\n    const countAtAdd = ++this.count_;\n    Promise.resolve(promise).then(\n      result => {\n        if (this.count_ === countAtAdd) {\n          this.resolve_(result);\n        }\n      },\n      error => {\n        // Don't follow behavior of Promise.all and Promise.race error so that\n        // this will only reject when most recently added promise fails.\n        if (this.count_ === countAtAdd) {\n          this.reject_(error);\n        }\n      }\n    );\n    return this.promise_;\n  }\n\n  /** @override */\n  then(opt_resolve, opt_reject) {\n    return this.promise_.then(opt_resolve, opt_reject);\n  }\n}\n","/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */\n\n\n/**\n * This regex consists of 4 matching capture groups and one (non-matching) fallback:\n *\n * - (\\0), catch the null terminator character so it may be replaced by UTF\n *   Replacement Char\n * - ^(-)$, catch a solitary dash char, so that it may be backslash escaped.\n *   This is a separate capture group so that the legal-chars (group 4) doesn't\n *   capture it first, since that group doesn't need to escape its dash.\n * - ([\\x01-\\x1f\\x7f]|^-?[0-9]), catch a UTF control char, or any leading\n *   number (with an optional leading dash). The control or the number (but not\n *   the leading dash) must be hex-escaped,.\n * - ([\\x80-\\uffff0-9a-zA-Z_-]+), catch legal-chars, with the exception of a\n *   solitary dash, which will already have matched in group 1.\n * - [^], finally, a catch-all that allows us to backslash escape the char.\n *\n * Together, this matches everything necessary for CSS.escape.\n */\nvar regex = /(\\0)|^(-)$|([\\x01-\\x1f\\x7f]|^-?[0-9])|([\\x80-\\uffff0-9a-zA-Z_-]+)|[^]/g;\n\nfunction escaper(match, nil, dash, hexEscape, chars) {\n  // Chars is the legal-chars (group 4) capture\n  if (chars) {\n    return chars;\n  }\n  // Nil is the null terminator (group 1) capture\n  if (nil) {\n    return '\\uFFFD';\n  }\n  // Both UTF control chars, and leading numbers (with optional leading dash)\n  // (group 3) must be backslash escaped with a trailing space.  Funnily, the\n  // leading dash must not be escaped, but the number. :shrug:\n  if (hexEscape) {\n    return match.slice(0, -1) + '\\\\' + match.slice(-1).charCodeAt(0).toString(16) + ' '\n  }\n  // Finally, the solitary dash and the catch-all chars require backslash\n  // escaping.\n  return '\\\\' + match;\n}\n\n/**\n * https://drafts.csswg.org/cssom/#serialize-an-identifier\n * @param {string} value\n * @return {string}\n */\nexport function cssEscape(value) {\n  return String(value).replace(regex, escaper);\n}\n","/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false Mustache: true*/\n\nfunction mustacheFactory (mustache) {\n\n  var objectToString = Object.prototype.toString;\n  var isArray = Array.isArray || function isArrayPolyfill (object) {\n    return objectToString.call(object) === '[object Array]';\n  };\n\n  function isFunction (object) {\n    return typeof object === 'function';\n  }\n\n  /**\n   * More correct typeof string handling array\n   * which normally returns typeof 'object'\n   */\n  function typeStr (obj) {\n    return isArray(obj) ? 'array' : typeof obj;\n  }\n\n  function escapeRegExp (string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n  }\n\n  /**\n   * Null safe way of checking whether or not an object,\n   * including its prototype, has a given property\n   */\n  function hasProperty (obj, propName) {\n    return obj != null && typeof obj === 'object' &&\n        Object.prototype.hasOwnProperty.call(obj, propName);\n  }\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  var regExpTest = RegExp.prototype.test;\n  function testRegExp (re, string) {\n    return regExpTest.call(re, string);\n  }\n\n  var nonSpaceRe = /\\S/;\n  function isWhitespace (string) {\n    return !testRegExp(nonSpaceRe, string);\n  }\n\n  var entityMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n  };\n\n  function escapeHtml (string) {\n    return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\n      return entityMap[s];\n    });\n  }\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var equalsRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  /**\n   * Breaks up the given `template` string into a tree of tokens. If the `tags`\n   * argument is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n   * course, the default is to use mustaches (i.e. mustache.tags).\n   *\n   * A token is an array with at least 4 elements. The first element is the\n   * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n   * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n   * all text that appears outside a symbol this element is \"text\".\n   *\n   * The second element of a token is its \"value\". For mustache tags this is\n   * whatever else was inside the tag besides the opening symbol. For text tokens\n   * this is the text itself.\n   *\n   * The third and fourth elements of the token are the start and end indices,\n   * respectively, of the token in the original template.\n   *\n   * Tokens that are the root node of a subtree contain two more elements: 1) an\n   * array of tokens in the subtree and 2) the index in the original template at\n   * which the closing tag for that section begins.\n   */\n  function parseTemplate (template, tags) {\n    if (!template)\n      return [];\n\n    var sections = [];     // Stack to hold section tokens\n    var tokens = [];       // Buffer to hold the tokens\n    var spaces = [];       // Indices of whitespace tokens on the current line\n    var hasTag = false;    // Is there a {{tag}} on the current line?\n    var nonSpace = false;  // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace () {\n      if (hasTag && !nonSpace) {\n        while (spaces.length)\n          delete tokens[spaces.pop()];\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var openingTagRe, closingTagRe, closingCurlyRe;\n    function compileTags (tagsToCompile) {\n      if (typeof tagsToCompile === 'string')\n        tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\n        throw new Error('Invalid tags: ' + tagsToCompile);\n\n      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n      closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n      closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n    }\n\n    compileTags(tags || mustache.tags);\n\n    var scanner = new Scanner(template);\n\n    var start, type, value, chr, token, openSection;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n\n      // Match any text between tags.\n      value = scanner.scanUntil(openingTagRe);\n\n      if (value) {\n        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push([ 'text', chr, start, start + 1 ]);\n          start += 1;\n\n          // Check for whitespace on the current line.\n          if (chr === '\\n')\n            stripSpace();\n        }\n      }\n\n      // Match the opening tag.\n      if (!scanner.scan(openingTagRe))\n        break;\n\n      hasTag = true;\n\n      // Get the tag type.\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe);\n\n      // Get the tag value.\n      if (type === '=') {\n        value = scanner.scanUntil(equalsRe);\n        scanner.scan(equalsRe);\n        scanner.scanUntil(closingTagRe);\n      } else if (type === '{') {\n        value = scanner.scanUntil(closingCurlyRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(closingTagRe);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(closingTagRe);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(closingTagRe))\n        throw new Error('Unclosed tag at ' + scanner.pos);\n\n      token = [ type, value, start, scanner.pos ];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        openSection = sections.pop();\n\n        if (!openSection)\n          throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n        if (openSection[1] !== value)\n          throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      }\n      // ORIGINAL CODE:\n      // else if (type === '=') {\n      //   // Set the tags for the next time around.\n      //   compileTags(value);\n      // }\n      // Fail quitely but do not allow delimiter substitutions. This is\n      // important from the security point of view so that our validators\n      // do not have to parse and interprete all of the mustache's syntax.\n    }\n\n    // Make sure there are no open sections when we're done.\n    openSection = sections.pop();\n\n    if (openSection)\n      throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n    return nestTokens(squashTokens(tokens));\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens (tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          squashedTokens.push(token);\n          lastToken = token;\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens (tokens) {\n    var nestedTokens = [];\n    var collector = nestedTokens;\n    var sections = [];\n\n    var token, section;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n        case '#':\n        case '^':\n          collector.push(token);\n          sections.push(token);\n          collector = token[4] = [];\n          break;\n        case '/':\n          section = sections.pop();\n          section[5] = token[2];\n          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n          break;\n        default:\n          collector.push(token);\n      }\n    }\n\n    return nestedTokens;\n  }\n\n  /**\n   * A simple string scanner that is used by the template parser to find\n   * tokens in template strings.\n   */\n  function Scanner (string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function eos () {\n    return this.tail === '';\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function scan (re) {\n    var match = this.tail.match(re);\n\n    if (!match || match.index !== 0)\n      return '';\n\n    var string = match[0];\n\n    this.tail = this.tail.substring(string.length);\n    this.pos += string.length;\n\n    return string;\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function scanUntil (re) {\n    var index = this.tail.search(re), match;\n\n    switch (index) {\n      case -1:\n        match = this.tail;\n        this.tail = '';\n        break;\n      case 0:\n        match = '';\n        break;\n      default:\n        match = this.tail.substring(0, index);\n        this.tail = this.tail.substring(index);\n    }\n\n    this.pos += match.length;\n\n    return match;\n  };\n\n  /**\n   * Represents a rendering context by wrapping a view object and\n   * maintaining a reference to the parent context.\n   */\n  function Context (view, parentContext) {\n    this.view = view;\n    this.cache = { '.': this.view };\n    this.parent = parentContext;\n  }\n\n  /**\n   * Creates a new context using the given view with this context\n   * as the parent.\n   */\n  Context.prototype.push = function push (view) {\n    return new Context(view, this);\n  };\n\n  /**\n   * Returns the value of the given name in this context, traversing\n   * up the context hierarchy if the value is absent in this context's view.\n   */\n  Context.prototype.lookup = function lookup (name) {\n    var cache = this.cache;\n\n    var value;\n    if (cache.hasOwnProperty(name)) {\n      value = cache[name];\n    } else {\n      var context = this, names, index, lookupHit = false;\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          value = context.view;\n          names = name.split('.');\n          index = 0;\n\n          /**\n           * Using the dot notion path in `name`, we descend through the\n           * nested objects.\n           *\n           * To be certain that the lookup has been successful, we have to\n           * check if the last object in the path actually has the property\n           * we are looking for. We store the result in `lookupHit`.\n           *\n           * This is specially necessary for when the value has been set to\n           * `undefined` and we want to avoid looking up parent contexts.\n           **/\n          while (value != null && index < names.length) {\n            if (!hasProperty(value, names[index])) {\n              value = null;\n              break;\n            }\n            if (index === names.length - 1)\n              lookupHit = true;\n            value = value[names[index++]];\n          }\n        } else {\n          if (!hasProperty(context.view, name)) {\n            value = null;\n          } else {\n            value = context.view[name];\n            lookupHit = true;\n          }\n        }\n\n        if (lookupHit)\n          break;\n\n        context = context.parent;\n      }\n\n      cache[name] = value;\n    }\n\n    if (isFunction(value))\n      value = value.call(this.view);\n\n    return value;\n  };\n\n  /**\n   * A Writer knows how to take a stream of tokens and render them to a\n   * string, given a context. It also maintains a cache of templates to\n   * avoid the need to parse the same template twice.\n   */\n  function Writer () {\n    this.cache = {};\n  }\n\n  /**\n   * Clears all cached templates in this writer.\n   */\n  Writer.prototype.clearCache = function clearCache () {\n    this.cache = {};\n  };\n\n  /**\n   * Parses and caches the given `template` and returns the array of tokens\n   * that is generated from the parse.\n   */\n  Writer.prototype.parse = function parse (template, tags) {\n    var cache = this.cache;\n    var tokens = cache[template];\n\n    if (tokens == null)\n      tokens = cache[template] = parseTemplate(template, tags);\n\n    return tokens;\n  };\n\n  /**\n   * High-level method that is used to render the given `template` with\n   * the given `view`.\n   *\n   * The optional `partials` argument may be an object that contains the\n   * names and templates of partials that are used in the template. It may\n   * also be a function that is used to load partial templates on the fly\n   * that takes a single argument: the name of the partial.\n   */\n  Writer.prototype.render = function render (template, view, partials) {\n    var tokens = this.parse(template);\n    var context = (view instanceof Context) ? view : new Context(view);\n    return this.renderTokens(tokens, context, partials, template);\n  };\n\n  /**\n   * Low-level method that renders the given array of `tokens` using\n   * the given `context` and `partials`.\n   *\n   * Note: The `originalTemplate` is only ever used to extract the portion\n   * of the original template that was contained in a higher-order section.\n   * If the template doesn't use higher-order sections, this argument may\n   * be omitted.\n   */\n  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {\n    var buffer = '';\n\n    var token, symbol, value;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      value = undefined;\n      token = tokens[i];\n      symbol = token[0];\n\n      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);\n      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);\n      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);\n      else if (symbol === '&') value = this.unescapedValue(token, context);\n      else if (symbol === 'name') value = this.escapedValue(token, context);\n      else if (symbol === 'text') value = this.rawValue(token);\n\n      if (value !== undefined)\n        buffer += value;\n    }\n\n    return buffer;\n  };\n\n  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {\n    var self = this;\n    var buffer = '';\n    var value = context.lookup(token[1]);\n\n    // This function is used to render an arbitrary template\n    // in the current context by higher-order sections.\n    function subRender (template) {\n      return self.render(template, context, partials);\n    }\n\n    if (!value) return;\n\n    if (isArray(value)) {\n      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n      }\n    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n    } else if (isFunction(value)) {\n      if (typeof originalTemplate !== 'string')\n        throw new Error('Cannot use higher-order sections without the original template');\n\n      // Extract the portion of the original template that the section contains.\n      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n      if (value != null)\n        buffer += value;\n    } else {\n      buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n    }\n    return buffer;\n  };\n\n  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {\n    var value = context.lookup(token[1]);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0))\n      return this.renderTokens(token[4], context, partials, originalTemplate);\n  };\n\n  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {\n    if (!partials) return;\n\n    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n    if (value != null)\n      return this.renderTokens(this.parse(value), context, partials, value);\n  };\n\n  Writer.prototype.unescapedValue = function unescapedValue (token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null) {\n      if (mustache.sanitizeUnescaped) {\n        return mustache.sanitizeUnescaped(value);\n      }\n      return value;\n    }\n  };\n\n  Writer.prototype.escapedValue = function escapedValue (token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return mustache.escape(value);\n  };\n\n  Writer.prototype.rawValue = function rawValue (token) {\n    return token[1];\n  };\n\n  mustache.name = 'mustache.js';\n  mustache.version = '2.2.0';\n  mustache.tags = [ '{{', '}}' ];\n\n  // All high-level mustache.* functions use this writer.\n  var defaultWriter = new Writer();\n\n  /**\n   * Clears all cached templates in the default writer.\n   */\n  mustache.clearCache = function clearCache () {\n    return defaultWriter.clearCache();\n  };\n\n  /**\n   * Parses and caches the given template in the default writer and returns the\n   * array of tokens it contains. Doing this ahead of time avoids the need to\n   * parse templates on the fly as they are rendered.\n   */\n  mustache.parse = function parse (template, tags) {\n    return defaultWriter.parse(template, tags);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  mustache.render = function render (template, view, partials) {\n    if (typeof template !== 'string') {\n      throw new TypeError('Invalid template! Template should be a \"string\" ' +\n                          'but \"' + typeStr(template) + '\" was given as the first ' +\n                          'argument for mustache#render(template, view, partials)');\n    }\n\n    return defaultWriter.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.,\n  /*eslint-disable */ // eslint wants camel cased function name\n  mustache.to_html = function to_html (template, view, partials, send) {\n    /*eslint-enable*/\n\n    var result = mustache.render(template, view, partials);\n\n    if (isFunction(send)) {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  mustache.escape = escapeHtml;\n\n  // Export the sanitizing function for unescaped values.\n  mustache.sanitizeUnescaped = null;\n  mustache.setUnescapedSanitizer = function setUnescapedSanitizer(sanitizeUnescaped) {\n    mustache.sanitizeUnescaped = sanitizeUnescaped;\n  };\n\n  // Export these mainly for testing, but also for advanced usage.\n  mustache.Scanner = Scanner;\n  mustache.Context = Context;\n  mustache.Writer = Writer;\n\n};\n\nconst Mustache = {};\nmustacheFactory(Mustache);\nexport default Mustache;\n"]}